<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>pageCache</title>
    <link href="/2022/12/05/netty/pageCache/"/>
    <url>/2022/12/05/netty/pageCache/</url>
    
    <content type="html"><![CDATA[<h1 id="pageCache"><a href="#pageCache" class="headerlink" title="pageCache"></a>pageCache</h1><p>对数据进行预读, 例如read() 每次读32KB的数据, 内核会将32～64KB的数据也读取到pageCache中</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>缓存最近被访问的数据</li><li>预读功能</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>不适合读取大文件</li></ul><h3 id="大文件读取"><a href="#大文件读取" class="headerlink" title="大文件读取"></a>大文件读取</h3><p>异步IO + 直接IO方式</p><ul><li>用户进程发起异步IO请求获取数据</li><li>内核态中进行同步IO获取数据</li></ul>]]></content>
    
    
    <categories>
      
      <category>netty</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>netty-零拷贝</title>
    <link href="/2022/11/28/netty/zeroCopy/"/>
    <url>/2022/11/28/netty/zeroCopy/</url>
    
    <content type="html"><![CDATA[<h1 id="数据传输方式"><a href="#数据传输方式" class="headerlink" title="数据传输方式"></a>数据传输方式</h1><h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><p>用户进程发起一个读请求, 内核收到读请求后, 先查看内核空间中是否有存在的数据, 如果已经存在的话, 则直接将数据copy给进程的缓冲区.此时如果数据不存在的话, 则由内核向磁盘发起指令, 要求磁盘读取数据, 磁盘控制器直接把数据写入到内核中的READ缓冲区中, 通过DMA完成. 包含了两次切换<br>上下文切换次数  </p><ul><li>用户态 -&gt; 内核态</li><li>内核态度 -&gt; 用户态</li></ul><p>数据拷贝次数  </p><ul><li>将磁盘中数据copy到内核缓冲区中, 通过DMA 来完成</li><li>将内核缓冲区的数据copy到用户缓冲区中, 此时用户进程可以使用这部分数据, 由CPU完成</li></ul><h2 id="write"><a href="#write" class="headerlink" title="write"></a>write</h2><p>进程如果需要发送一个请求数据, 需要先将用户的缓冲区数据copy到内核的socket缓冲区中, 然后内核通过DMA将数据copy到网卡中, 完成发送<br>上下文切换次数  </p><ul><li>用户态 -&gt; 内核态  </li><li>内核态度 -&gt; 用户态数据</li></ul><p>数据拷贝次数</p><ul><li>将拷贝到用户缓冲区的数据copy到内核的socket 缓冲区中,由CPU完成</li><li>内核缓冲区的数据copy 到网卡的缓冲区中, 通过DMA来完成</li></ul><h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h2><p>在进行IO设备和数据传输的的时候, 数据搬运工作通过DMA控制器来完成, CPU 不负责去处理数据搬运的工作</p><h3 id="搬运过程"><a href="#搬运过程" class="headerlink" title="搬运过程"></a>搬运过程</h3><p>收到磁盘的信号, 将磁盘缓冲区中的数据copy到内核缓冲区中, 此时不再占用CPU资源, 等DMA 读取到了足够多的数据, 发送中断信号给CPU, CPU 收到DMA的信号后, 将内核中的数据copy 到用户空间中, 系统调用返回</p><h1 id="实现零拷贝"><a href="#实现零拷贝" class="headerlink" title="实现零拷贝"></a>实现零拷贝</h1><ul><li>mmap + write</li><li>sendfile</li></ul><h2 id="mmap-write"><a href="#mmap-write" class="headerlink" title="mmap(write)"></a>mmap(write)</h2><p>mmap 是一种文件映射的方法, 可以将一个文件或者其他对象的地址映射到<code>进程</code>的地址空间上, 可以用来减少<code>内核中READ缓冲区到用户缓冲区</code>的一次拷贝, 可以将内核READ缓冲区的数据直接写到内核的socket缓冲区中</p><ul><li>用户进程调用mmap, DMA会将数据copy到内核缓冲区中, 接着用户进程和内核进程共享该缓冲区  <ul><li>上下文切换  <ul><li>用户态 -&gt; 内核态</li><li>内核态 -&gt; 用户态</li></ul></li></ul></li><li>用户调用write方法, 将内核缓冲区的数据写到socket缓冲区中<ul><li>CPU 来将缓冲区数据copy 到 socket缓冲区中</li><li>上下文切换<ul><li>用户态 -&gt; 内核态</li></ul></li></ul></li><li>socket缓冲区数据中copy 到网卡中<ul><li>DMA 来操作完成</li><li>上下文切换<ul><li>内核态 -&gt; 用户态</li></ul></li></ul></li></ul><h2 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">sendfile</span><span class="hljs-params">(<span class="hljs-type">int</span> out_fd, <span class="hljs-type">int</span> in_fd, <span class="hljs-type">off_t</span> *offset, <span class="hljs-type">size_t</span> count)</span>;<br></code></pre></td></tr></table></figure><p>通过sendfile 函数来代理 read() write()函数, 可以降低系统调用, 将上下文切换从4次换成2次  </p><ul><li>用户进程调用sendfile</li><li>内核态收到sendfile 进行数据处理<ul><li>通过DMA 将数据写入到内核缓冲区</li><li>CPU 拷贝将内核缓冲区数据copy 到socket缓冲区</li><li>DMA 拷贝将socket缓冲区数据copy 到网卡上</li></ul></li><li>上下文切换<ul><li>用户态 -&gt; 内核态</li></ul></li><li>数据拷贝次数<ul><li>两次DMA 数据copy, 一次CPU 数据copy</li></ul></li></ul><h2 id="SG-DMA-技术"><a href="#SG-DMA-技术" class="headerlink" title="SG-DMA 技术"></a>SG-DMA 技术</h2><ul><li>用户进程调用sendfile</li><li>内核态收到sendfile 进行数据处理<ul><li>磁盘文件通过DMA copy 到缓冲区中</li><li>缓冲区描述符和数据长度传到socket缓冲区中, 此时SG-DMA控制器可以直接将内核缓冲区的数据copy 到网卡中, 此过程不需要将内核缓冲区的数据copy到socket缓冲区中</li></ul></li><li>上下文切换<ul><li>用户态 -&gt; 内核态</li><li>内核态 -&gt; 用户态</li></ul></li><li>数据拷贝次数<ul><li>两次DMA 数据copy</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>零拷贝指的是全程不需要CPU 进行参与, 所有数据都是通过DMA来进行传输的</li><li>全程只需要2次上下文切换, 2次DMA数据copy</li></ul>]]></content>
    
    
    <categories>
      
      <category>netty</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>zk 集群方式启动选举</title>
    <link href="/2022/11/22/zk/groupMode/"/>
    <url>/2022/11/22/zk/groupMode/</url>
    
    <content type="html"><![CDATA[<h1 id="集群模式启动过程概览"><a href="#集群模式启动过程概览" class="headerlink" title="集群模式启动过程概览"></a>集群模式启动过程概览</h1><p>在集群模式当中指定的main方法为QuorumPeerMain</p><h2 id="读取配置文件"><a href="#读取配置文件" class="headerlink" title="读取配置文件"></a>读取配置文件</h2><p>读取指定的配置文件内容, 将配置文件内容转换成QuorumPeerConfig对象</p><ul><li>配置了三个端口<ul><li>面向客户端的端口  clientPort</li><li>用于数据同步的端口 server.1&#x3D;ip:synPort:electionPort</li><li>用于选举时的端口  server.1&#x3D;ip:synPort:electionPort</li></ul></li></ul><h2 id="开启定时脚本清除"><a href="#开启定时脚本清除" class="headerlink" title="开启定时脚本清除"></a>开启定时脚本清除</h2><p>对log 以及 snapshot 目录下的文件可以通过配置的方式开启定时清除</p><h2 id="开始入口"><a href="#开始入口" class="headerlink" title="开始入口"></a>开始入口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runFromConfig</span><span class="hljs-params">(QuorumPeerConfig config)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>     <span class="hljs-keyword">try</span> &#123;<br>         ManagedUtil.registerLog4jMBeans();<br>     &#125; <span class="hljs-keyword">catch</span> (JMException e) &#123;<br>         LOG.warn(<span class="hljs-string">&quot;Unable to register log4j JMX control&quot;</span>, e);<br>     &#125;<br><br>     LOG.info(<span class="hljs-string">&quot;Starting quorum peer&quot;</span>);<br>     <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-type">ServerCnxnFactory</span> <span class="hljs-variable">cnxnFactory</span> <span class="hljs-operator">=</span> ServerCnxnFactory.createFactory();<br>         cnxnFactory.configure(config.getClientPortAddress(),<br>                 config.getMaxClientCnxns());<br><br>         quorumPeer = getQuorumPeer();<br><br>         quorumPeer.setQuorumPeers(config.getServers());<br>         quorumPeer.setTxnFactory(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileTxnSnapLog</span>(<br>                 <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(config.getDataDir()),<br>                 <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(config.getDataLogDir())));<br>         quorumPeer.setElectionType(config.getElectionAlg());<br>         quorumPeer.setMyid(config.getServerId());<br>         quorumPeer.setTickTime(config.getTickTime());<br>         quorumPeer.setInitLimit(config.getInitLimit());<br>         quorumPeer.setSyncLimit(config.getSyncLimit());<br>         quorumPeer.setQuorumListenOnAllIPs(config.getQuorumListenOnAllIPs());<br>         quorumPeer.setCnxnFactory(cnxnFactory);<br>         quorumPeer.setQuorumVerifier(config.getQuorumVerifier());<br>         quorumPeer.setClientPortAddress(config.getClientPortAddress());<br>         quorumPeer.setMinSessionTimeout(config.getMinSessionTimeout());<br>         quorumPeer.setMaxSessionTimeout(config.getMaxSessionTimeout());<br>         quorumPeer.setZKDatabase(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ZKDatabase</span>(quorumPeer.getTxnFactory()));<br>         quorumPeer.setLearnerType(config.getPeerType());<br>         quorumPeer.setSyncEnabled(config.getSyncEnabled());<br><br>         <span class="hljs-comment">// sets quorum sasl authentication configurations</span><br>         quorumPeer.setQuorumSaslEnabled(config.quorumEnableSasl);<br>         <span class="hljs-keyword">if</span> (quorumPeer.isQuorumSaslAuthEnabled()) &#123;<br>             quorumPeer.setQuorumServerSaslRequired(config.quorumServerRequireSasl);<br>             quorumPeer.setQuorumLearnerSaslRequired(config.quorumLearnerRequireSasl);<br>             quorumPeer.setQuorumServicePrincipal(config.quorumServicePrincipal);<br>             quorumPeer.setQuorumServerLoginContext(config.quorumServerLoginContext);<br>             quorumPeer.setQuorumLearnerLoginContext(config.quorumLearnerLoginContext);<br>         &#125;<br><br>         quorumPeer.setQuorumCnxnThreadsSize(config.quorumCnxnThreadsSize);<br>         quorumPeer.initialize();<br><br>         quorumPeer.start();<br>         quorumPeer.join();<br>     &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>         <span class="hljs-comment">// warn, but generally this is ok</span><br>         LOG.warn(<span class="hljs-string">&quot;Quorum Peer interrupted&quot;</span>, e);<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><ul><li>ServerCnxnFactory 默认使用NIOServerCnxnFactory</li><li>NIOServerCnxnFactory 配置好面向客户端使用的端口和最大连接数</li></ul><h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>    loadDataBase();<br>    cnxnFactory.start();        <br>    startLeaderElection();<br>    <span class="hljs-built_in">super</span>.start();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="加载缓存数据"><a href="#加载缓存数据" class="headerlink" title="加载缓存数据"></a>加载缓存数据</h3><h3 id="bind客户端监听端口"><a href="#bind客户端监听端口" class="headerlink" title="bind客户端监听端口"></a>bind客户端监听端口</h3><h3 id="投票前准备好数据-绑定选举的端口"><a href="#投票前准备好数据-绑定选举的端口" class="headerlink" title="投票前准备好数据, 绑定选举的端口"></a>投票前准备好数据, 绑定选举的端口</h3><p><img src="/img/zk/select.jpg"><br>选举算法配置参数为electionAlg,默认为3,因此采用 QuorumCnxManager</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Election <span class="hljs-title function_">createElectionAlgorithm</span><span class="hljs-params">(<span class="hljs-type">int</span> electionAlgorithm)</span>&#123;<br>    Election le=<span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> use a factory rather than a switch</span><br>    <span class="hljs-keyword">switch</span> (electionAlgorithm) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>        le = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LeaderElection</span>(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        le = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AuthFastLeaderElection</span>(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        le = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AuthFastLeaderElection</span>(<span class="hljs-built_in">this</span>, <span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>        qcm = createCnxnManager();<br>        QuorumCnxManager.<span class="hljs-type">Listener</span> <span class="hljs-variable">listener</span> <span class="hljs-operator">=</span> qcm.listener;<br>        <span class="hljs-keyword">if</span>(listener != <span class="hljs-literal">null</span>)&#123;<br>            listener.start();<br>            le = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FastLeaderElection</span>(<span class="hljs-built_in">this</span>, qcm);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            LOG.error(<span class="hljs-string">&quot;Null listener when initializing cnx manager&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">assert</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> le;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="绑定选举端口"><a href="#绑定选举端口" class="headerlink" title="绑定选举端口"></a>绑定选举端口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">numRetries</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>     InetSocketAddress addr;<br>     <span class="hljs-keyword">while</span>((!shutdown) &amp;&amp; (numRetries &lt; <span class="hljs-number">3</span>))&#123;<br>         <span class="hljs-keyword">try</span> &#123;<br>             ss = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>();<br>             ss.setReuseAddress(<span class="hljs-literal">true</span>);<br>             <span class="hljs-keyword">if</span> (listenOnAllIPs) &#123;<br>                 <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> view.get(QuorumCnxManager.<span class="hljs-built_in">this</span>.mySid)<br>                     .electionAddr.getPort();<br>                 addr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(port);<br>             &#125; <span class="hljs-keyword">else</span> &#123;<br>                 addr = view.get(QuorumCnxManager.<span class="hljs-built_in">this</span>.mySid)<br>                     .electionAddr;<br>             &#125;<br>             LOG.info(<span class="hljs-string">&quot;My election bind port: &quot;</span> + addr.toString());<br>             setName(view.get(QuorumCnxManager.<span class="hljs-built_in">this</span>.mySid)<br>                     .electionAddr.toString());<br>             ss.bind(addr);<br>             <span class="hljs-keyword">while</span> (!shutdown) &#123;<br>                 <span class="hljs-type">Socket</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> ss.accept();<br>                 setSockOpts(client);<br>                 LOG.info(<span class="hljs-string">&quot;Received connection request &quot;</span><br>                         + client.getRemoteSocketAddress());<br><br>                 <span class="hljs-comment">// Receive and handle the connection request</span><br>                 <span class="hljs-comment">// asynchronously if the quorum sasl authentication is</span><br>                 <span class="hljs-comment">// enabled. This is required because sasl server</span><br>                 <span class="hljs-comment">// authentication process may take few seconds to finish,</span><br>                 <span class="hljs-comment">// this may delay next peer connection requests.</span><br>                 <span class="hljs-keyword">if</span> (quorumSaslAuthEnabled) &#123;<br>                     receiveConnectionAsync(client);<br>                 &#125; <span class="hljs-keyword">else</span> &#123;<br>                     receiveConnection(client);<br>                 &#125;<br><br>                 numRetries = <span class="hljs-number">0</span>;<br>             &#125;<br>         &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>             LOG.error(<span class="hljs-string">&quot;Exception while listening&quot;</span>, e);<br>             numRetries++;<br>             <span class="hljs-keyword">try</span> &#123;<br>                 ss.close();<br>                 Thread.sleep(<span class="hljs-number">1000</span>);<br>             &#125; <span class="hljs-keyword">catch</span> (IOException ie) &#123;<br>                 LOG.error(<span class="hljs-string">&quot;Error closing server socket&quot;</span>, ie);<br>             &#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;<br>                 LOG.error(<span class="hljs-string">&quot;Interrupted while sleeping. &quot;</span> +<br>                           <span class="hljs-string">&quot;Ignoring exception&quot;</span>, ie);<br>             &#125;<br>         &#125;<br>     &#125;<br>     LOG.info(<span class="hljs-string">&quot;Leaving listener&quot;</span>);<br>     <span class="hljs-keyword">if</span> (!shutdown) &#123;<br>         LOG.error(<span class="hljs-string">&quot;As I&#x27;m leaving the listener thread, &quot;</span><br>                 + <span class="hljs-string">&quot;I won&#x27;t be able to participate in leader &quot;</span><br>                 + <span class="hljs-string">&quot;election any longer: &quot;</span><br>                 + view.get(QuorumCnxManager.<span class="hljs-built_in">this</span>.mySid).electionAddr);<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h4 id="处理接受到的请求"><a href="#处理接受到的请求" class="headerlink" title="处理接受到的请求"></a>处理接受到的请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//If wins the challenge, then close the new connection.</span><br> <span class="hljs-comment">//保证只有sid大的发给小的</span><br> <span class="hljs-keyword">if</span> (sid &lt; <span class="hljs-built_in">this</span>.mySid) &#123;<br>     <span class="hljs-comment">/*</span><br><span class="hljs-comment">      * This replica might still believe that the connection to sid is</span><br><span class="hljs-comment">      * up, so we have to shut down the workers before trying to open a</span><br><span class="hljs-comment">      * new connection.</span><br><span class="hljs-comment">      */</span><br>     <span class="hljs-type">SendWorker</span> <span class="hljs-variable">sw</span> <span class="hljs-operator">=</span> senderWorkerMap.get(sid);<br>     <span class="hljs-keyword">if</span> (sw != <span class="hljs-literal">null</span>) &#123;<br>         sw.finish();<br>     &#125;<br><br>     <span class="hljs-comment">/*</span><br><span class="hljs-comment">      * Now we start a new connection</span><br><span class="hljs-comment">      */</span><br>     LOG.debug(<span class="hljs-string">&quot;Create new connection to server: &quot;</span> + sid);<br>     closeSocket(sock);<br>     connectOne(sid);<br><br>     <span class="hljs-comment">// Otherwise start worker threads to receive data.</span><br> &#125; <span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-comment">//sendWorker 绑定socket</span><br>     <span class="hljs-type">SendWorker</span> <span class="hljs-variable">sw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SendWorker</span>(sock, sid);<br>     <span class="hljs-comment">//recvWorker 绑定socket</span><br>     <span class="hljs-type">RecvWorker</span> <span class="hljs-variable">rw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RecvWorker</span>(sock, din, sid, sw);<br>     sw.setRecv(rw);<br><br>     <span class="hljs-type">SendWorker</span> <span class="hljs-variable">vsw</span> <span class="hljs-operator">=</span> senderWorkerMap.get(sid);<br>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">      * 如果以前有绑定过相同的sid, 则将以前的sendWorker进行下掉</span><br><span class="hljs-comment">      * 由于关联了recvWorker, 在进行finish的同时,recvWorker也会结束</span><br><span class="hljs-comment">      */</span><br>     <span class="hljs-keyword">if</span>(vsw != <span class="hljs-literal">null</span>)<br>         vsw.finish();<br><br>     senderWorkerMap.put(sid, sw);<br>     queueSendMap.putIfAbsent(sid, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;ByteBuffer&gt;(SEND_CAPACITY));<br><br>     sw.start();<br>     rw.start();<br><br>     <span class="hljs-keyword">return</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="zk选举发送接收线程概览"><a href="#zk选举发送接收线程概览" class="headerlink" title="zk选举发送接收线程概览"></a>zk选举发送接收线程概览</h4><p><img src="/img/zk/send.recv.dispose.thrad.jpg"></p><ul><li>通过sendWorker、recvWorker、WorkerSender、WorkerReceiver去处理发送 选举时的相关请求</li></ul><h5 id="sendWorker"><a href="#sendWorker" class="headerlink" title="sendWorker"></a>sendWorker</h5><p>用于选举投票时发送数据</p><h6 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">SendWorker(Socket sock, Long sid) &#123;<br>    <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;SendWorker:&quot;</span> + sid);<br>    <span class="hljs-built_in">this</span>.sid = sid;<br>    <span class="hljs-built_in">this</span>.sock = sock;<br>    recvWorker = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        dout = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(sock.getOutputStream());<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        LOG.error(<span class="hljs-string">&quot;Unable to access socket output stream&quot;</span>, e);<br>        closeSocket(sock);<br>        running = <span class="hljs-literal">false</span>;<br>    &#125;<br>    LOG.debug(<span class="hljs-string">&quot;Address of remote peer: &quot;</span> + <span class="hljs-built_in">this</span>.sid);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>绑定socket 连接</li><li>绑定svrId</li></ul><h6 id="主要处理内容"><a href="#主要处理内容" class="headerlink" title="主要处理内容"></a>主要处理内容</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    threadCnt.incrementAndGet();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * If there is nothing in the queue to send, then we</span><br><span class="hljs-comment">         * send the lastMessage to ensure that the last message</span><br><span class="hljs-comment">         * was received by the peer. The message could be dropped</span><br><span class="hljs-comment">         * in case self or the peer shutdown their connection</span><br><span class="hljs-comment">         * (and exit the thread) prior to reading/processing</span><br><span class="hljs-comment">         * the last message. Duplicate messages are handled correctly</span><br><span class="hljs-comment">         * by the peer.</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * If the send queue is non-empty, then we have a recent</span><br><span class="hljs-comment">         * message than that stored in lastMessage. To avoid sending</span><br><span class="hljs-comment">         * stale message, we should send the message in the send queue.</span><br><span class="hljs-comment">         */</span><br>        ArrayBlockingQueue&lt;ByteBuffer&gt; bq = queueSendMap.get(sid);<br>        <span class="hljs-keyword">if</span> (bq == <span class="hljs-literal">null</span> || isSendQueueEmpty(bq)) &#123;<br>           <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> lastMessageSent.get(sid);<br>           <span class="hljs-keyword">if</span> (b != <span class="hljs-literal">null</span>) &#123;<br>               LOG.debug(<span class="hljs-string">&quot;Attempting to send lastMessage to sid=&quot;</span> + sid);<br>               send(b);<br>           &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        LOG.error(<span class="hljs-string">&quot;Failed to send last message. Shutting down thread.&quot;</span>, e);<br>        <span class="hljs-built_in">this</span>.finish();<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (running &amp;&amp; !shutdown &amp;&amp; sock != <span class="hljs-literal">null</span>) &#123;<br><br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//通过sid从queueSendMap获取需要发送的数据, 选举时需要给外部发送请求的数据放在该队列里面</span><br>                ArrayBlockingQueue&lt;ByteBuffer&gt; bq = queueSendMap<br>                        .get(sid);<br>                <span class="hljs-keyword">if</span> (bq != <span class="hljs-literal">null</span>) &#123;<br>                    b = pollSendQueue(bq, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    LOG.error(<span class="hljs-string">&quot;No queue of incoming messages for &quot;</span> +<br>                              <span class="hljs-string">&quot;server &quot;</span> + sid);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span>(b != <span class="hljs-literal">null</span>)&#123;<br>                    lastMessageSent.put(sid, b);<br>                    <span class="hljs-comment">//发送数据</span><br>                    send(b);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                LOG.warn(<span class="hljs-string">&quot;Interrupted while waiting for message on queue&quot;</span>,<br>                        e);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        LOG.warn(<span class="hljs-string">&quot;Exception when using channel: for id &quot;</span> + sid<br>                 + <span class="hljs-string">&quot; my id = &quot;</span> + QuorumCnxManager.<span class="hljs-built_in">this</span>.mySid<br>                 + <span class="hljs-string">&quot; error = &quot;</span> + e);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.finish();<br>    LOG.warn(<span class="hljs-string">&quot;Send worker leaving thread&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>sendWorker 就是通过queueSendMap 获取到数据, 然后将数据进行发送</li><li>lastMessageSent 是为了防止接收方接受到消息之前或者处理消息是不可用了, 则进行重复发送, 同时接收方接受到同样的消息时, 需要进行处理</li></ul><p>####### send逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(ByteBuffer b)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">byte</span>[] msgBytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[b.capacity()];<br>    <span class="hljs-keyword">try</span> &#123;<br>        b.position(<span class="hljs-number">0</span>);<br>        b.get(msgBytes);<br>    &#125; <span class="hljs-keyword">catch</span> (BufferUnderflowException be) &#123;<br>        LOG.error(<span class="hljs-string">&quot;BufferUnderflowException &quot;</span>, be);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    dout.writeInt(b.capacity());<br>    dout.write(b.array());<br>    dout.flush();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="recvWorker"><a href="#recvWorker" class="headerlink" title="recvWorker"></a>recvWorker</h5><p>用于选举投票时处理接受请求并处理数据</p><h6 id="构造-1"><a href="#构造-1" class="headerlink" title="构造"></a>构造</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">RecvWorker(Socket sock, DataInputStream din, Long sid, SendWorker sw) &#123;<br>    <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;RecvWorker:&quot;</span> + sid);<br>    <span class="hljs-built_in">this</span>.sid = sid;<br>    <span class="hljs-built_in">this</span>.sock = sock;<br>    <span class="hljs-built_in">this</span>.sw = sw;<br>    <span class="hljs-built_in">this</span>.din = din;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// OK to wait until socket disconnects while reading.</span><br>        sock.setSoTimeout(<span class="hljs-number">0</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        LOG.error(<span class="hljs-string">&quot;Error while accessing socket for &quot;</span> + sid, e);<br>        closeSocket(sock);<br>        running = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="run"><a href="#run" class="headerlink" title="run"></a>run</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    threadCnt.incrementAndGet();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (running &amp;&amp; !shutdown &amp;&amp; sock != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * Reads the first int to determine the length of the</span><br><span class="hljs-comment">             * message</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> din.readInt();<br>            <span class="hljs-keyword">if</span> (length &lt;= <span class="hljs-number">0</span> || length &gt; PACKETMAXSIZE) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<br>                        <span class="hljs-string">&quot;Received packet with invalid packet: &quot;</span><br>                                + length);<br>            &#125;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * Allocates a new ByteBuffer to receive the message</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-type">byte</span>[] msgArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[length];<br>            din.readFully(msgArray, <span class="hljs-number">0</span>, length);<br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(msgArray);<br>            addToRecvQueue(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(message.duplicate(), sid));<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        LOG.warn(<span class="hljs-string">&quot;Connection broken for id &quot;</span> + sid + <span class="hljs-string">&quot;, my id = &quot;</span><br>                 + QuorumCnxManager.<span class="hljs-built_in">this</span>.mySid + <span class="hljs-string">&quot;, error = &quot;</span> , e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        LOG.warn(<span class="hljs-string">&quot;Interrupting SendWorker&quot;</span>);<br>        sw.finish();<br>        <span class="hljs-keyword">if</span> (sock != <span class="hljs-literal">null</span>) &#123;<br>            closeSocket(sock);<br>        &#125;<br>    &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>处理接受到的请求数据, 将接受到的请求数据放到recvQueue 中</li></ul><h6 id="addToRecvQueue"><a href="#addToRecvQueue" class="headerlink" title="addToRecvQueue"></a>addToRecvQueue</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addToRecvQueue</span><span class="hljs-params">(Message msg)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span>(recvQLock) &#123;<br>        <span class="hljs-keyword">if</span> (recvQueue.remainingCapacity() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                recvQueue.remove();<br>            &#125; <span class="hljs-keyword">catch</span> (NoSuchElementException ne) &#123;<br>                <span class="hljs-comment">// element could be removed by poll()</span><br>                 LOG.debug(<span class="hljs-string">&quot;Trying to remove from an empty &quot;</span> +<br>                     <span class="hljs-string">&quot;recvQueue. Ignoring exception &quot;</span> + ne);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            recvQueue.add(msg);<br>        &#125; <span class="hljs-keyword">catch</span> (IllegalStateException ie) &#123;<br>            <span class="hljs-comment">// This should never happen</span><br>            LOG.error(<span class="hljs-string">&quot;Unable to insert element in the recvQueue &quot;</span> + ie);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果接受到的队列满了, 则删除队首元素, 在往recvQueue 去添加数据</li></ul><h5 id="WorkerSender"><a href="#WorkerSender" class="headerlink" title="WorkerSender"></a>WorkerSender</h5><h6 id="构造-2"><a href="#构造-2" class="headerlink" title="构造"></a>构造</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">WorkerSender(QuorumCnxManager manager)&#123;<br>    <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;WorkerSender&quot;</span>);<br>    <span class="hljs-built_in">this</span>.stop = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">this</span>.manager = manager;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="处理逻辑"><a href="#处理逻辑" class="headerlink" title="处理逻辑"></a>处理逻辑</h6><p>####### 从sendQueue中获取数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">while</span> (!stop) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ToSend</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> sendqueue.poll(<span class="hljs-number">3000</span>, TimeUnit.MILLISECONDS);<br>            <span class="hljs-keyword">if</span>(m == <span class="hljs-literal">null</span>) <span class="hljs-keyword">continue</span>;<br><br>            process(m);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    LOG.info(<span class="hljs-string">&quot;WorkerSender is down&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>####### 处理消息并发送</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(ToSend m)</span> &#123;<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">requestBuffer</span> <span class="hljs-operator">=</span> buildMsg(m.state.ordinal(),<br>                                            m.leader,<br>                                            m.zxid,<br>                                            m.electionEpoch,<br>                                            m.peerEpoch);<br>    manager.toSend(m.sid, requestBuffer);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">toSend</span><span class="hljs-params">(Long sid, ByteBuffer b)</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * If sending message to myself, then simply enqueue it (loopback).</span><br><span class="hljs-comment">     * 如果是要发送给自己的, 则将内容直接放到接收队列中去</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.mySid == sid) &#123;<br>         b.position(<span class="hljs-number">0</span>);<br>         addToRecvQueue(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(b.duplicate(), sid));<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Otherwise send to the corresponding thread to send.</span><br><span class="hljs-comment">         */</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-comment">/*</span><br><span class="hljs-comment">          * Start a new connection if doesn&#x27;t have one already.</span><br><span class="hljs-comment">          * 查看对方id 是否存在要发送的缓存queue, 如果没有的话, 创建一个新的queue, 已经有的话往缓存queue中添加数据,</span><br><span class="hljs-comment">          *  worker 则从queueSendMap中获取对应的数据去进行消费</span><br><span class="hljs-comment">          */</span><br>         ArrayBlockingQueue&lt;ByteBuffer&gt; bq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;ByteBuffer&gt;(SEND_CAPACITY);<br>         ArrayBlockingQueue&lt;ByteBuffer&gt; bqExisting = queueSendMap.putIfAbsent(sid, bq);<br>         <span class="hljs-keyword">if</span> (bqExisting != <span class="hljs-literal">null</span>) &#123;<br>             addToSendQueue(bqExisting, b);<br>         &#125; <span class="hljs-keyword">else</span> &#123;<br>             addToSendQueue(bq, b);<br>         &#125;<br>         connectOne(sid);<br><br>    &#125;<br>&#125;<br>...<br><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connectOne</span><span class="hljs-params">(<span class="hljs-type">long</span> sid)</span>&#123;<br>  <span class="hljs-keyword">if</span> (!connectedToPeer(sid))&#123;<br>    ...<br>    <span class="hljs-type">Socket</span> <span class="hljs-variable">sock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>();<br>    setSockOpts(sock);<br>    sock.connect(view.get(sid).electionAddr, cnxTO);<br>    ...<br>    initiateConnection(sock, sid);  <br>    ...<br>  &#125;  <br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initiateConnection</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Socket sock, <span class="hljs-keyword">final</span> Long sid)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        startConnection(sock, sid);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        ...<br>    &#125;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startConnection</span><span class="hljs-params">(Socket sock, Long sid)</span><br>            <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">dout</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">DataInputStream</span> <span class="hljs-variable">din</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// Sending id and challenge</span><br>        dout = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(sock.getOutputStream());<br>        dout.writeLong(<span class="hljs-built_in">this</span>.mySid);<br>        dout.flush();<br><br>        din = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(sock.getInputStream()));<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        LOG.warn(<span class="hljs-string">&quot;Ignoring exception reading or writing challenge: &quot;</span>, e);<br>        closeSocket(sock);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;   <br>    <span class="hljs-keyword">if</span> (sid &gt; <span class="hljs-built_in">this</span>.mySid) &#123;<br>        LOG.info(<span class="hljs-string">&quot;Have smaller server identifier, so dropping the &quot;</span> +<br>                 <span class="hljs-string">&quot;connection: (&quot;</span> + sid + <span class="hljs-string">&quot;, &quot;</span> + <span class="hljs-built_in">this</span>.mySid + <span class="hljs-string">&quot;)&quot;</span>);<br>        closeSocket(sock);<br>        <span class="hljs-comment">// Otherwise proceed with the connection</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">SendWorker</span> <span class="hljs-variable">sw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SendWorker</span>(sock, sid);<br>        <span class="hljs-type">RecvWorker</span> <span class="hljs-variable">rw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RecvWorker</span>(sock, din, sid, sw);<br>        sw.setRecv(rw);<br><br>        <span class="hljs-type">SendWorker</span> <span class="hljs-variable">vsw</span> <span class="hljs-operator">=</span> senderWorkerMap.get(sid);<br><br>        <span class="hljs-keyword">if</span>(vsw != <span class="hljs-literal">null</span>)<br>            vsw.finish();<br><br>        senderWorkerMap.put(sid, sw);<br>        queueSendMap.putIfAbsent(sid, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;ByteBuffer&gt;(SEND_CAPACITY));<br><br>        sw.start();<br>        rw.start();<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>根据要接受方的sid 从queueSendMap中查看是否有发送的消息队列<ul><li>没有则创建, 将需要发送的数据放到队列中</li><li>有的话, 则用已有的队列去进行获取发送</li></ul></li><li>根据sid 查看和对方是有有sendWorker线程, 该线程会一直去消费queueSendMap 中的消息队列<ul><li>sendWorker 会由于对方请求断了, 从而将线程给中断</li></ul></li><li>如果没有的话创建和对方的连接<ul><li>如果自己的对方的id 比自己的大的话, 则关闭连接, sid大的给小的去发送请求</li><li>创建sendWorker 和 recvWorker 线程, 两个线程绑定对应的socket</li></ul></li></ul><h5 id="WorkerReceiver"><a href="#WorkerReceiver" class="headerlink" title="WorkerReceiver"></a>WorkerReceiver</h5><h6 id="构造-3"><a href="#构造-3" class="headerlink" title="构造"></a>构造</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">WorkerReceiver(QuorumCnxManager manager) &#123;<br>    <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;WorkerReceiver&quot;</span>);<br>    <span class="hljs-built_in">this</span>.stop = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">this</span>.manager = manager;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br>     Message response;<br>     <span class="hljs-keyword">while</span> (!stop) &#123;<br>         <span class="hljs-comment">// Sleeps on receive</span><br>         <span class="hljs-keyword">try</span>&#123;<br>             <span class="hljs-comment">//从qcm中获取响应</span><br>             response = manager.pollRecvQueue(<span class="hljs-number">3000</span>, TimeUnit.MILLISECONDS);<br>             <span class="hljs-keyword">if</span>(response == <span class="hljs-literal">null</span>) <span class="hljs-keyword">continue</span>;<br><br>             <span class="hljs-comment">/*</span><br><span class="hljs-comment">              * If it is from an observer, respond right away.</span><br><span class="hljs-comment">              * Note that the following predicate assumes that</span><br><span class="hljs-comment">              * if a server is not a follower, then it must be</span><br><span class="hljs-comment">              * an observer. If we ever have any other type of</span><br><span class="hljs-comment">              * learner in the future, we&#x27;ll have to change the</span><br><span class="hljs-comment">              * way we check for observers.</span><br><span class="hljs-comment">              * 如果请求是来自于observer则立马进行响应, 因为observer 不需要进行选举投票</span><br><span class="hljs-comment">              */</span><br>             <span class="hljs-keyword">if</span>(!self.getVotingView().containsKey(response.sid))&#123;<br>                 <span class="hljs-type">Vote</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> self.getCurrentVote();<br>                 <span class="hljs-type">ToSend</span> <span class="hljs-variable">notmsg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ToSend</span>(ToSend.mType.notification,<br>                         current.getId(),<br>                         current.getZxid(),<br>                         logicalclock.get(),<br>                         self.getPeerState(),<br>                         response.sid,<br>                         current.getPeerEpoch());<br><br>                 sendqueue.offer(notmsg);<br>             &#125; <span class="hljs-keyword">else</span> &#123;<br>                 <span class="hljs-comment">// Receive new message</span><br>                 <span class="hljs-keyword">if</span> (LOG.isDebugEnabled()) &#123;<br>                     LOG.debug(<span class="hljs-string">&quot;Receive new notification message. My id = &quot;</span><br>                             + self.getId());<br>                 &#125;<br><br>                 <span class="hljs-comment">/*</span><br><span class="hljs-comment">                  * We check for 28 bytes for backward compatibility</span><br><span class="hljs-comment">                  */</span><br>                 <span class="hljs-keyword">if</span> (response.buffer.capacity() &lt; <span class="hljs-number">28</span>) &#123;<br>                     LOG.error(<span class="hljs-string">&quot;Got a short response: &quot;</span><br>                             + response.buffer.capacity());<br>                     <span class="hljs-keyword">continue</span>;<br>                 &#125;<br>                 <span class="hljs-type">boolean</span> <span class="hljs-variable">backCompatibility</span> <span class="hljs-operator">=</span> (response.buffer.capacity() == <span class="hljs-number">28</span>);<br>                 response.buffer.clear();<br><br>                 <span class="hljs-comment">// Instantiate Notification and set its attributes</span><br>                 <span class="hljs-type">Notification</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Notification</span>();<br><br>                 <span class="hljs-comment">// State of peer that sent this message</span><br>                 QuorumPeer.<span class="hljs-type">ServerState</span> <span class="hljs-variable">ackstate</span> <span class="hljs-operator">=</span> QuorumPeer.ServerState.LOOKING;<br>                 <span class="hljs-keyword">switch</span> (response.buffer.getInt()) &#123;<br>                 <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                     ackstate = QuorumPeer.ServerState.LOOKING;<br>                     <span class="hljs-keyword">break</span>;<br>                 <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                     ackstate = QuorumPeer.ServerState.FOLLOWING;<br>                     <span class="hljs-keyword">break</span>;<br>                 <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                     ackstate = QuorumPeer.ServerState.LEADING;<br>                     <span class="hljs-keyword">break</span>;<br>                 <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                     ackstate = QuorumPeer.ServerState.OBSERVING;<br>                     <span class="hljs-keyword">break</span>;<br>                 <span class="hljs-keyword">default</span>:<br>                     <span class="hljs-keyword">continue</span>;<br>                 &#125;<br><br>                 n.leader = response.buffer.getLong();<br>                 n.zxid = response.buffer.getLong();<br>                 n.electionEpoch = response.buffer.getLong();<br>                 n.state = ackstate;<br>                 n.sid = response.sid;<br>                 <span class="hljs-keyword">if</span>(!backCompatibility)&#123;<br>                     n.peerEpoch = response.buffer.getLong();<br>                 &#125; <span class="hljs-keyword">else</span> &#123;<br>                     <span class="hljs-keyword">if</span>(LOG.isInfoEnabled())&#123;<br>                         LOG.info(<span class="hljs-string">&quot;Backward compatibility mode, server id=&quot;</span> + n.sid);<br>                     &#125;<br>                     n.peerEpoch = ZxidUtils.getEpochFromZxid(n.zxid);<br>                 &#125;<br><br>                 <span class="hljs-comment">/*</span><br><span class="hljs-comment">                  * Version added in 3.4.6</span><br><span class="hljs-comment">                  */</span><br><br>                 n.version = (response.buffer.remaining() &gt;= <span class="hljs-number">4</span>) ?<br>                              response.buffer.getInt() : <span class="hljs-number">0x0</span>;<br><br>                 <span class="hljs-comment">/*</span><br><span class="hljs-comment">                  * Print notification info</span><br><span class="hljs-comment">                  */</span><br>                 <span class="hljs-keyword">if</span>(LOG.isInfoEnabled())&#123;<br>                     printNotification(n);<br>                 &#125;<br><br>                 <span class="hljs-comment">/*</span><br><span class="hljs-comment">                  * If this server is looking, then send proposed leader</span><br><span class="hljs-comment">                  * 当前机器的状态是LOIOKING, 则将收到的响应加入到recvQueue中, 用于参与投票选举</span><br><span class="hljs-comment">                  */</span><br><br>                 <span class="hljs-keyword">if</span>(self.getPeerState() == QuorumPeer.ServerState.LOOKING)&#123;<br>                     recvqueue.offer(n);<br><br>                     <span class="hljs-comment">/*</span><br><span class="hljs-comment">                      * Send a notification back if the peer that sent this</span><br><span class="hljs-comment">                      * message is also looking and its logical clock is</span><br><span class="hljs-comment">                      * lagging behind.</span><br><span class="hljs-comment">                      * 如果对方的状态也是LOOKING 并且自己的epoch 要比对方的大</span><br><span class="hljs-comment">                      *  则将当前自己认为的投票对象响应回去</span><br><span class="hljs-comment">                      */</span><br>                     <span class="hljs-keyword">if</span>((ackstate == QuorumPeer.ServerState.LOOKING)<br>                             &amp;&amp; (n.electionEpoch &lt; logicalclock.get()))&#123;<br>                         <span class="hljs-type">Vote</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> getVote();<br>                         <span class="hljs-type">ToSend</span> <span class="hljs-variable">notmsg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ToSend</span>(ToSend.mType.notification,<br>                                 v.getId(),<br>                                 v.getZxid(),<br>                                 logicalclock.get(),<br>                                 self.getPeerState(),<br>                                 response.sid,<br>                                 v.getPeerEpoch());<br>                         sendqueue.offer(notmsg);<br>                     &#125;<br>                 &#125; <span class="hljs-keyword">else</span> &#123;<br>                     <span class="hljs-comment">/*</span><br><span class="hljs-comment">                      * If this server is not looking, but the one that sent the ack</span><br><span class="hljs-comment">                      * is looking, then send back what it believes to be the leader.</span><br><span class="hljs-comment">                      * 如果ack 回来的状态是LOOKING 则将当前机器认为的leader状态进行响应, 数据放到sendQueue中</span><br><span class="hljs-comment">                      */</span><br>                     <span class="hljs-type">Vote</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> self.getCurrentVote();<br>                     <span class="hljs-keyword">if</span>(ackstate == QuorumPeer.ServerState.LOOKING)&#123;<br>                         <span class="hljs-keyword">if</span>(LOG.isDebugEnabled())&#123;<br>                             LOG.debug(<span class="hljs-string">&quot;Sending new notification. My id =  &quot;</span> +<br>                                     self.getId() + <span class="hljs-string">&quot; recipient=&quot;</span> +<br>                                     response.sid + <span class="hljs-string">&quot; zxid=0x&quot;</span> +<br>                                     Long.toHexString(current.getZxid()) +<br>                                     <span class="hljs-string">&quot; leader=&quot;</span> + current.getId());<br>                         &#125;<br><br>                         ToSend notmsg;<br>                         <span class="hljs-keyword">if</span>(n.version &gt; <span class="hljs-number">0x0</span>) &#123;<br>                             notmsg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ToSend</span>(<br>                                     ToSend.mType.notification,<br>                                     current.getId(),<br>                                     current.getZxid(),<br>                                     current.getElectionEpoch(),<br>                                     self.getPeerState(),<br>                                     response.sid,<br>                                     current.getPeerEpoch());<br><br>                         &#125; <span class="hljs-keyword">else</span> &#123;<br>                             <span class="hljs-type">Vote</span> <span class="hljs-variable">bcVote</span> <span class="hljs-operator">=</span> self.getBCVote();<br>                             notmsg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ToSend</span>(<br>                                     ToSend.mType.notification,<br>                                     bcVote.getId(),<br>                                     bcVote.getZxid(),<br>                                     bcVote.getElectionEpoch(),<br>                                     self.getPeerState(),<br>                                     response.sid,<br>                                     bcVote.getPeerEpoch());<br>                         &#125;<br>                         sendqueue.offer(notmsg);<br>                     &#125;<br>                 &#125;<br>             &#125;<br>         &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>             System.out.println(<span class="hljs-string">&quot;Interrupted Exception while waiting for new message&quot;</span> +<br>                     e.toString());<br>         &#125;<br>     &#125;<br>     LOG.info(<span class="hljs-string">&quot;WorkerReceiver is down&quot;</span>);<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="投票"><a href="#投票" class="headerlink" title="投票"></a>投票</h3><h4 id="更新自己的投票信息"><a href="#更新自己的投票信息" class="headerlink" title="更新自己的投票信息"></a>更新自己的投票信息</h4><ul><li>获取自己的id, zxId, epoch</li><li>给所有参与投票的svr<ul><li>内容为leaderId, zxId, epoch</li><li>将发送的信息放到sendqueue 缓存中<br><img src="/img/zk/election.jpg"></li></ul></li></ul><h4 id="选举逻辑"><a href="#选举逻辑" class="headerlink" title="选举逻辑"></a>选举逻辑</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Vote <span class="hljs-title function_">lookForLeader</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        self.jmxLeaderElectionBean = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LeaderElectionBean</span>();<br>        MBeanRegistry.getInstance().register(<br>                self.jmxLeaderElectionBean, self.jmxLocalPeerBean);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        LOG.warn(<span class="hljs-string">&quot;Failed to register with JMX&quot;</span>, e);<br>        self.jmxLeaderElectionBean = <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (self.start_fle == <span class="hljs-number">0</span>) &#123;<br>       self.start_fle = Time.currentElapsedTime();<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        HashMap&lt;Long, Vote&gt; recvset = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Long, Vote&gt;();<br><br>        HashMap&lt;Long, Vote&gt; outofelection = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Long, Vote&gt;();<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">notTimeout</span> <span class="hljs-operator">=</span> finalizeWait;<br><br>        <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>)&#123;<br>            logicalclock.incrementAndGet();<br>            updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());<br>        &#125;<br><br>        LOG.info(<span class="hljs-string">&quot;New election. My id =  &quot;</span> + self.getId() +<br>                <span class="hljs-string">&quot;, proposed zxid=0x&quot;</span> + Long.toHexString(proposedZxid));<br>        sendNotifications();<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Loop in which we exchange notifications until we find a leader</span><br><span class="hljs-comment">         */</span><br><br>        <span class="hljs-keyword">while</span> ((self.getPeerState() == ServerState.LOOKING) &amp;&amp;<br>                (!stop))&#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * Remove next notification from queue, times out after 2 times</span><br><span class="hljs-comment">             * the termination time</span><br><span class="hljs-comment">             * 从接受队列中获取内容</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-type">Notification</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> recvqueue.poll(notTimeout,<br>                    TimeUnit.MILLISECONDS);<br><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * Sends more notifications if haven&#x27;t received enough.</span><br><span class="hljs-comment">             * Otherwise processes new notification.</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">if</span>(n == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">if</span>(manager.haveDelivered())&#123;<br>                    sendNotifications();<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    manager.connectAll();<br>                &#125;<br><br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 * Exponential backoff</span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">tmpTimeOut</span> <span class="hljs-operator">=</span> notTimeout*<span class="hljs-number">2</span>;<br>                notTimeout = (tmpTimeOut &lt; maxNotificationInterval?<br>                        tmpTimeOut : maxNotificationInterval);<br>                LOG.info(<span class="hljs-string">&quot;Notification time out: &quot;</span> + notTimeout);<br>            &#125;<br>            <span class="hljs-comment">// 只对集群内的svrId进行处理</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(self.getVotingView().containsKey(n.sid)) &#123;<br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 * Only proceed if the vote comes from a replica in the</span><br><span class="hljs-comment">                 * voting view.</span><br><span class="hljs-comment">                 * 对方的状态是looking</span><br><span class="hljs-comment">                 *  对方的逻辑时钟比自己的大</span><br><span class="hljs-comment">                 *    更新逻辑时钟为对方的</span><br><span class="hljs-comment">                 *      确认是否可以进行更新选票(比较逻辑时钟、zxid、svrId), 可以的话将选票信息更新为对端的, 不行的话将选票信息设置为自己的</span><br><span class="hljs-comment">                 *    将自己的选票信息发送给其他svr节点</span><br><span class="hljs-comment">                 *  对方的逻辑时钟比自己的小</span><br><span class="hljs-comment">                 *     忽略</span><br><span class="hljs-comment">                 *     结束</span><br><span class="hljs-comment">                 *  对方的逻辑时钟和自己的相等</span><br><span class="hljs-comment">                 *     确认是否可以进行更新选票</span><br><span class="hljs-comment">                 *       可以的话更新选票信息, 然后通知给其他svr节点</span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-keyword">switch</span> (n.state) &#123;<br>                <span class="hljs-keyword">case</span> LOOKING:<br>                    <span class="hljs-comment">// If notification &gt; current, replace and send messages out</span><br>                    <span class="hljs-keyword">if</span> (n.electionEpoch &gt; logicalclock.get()) &#123;<br>                        logicalclock.set(n.electionEpoch);<br>                        recvset.clear();<br>                        <span class="hljs-keyword">if</span>(totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,<br>                                getInitId(), getInitLastLoggedZxid(), getPeerEpoch())) &#123;<br>                            updateProposal(n.leader, n.zxid, n.peerEpoch);<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            updateProposal(getInitId(),<br>                                    getInitLastLoggedZxid(),<br>                                    getPeerEpoch());<br>                        &#125;<br>                        sendNotifications();<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n.electionEpoch &lt; logicalclock.get()) &#123;<br>                        <span class="hljs-keyword">if</span>(LOG.isDebugEnabled())&#123;<br>                            LOG.debug(<span class="hljs-string">&quot;Notification election epoch is smaller than logicalclock. n.electionEpoch = 0x&quot;</span><br>                                    + Long.toHexString(n.electionEpoch)<br>                                    + <span class="hljs-string">&quot;, logicalclock=0x&quot;</span> + Long.toHexString(logicalclock.get()));<br>                        &#125;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,<br>                            proposedLeader, proposedZxid, proposedEpoch)) &#123;<br>                        updateProposal(n.leader, n.zxid, n.peerEpoch);<br>                        sendNotifications();<br>                    &#125;<br><br>                    <span class="hljs-keyword">if</span>(LOG.isDebugEnabled())&#123;<br>                        LOG.debug(<span class="hljs-string">&quot;Adding vote: from=&quot;</span> + n.sid +<br>                                <span class="hljs-string">&quot;, proposed leader=&quot;</span> + n.leader +<br>                                <span class="hljs-string">&quot;, proposed zxid=0x&quot;</span> + Long.toHexString(n.zxid) +<br>                                <span class="hljs-string">&quot;, proposed election epoch=0x&quot;</span> + Long.toHexString(n.electionEpoch));<br>                    &#125;<br><br>                    recvset.put(n.sid, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vote</span>(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));<br><br>                    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                     * 确定选票是否超过半数以上</span><br><span class="hljs-comment">                     *  如果发现超过半数以上的话</span><br><span class="hljs-comment">                     *      再次从recvQ中获取一下数据, 确定没有请求数据残留, 然后再去判断是否需要更新leader</span><br><span class="hljs-comment">                     *      无法再从recvQ中获取到数据, 然后看选举出来的id是否和自己相等, 相等的话自己就设置为leader, 不是的话, 自己设置为observer</span><br><span class="hljs-comment">                     *         或者是flower, 并将结果状态返回</span><br><span class="hljs-comment">                     */</span><br>                    <span class="hljs-keyword">if</span> (termPredicate(recvset,<br>                            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vote</span>(proposedLeader, proposedZxid,<br>                                    logicalclock.get(), proposedEpoch))) &#123;<br><br>                        <span class="hljs-comment">// Verify if there is any change in the proposed leader</span><br>                        <span class="hljs-keyword">while</span>((n = recvqueue.poll(finalizeWait,<br>                                TimeUnit.MILLISECONDS)) != <span class="hljs-literal">null</span>)&#123;<br>                            <span class="hljs-keyword">if</span>(totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,<br>                                    proposedLeader, proposedZxid, proposedEpoch))&#123;<br>                                recvqueue.put(n);<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br><br>                        <span class="hljs-comment">/*</span><br><span class="hljs-comment">                         * This predicate is true once we don&#x27;t read any new</span><br><span class="hljs-comment">                         * relevant message from the reception queue</span><br><span class="hljs-comment">                         */</span><br>                        <span class="hljs-keyword">if</span> (n == <span class="hljs-literal">null</span>) &#123;<br>                            self.setPeerState((proposedLeader == self.getId()) ?<br>                                    ServerState.LEADING: learningState());<br><br>                            <span class="hljs-type">Vote</span> <span class="hljs-variable">endVote</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vote</span>(proposedLeader,<br>                                                    proposedZxid,<br>                                                    logicalclock.get(),<br>                                                    proposedEpoch);<br>                            leaveInstance(endVote);<br>                            <span class="hljs-keyword">return</span> endVote;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> OBSERVING:<br>                    LOG.debug(<span class="hljs-string">&quot;Notification from observer: &quot;</span> + n.sid);<br>                    <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                     * 如果对方的状态是flower 或者是leader</span><br><span class="hljs-comment">                     *  比较对方的逻辑时钟和自己的逻辑时钟</span><br><span class="hljs-comment">                     *     相等的情况下去在收到looking响应的投票集合中是否获得半数以上的投票,</span><br><span class="hljs-comment">                     *          并且去校验收到响应的节点在flower 和 leader 集合中是否为leader, 是的话则对当前状态结果进行更新</span><br><span class="hljs-comment">                     *     如果当前节点不符合leader的判断, 则将当前节点加入到flower 和 leader的集合中中, 再次进行校验是否符合leader 角色</span><br><span class="hljs-comment">                     *</span><br><span class="hljs-comment">                     */</span><br>                <span class="hljs-keyword">case</span> FOLLOWING:<br>                <span class="hljs-keyword">case</span> LEADING:<br>                    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                     * Consider all notifications from the same epoch</span><br><span class="hljs-comment">                     * together.</span><br><span class="hljs-comment">                     */</span><br>                    <span class="hljs-keyword">if</span>(n.electionEpoch == logicalclock.get())&#123;<br>                        recvset.put(n.sid, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vote</span>(n.leader,<br>                                                      n.zxid,<br>                                                      n.electionEpoch,<br>                                                      n.peerEpoch));<br><br>                        <span class="hljs-keyword">if</span>(ooePredicate(recvset, outofelection, n)) &#123;<br>                            self.setPeerState((n.leader == self.getId()) ?<br>                                    ServerState.LEADING: learningState());<br><br>                            <span class="hljs-type">Vote</span> <span class="hljs-variable">endVote</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vote</span>(n.leader,<br>                                    n.zxid,<br>                                    n.electionEpoch,<br>                                    n.peerEpoch);<br>                            leaveInstance(endVote);<br>                            <span class="hljs-keyword">return</span> endVote;<br>                        &#125;<br>                    &#125;<br><br>                    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                     * Before joining an established ensemble, verify</span><br><span class="hljs-comment">                     * a majority is following the same leader.</span><br><span class="hljs-comment">                     */</span><br>                    outofelection.put(n.sid, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vote</span>(n.version,<br>                                                        n.leader,<br>                                                        n.zxid,<br>                                                        n.electionEpoch,<br>                                                        n.peerEpoch,<br>                                                        n.state));<br><br>                    <span class="hljs-keyword">if</span>(ooePredicate(outofelection, outofelection, n)) &#123;<br>                        <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>)&#123;<br>                            logicalclock.set(n.electionEpoch);<br>                            self.setPeerState((n.leader == self.getId()) ?<br>                                    ServerState.LEADING: learningState());<br>                        &#125;<br>                        <span class="hljs-type">Vote</span> <span class="hljs-variable">endVote</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vote</span>(n.leader,<br>                                                n.zxid,<br>                                                n.electionEpoch,<br>                                                n.peerEpoch);<br>                        leaveInstance(endVote);<br>                        <span class="hljs-keyword">return</span> endVote;<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    LOG.warn(<span class="hljs-string">&quot;Notification state unrecognized: &#123;&#125; (n.state), &#123;&#125; (n.sid)&quot;</span>,<br>                            n.state, n.sid);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                LOG.warn(<span class="hljs-string">&quot;Ignoring notification from non-cluster member &quot;</span> + n.sid);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(self.jmxLeaderElectionBean != <span class="hljs-literal">null</span>)&#123;<br>                MBeanRegistry.getInstance().unregister(<br>                        self.jmxLeaderElectionBean);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            LOG.warn(<span class="hljs-string">&quot;Failed to unregister with JMX&quot;</span>, e);<br>        &#125;<br>        self.jmxLeaderElectionBean = <span class="hljs-literal">null</span>;<br>        LOG.debug(<span class="hljs-string">&quot;Number of connection processing threads: &#123;&#125;&quot;</span>,<br>                manager.getConnectionThreadCount());<br>    &#125;<br>&#125;<br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">ooePredicate</span><span class="hljs-params">(HashMap&lt;Long,Vote&gt; recv,</span><br><span class="hljs-params">                                HashMap&lt;Long,Vote&gt; ooe,</span><br><span class="hljs-params">                                Notification n)</span> &#123;<br><br>    <span class="hljs-keyword">return</span> (termPredicate(recv, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vote</span>(n.version,<br>                                         n.leader,<br>                                         n.zxid,<br>                                         n.electionEpoch,<br>                                         n.peerEpoch,<br>                                         n.state))<br>            &amp;&amp; checkLeader(ooe, n.leader, n.electionEpoch));<br><br>&#125;<br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkLeader</span><span class="hljs-params">(</span><br><span class="hljs-params">        HashMap&lt;Long, Vote&gt; votes,</span><br><span class="hljs-params">        <span class="hljs-type">long</span> leader,</span><br><span class="hljs-params">        <span class="hljs-type">long</span> electionEpoch)</span>&#123;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">predicate</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * If everyone else thinks I&#x27;m the leader, I must be the leader.</span><br><span class="hljs-comment">     * The other two checks are just for the case in which I&#x27;m not the</span><br><span class="hljs-comment">     * leader. If I&#x27;m not the leader and I haven&#x27;t received a message</span><br><span class="hljs-comment">     * from leader stating that it is leading, then predicate is false.</span><br><span class="hljs-comment">     * 如果其他人认为自己是leader, 那么自己就是leader, 除两种情况以外:</span><br><span class="hljs-comment">     *  1. 逻辑时钟和自己的不一样(说明曾经挂过)</span><br><span class="hljs-comment">     *  2. leader的状态不是leader(只要我自己不是leader，且我没有收到leader给我发它是leader，那么就不行)</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-keyword">if</span>(leader != self.getId())&#123;<br>        <span class="hljs-keyword">if</span>(votes.get(leader) == <span class="hljs-literal">null</span>) predicate = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(votes.get(leader).getState() != ServerState.LEADING) predicate = <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(logicalclock.get() != electionEpoch) &#123;<br>        predicate = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> predicate;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="查看是否收到半数以上的票"><a href="#查看是否收到半数以上的票" class="headerlink" title="查看是否收到半数以上的票"></a>查看是否收到半数以上的票</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">termPredicate</span><span class="hljs-params">(</span><br><span class="hljs-params">        HashMap&lt;Long, Vote&gt; votes,</span><br><span class="hljs-params">        Vote vote)</span> &#123;<br><br>    HashSet&lt;Long&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Long&gt;();<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * First make the views consistent. Sometimes peers will have</span><br><span class="hljs-comment">     * different zxids for a server depending on timing.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">for</span> (Map.Entry&lt;Long,Vote&gt; entry : votes.entrySet()) &#123;<br>        <span class="hljs-keyword">if</span> (vote.equals(entry.getValue()))&#123;<br>            set.add(entry.getKey());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> self.getQuorumVerifier().containsQuorum(set);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsQuorum</span><span class="hljs-params">(HashSet&lt;Long&gt; set)</span>&#123;<br>    <span class="hljs-keyword">return</span> (set.size() &gt; half);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>zk</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>netty服务端启动流程</title>
    <link href="/2022/11/19/netty/nettystart/"/>
    <url>/2022/11/19/netty/nettystart/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>netty</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>线程池</title>
    <link href="/2022/11/19/jdk/threadPoolExecutor/"/>
    <url>/2022/11/19/jdk/threadPoolExecutor/</url>
    
    <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ul><li>有大量异步任务的时候提升性能</li><li>通过一系列参数对线程资源进行管理</li></ul><h2 id="构造线程池"><a href="#构造线程池" class="headerlink" title="构造线程池"></a>构造线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                          ThreadFactory threadFactory,</span><br><span class="hljs-params">                          RejectedExecutionHandler handler)</span> &#123;<br>    <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt;= <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt; corePoolSize ||<br>        keepAliveTime &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-literal">null</span> || threadFactory == <span class="hljs-literal">null</span> || handler == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-built_in">this</span>.corePoolSize = corePoolSize;<br>    <span class="hljs-built_in">this</span>.maximumPoolSize = maximumPoolSize;<br>    <span class="hljs-built_in">this</span>.workQueue = workQueue;<br>    <span class="hljs-built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br>    <span class="hljs-built_in">this</span>.threadFactory = threadFactory;<br>    <span class="hljs-built_in">this</span>.handler = handler;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><ul><li>corePoolSize: 核心线程数</li><li>maximumPoolSize: 最大线程数</li><li>keepAliveTime: 空闲线程存活时间</li><li>unit: 空闲线程存活的时间单位</li><li>workQueue: 用于保存等待执行任务的队列</li><li>threadFactory:  用于创建线程的工厂</li><li>handler: 当任务队列满了以后, 用于何种策略去执行</li></ul><h2 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">ctl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br> <span class="hljs-comment">//表示运行状态</span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> Integer.SIZE - <span class="hljs-number">3</span>;<br> <span class="hljs-comment">//表示worker的个数</span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_MASK</span> <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;<br> <span class="hljs-comment">// runState is stored in the high-order bits</span><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  *           SHUTDOWN()</span><br><span class="hljs-comment">  * RUNNING ---------------&gt; SHUTDOWN</span><br><span class="hljs-comment">  *           SHUTDOWNNOW()</span><br><span class="hljs-comment">  * RUNNING ---------------&gt; STOP</span><br><span class="hljs-comment">  * 1. RUNNING: 可以接受任务, 以及对添加的任务进行处理</span><br><span class="hljs-comment">  * 2. SHUTDOWN: 不可以接受任务, 但是可以对已经添加的任务进行处理</span><br><span class="hljs-comment">  * 3. STOP: 不接受添加任务, 不处理已经添加的任务, 会中断正在处理的任务</span><br><span class="hljs-comment">  * 4. TIDYING: 所有的任务已终止, ctl 记录的任务数量为0, 此时可以执行回掉函数terminated()</span><br><span class="hljs-comment">  * 5. TERMINATED: 线程池彻底终止</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RUNNING</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHUTDOWN</span>   <span class="hljs-operator">=</span>  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">STOP</span>       <span class="hljs-operator">=</span>  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TIDYING</span>    <span class="hljs-operator">=</span>  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TERMINATED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br></code></pre></td></tr></table></figure><ul><li>高3位表示状态, 后29表示个数<br>为什么用高三位表示状态?<br>因为线程池的状态有五种, RUNNING、SHUTDOWN、STOP、TIDYING、TERMINATED, 三位刚好可以表示</li></ul><h2 id="EXECUTE"><a href="#EXECUTE" class="headerlink" title="EXECUTE"></a>EXECUTE</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Proceed in 3 steps:</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 1. If fewer than corePoolSize threads are running, try to</span><br><span class="hljs-comment">     * start a new thread with the given command as its first</span><br><span class="hljs-comment">     * task.  The call to addWorker atomically checks runState and</span><br><span class="hljs-comment">     * workerCount, and so prevents false alarms that would add</span><br><span class="hljs-comment">     * threads when it shouldn&#x27;t, by returning false.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 2. If a task can be successfully queued, then we still need</span><br><span class="hljs-comment">     * to double-check whether we should have added a thread</span><br><span class="hljs-comment">     * (because existing ones died since last checking) or that</span><br><span class="hljs-comment">     * the pool shut down since entry into this method. So we</span><br><span class="hljs-comment">     * recheck state and if necessary roll back the enqueuing if</span><br><span class="hljs-comment">     * stopped, or start a new thread if there are none.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 3. If we cannot queue task, then we try to add a new</span><br><span class="hljs-comment">     * thread.  If it fails, we know we are shut down or saturated</span><br><span class="hljs-comment">     * and so reject the task.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>    <span class="hljs-comment">//通过获取地位运行线程数的个数来和当前核心线程数进行比较, 判断是否需要直接创建worker</span><br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>))<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//创建失败的原因: 线程池状态变更为 SHUTDOWN 或 其他任务被提交执行导致工作线程数超过了核心线程数</span><br>        c = ctl.get();<br>    &#125;<br><br>     <span class="hljs-comment">//线程池运行为RUNNING 状态的, 并且向queue里面去放线程</span><br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 再次检查线程池状态</span><br><span class="hljs-comment">         * 如果状态不是running 则将任务从队列中移除</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>            reject(command);<br>        <span class="hljs-comment">//当worker的数量为0的时候, 创建新的worker 线程从queue中去消费任务</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>            addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果队列满了, 直接尝试去通过创建线程池去执行线程,</span><br><span class="hljs-comment">     *  无法创建说明到了最大线程数, 则执行拒绝策略</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))<br>        reject(command);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="/img/executor.execute.jpg"></p><h2 id="创建WORKER"><a href="#创建WORKER" class="headerlink" title="创建WORKER"></a>创建WORKER</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-type">boolean</span> core)</span> &#123;<br>     retry:<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();;) &#123;<br>         <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>         <span class="hljs-comment">/**</span><br><span class="hljs-comment">          * 1. 线程池的状态为SHUTDOWN 并且</span><br><span class="hljs-comment">          *  1.1 线程池运行状态为STOP</span><br><span class="hljs-comment">          *  1.2 运行的task不为空</span><br><span class="hljs-comment">          *  1.3 workQueue 为空</span><br><span class="hljs-comment">          *  返回添加失败</span><br><span class="hljs-comment">          */</span><br>         <span class="hljs-keyword">if</span> (runStateAtLeast(c, SHUTDOWN)<br>             &amp;&amp; (runStateAtLeast(c, STOP)<br>                 || firstTask != <span class="hljs-literal">null</span><br>                 || workQueue.isEmpty()))<br>             <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>         <span class="hljs-keyword">for</span> (;;) &#123;<br>             <span class="hljs-comment">/**</span><br><span class="hljs-comment">              * 如果创建的是核心线程, 则判断当前线程数是否大于核心线程数</span><br><span class="hljs-comment">              * 如果创建的是非核心线程, 判断当前线程数是否大于最大核心线程数</span><br><span class="hljs-comment">              */</span><br>             <span class="hljs-keyword">if</span> (workerCountOf(c)<br>                 &gt;= ((core ? corePoolSize : maximumPoolSize) &amp; COUNT_MASK))<br>                 <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>             <span class="hljs-comment">/**</span><br><span class="hljs-comment">              * 通过CAS对worker 数量进行加1</span><br><span class="hljs-comment">              */</span><br><br>             <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br>                 <span class="hljs-keyword">break</span> retry;<br>             c = ctl.get();  <span class="hljs-comment">// Re-read ctl</span><br>             <span class="hljs-keyword">if</span> (runStateAtLeast(c, SHUTDOWN))<br>                 <span class="hljs-keyword">continue</span> retry;<br>             <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span><br>         &#125;<br>     &#125;<br><br>     <span class="hljs-type">boolean</span> <span class="hljs-variable">workerStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>     <span class="hljs-type">boolean</span> <span class="hljs-variable">workerAdded</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>     <span class="hljs-type">Worker</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>     <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-comment">//创建一个worker</span><br>         w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(firstTask);<br>         <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br>         <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>             <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>             mainLock.lock();<br>             <span class="hljs-keyword">try</span> &#123;<br>                 <span class="hljs-comment">// Recheck while holding lock.</span><br>                 <span class="hljs-comment">// Back out on ThreadFactory failure or if</span><br>                 <span class="hljs-comment">// shut down before lock acquired.</span><br>                 <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br><br>                 <span class="hljs-comment">/**</span><br><span class="hljs-comment">                  * 加读写锁后再次对线程状态进行查看, 判断线程的状态是否为running状态,</span><br><span class="hljs-comment">                  * 将当前task 加入到worker中,并且去最大线程池数量</span><br><span class="hljs-comment">                  * 加入到线程池后进行解锁, 运行worker</span><br><span class="hljs-comment">                  */</span><br>                 <span class="hljs-keyword">if</span> (isRunning(c) ||<br>                     (runStateLessThan(c, STOP) &amp;&amp; firstTask == <span class="hljs-literal">null</span>)) &#123;<br>                     <span class="hljs-keyword">if</span> (t.getState() != Thread.State.NEW)<br>                         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br>                     workers.add(w);<br>                     workerAdded = <span class="hljs-literal">true</span>;<br>                     <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> workers.size();<br>                     <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>                         largestPoolSize = s;<br>                 &#125;<br>             &#125; <span class="hljs-keyword">finally</span> &#123;<br>                 mainLock.unlock();<br>             &#125;<br>             <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>                 t.start();<br>                 workerStarted = <span class="hljs-literal">true</span>;<br>             &#125;<br>         &#125;<br>     &#125; <span class="hljs-keyword">finally</span> &#123;<br>         <span class="hljs-keyword">if</span> (! workerStarted)<br>             addWorkerFailed(w);<br>     &#125;<br>     <span class="hljs-keyword">return</span> workerStarted;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="流程图-1"><a href="#流程图-1" class="headerlink" title="流程图"></a>流程图</h3><p><img src="/img/executor.create.worker.jpg"></p><h3 id="上锁的原因"><a href="#上锁的原因" class="headerlink" title="上锁的原因"></a>上锁的原因</h3><ul><li>对worker的集合以及数据进行加锁的原因  <ul><li>中断风暴定义: 如果不用lock的话, 使用并发安全的集合, 同时有5个线程进行中断, 每个线程都会进行interruptIdleWorkers<ul><li>第一个线程发起了对worker 进行中断, 第二个线程再次发起, 变成了对中断线程的中断,因此简单一点, 只需要一个线程可以发起中断即可, 用锁来实现串行化</li></ul></li><li>加锁好维护一些静态数据: largestPoolSize, 如用volatile的话, 到addWorker的时候, 拿到的值不一定准确</li></ul></li></ul><h3 id="其中worker-对象自身继承于AQS"><a href="#其中worker-对象自身继承于AQS" class="headerlink" title="其中worker 对象自身继承于AQS"></a>其中worker 对象自身继承于AQS</h3><ul><li>在初始化所得时候, 将值设置为-1, 开始时候变为正的, 保证线程开始运行的时候才可以进行中断线程</li></ul><h2 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Worker(Runnable firstTask) &#123;<br>    setState(-<span class="hljs-number">1</span>); <span class="hljs-comment">// inhibit interrupts until runWorker</span><br>    <span class="hljs-built_in">this</span>.firstTask = firstTask;<br>    <span class="hljs-built_in">this</span>.thread = getThreadFactory().newThread(<span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="runWorker"><a href="#runWorker" class="headerlink" title="runWorker"></a>runWorker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runWorker</span><span class="hljs-params">(Worker w)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">wt</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> w.firstTask;<br>    w.firstTask = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化的时候将值设置为-1, 知道开始运行的时候才设置为0, 目的是为了线程只有在开始运行的时候才可以中断</span><br><span class="hljs-comment">     */</span><br>    w.unlock(); <span class="hljs-comment">// allow interrupts</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">completedAbruptly</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 当前任务为哦那个 或者时获取不到任务时</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = getTask()) != <span class="hljs-literal">null</span>) &#123;<br>            w.lock();<br>            <span class="hljs-comment">// If pool is stopping, ensure thread is interrupted;</span><br>            <span class="hljs-comment">// if not, ensure thread is not interrupted.  This</span><br>            <span class="hljs-comment">// requires a recheck in second case to deal with</span><br>            <span class="hljs-comment">// shutdownNow race while clearing interrupt</span><br>            <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||<br>                 (Thread.interrupted() &amp;&amp;<br>                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;<br>                !wt.isInterrupted())<br>                wt.interrupt();<br>            <span class="hljs-keyword">try</span> &#123;<br>                beforeExecute(wt, task);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    task.run();<br>                    afterExecute(task, <span class="hljs-literal">null</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                    afterExecute(task, ex);<br>                    <span class="hljs-keyword">throw</span> ex;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                task = <span class="hljs-literal">null</span>;<br>                w.completedTasks++;<br>                w.unlock();<br>            &#125;<br>        &#125;<br>        completedAbruptly = <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 对work 进行退出</span><br><span class="hljs-comment">         */</span><br>        processWorkerExit(w, completedAbruptly);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>封装出来的worker在runWorker中进行运行真正的调度, 以及从队列当中获取任务去执行</li><li>只有getTasks 执行完了, 才会进行退出执行</li></ul><h3 id="getTasks"><a href="#getTasks" class="headerlink" title="getTasks"></a>getTasks</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Performs blocking or timed wait for a task, depending on</span><br><span class="hljs-comment"> * current configuration settings, or returns null if this worker</span><br><span class="hljs-comment"> * must exit because of any of:</span><br><span class="hljs-comment"> * 1. There are more than maximumPoolSize workers (due to</span><br><span class="hljs-comment"> *    a call to setMaximumPoolSize).</span><br><span class="hljs-comment"> * 2. The pool is stopped.</span><br><span class="hljs-comment"> * 3. The pool is shutdown and the queue is empty.</span><br><span class="hljs-comment"> * 4. This worker timed out waiting for a task, and timed-out</span><br><span class="hljs-comment"> *    workers are subject to termination (that is,</span><br><span class="hljs-comment"> *    &#123;<span class="hljs-doctag">@code</span> allowCoreThreadTimeOut || workerCount &gt; corePoolSize&#125;)</span><br><span class="hljs-comment"> *    both before and after the timed wait, and if the queue is</span><br><span class="hljs-comment"> *    non-empty, this worker is not the last thread in the pool.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  通过阻塞或者是超时等待获取到任务</span><br><span class="hljs-comment"> *  以下状态返回null</span><br><span class="hljs-comment"> *      1. 在设置了最大线程数, 当前的worker count 超过了最大线程数</span><br><span class="hljs-comment"> *      2. 线程池的状态为stop 的状态</span><br><span class="hljs-comment"> *      3. 线程池得状态为stop 或者是 shutdown 同时队列为空</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> task, or null if the worker must exit, in which case</span><br><span class="hljs-comment"> *         workerCount is decremented</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Runnable <span class="hljs-title function_">getTask</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">timedOut</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br><br>        <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 此时线程池工作状态为STOP, TIDYING, TERMINATED或者是shutdown</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (runStateAtLeast(c, SHUTDOWN)<br>            &amp;&amp; (runStateAtLeast(c, STOP) || workQueue.isEmpty())) &#123;<br>            decrementWorkerCount();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<br><br>        <span class="hljs-comment">// Are workers subject to culling?</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 1. 允许超时回收, 如果设置为, 则会回收所有的worker</span><br><span class="hljs-comment">         * 2. worker count 大于核心线程数量</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">timed</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 工作线程超过最大线程数或者获取当前任务超时了</span><br><span class="hljs-comment">         * 同时 当前的workqueue 为空了, 从而导致获取不到任务时</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))<br>            &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;<br>            <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> timed ?<br>                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :<br>                workQueue.take();<br>            <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> r;<br>            timedOut = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;<br>            timedOut = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>判断能否继续获取到task<ul><li>线程池的工作状态为STOP 或者是SHUTDOWN 并且没有任务要执行了</li><li>当前worker线程数大于1, 并且任务队列中没有可执行任务了<ul><li>对于大多数默认的, 当前worker 个数是否超过了核心线程数,或者是设置了运行超时</li><li>当前的worker线程超过了最大线程数</li></ul></li></ul></li></ul><h3 id="退出worker"><a href="#退出worker" class="headerlink" title="退出worker"></a>退出worker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Performs cleanup and bookkeeping for a dying worker. Called</span><br><span class="hljs-comment"> * only from worker threads. Unless completedAbruptly is set,</span><br><span class="hljs-comment"> * assumes that workerCount has already been adjusted to account</span><br><span class="hljs-comment"> * for exit.  This method removes thread from worker set, and</span><br><span class="hljs-comment"> * possibly terminates the pool or replaces the worker if either</span><br><span class="hljs-comment"> * it exited due to user task exception or if fewer than</span><br><span class="hljs-comment"> * corePoolSize workers are running or queue is non-empty but</span><br><span class="hljs-comment"> * there are no workers.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 1. worker set 中 移除worker</span><br><span class="hljs-comment"> * 2. 替换worker, 由于前面的</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> w the worker</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> completedAbruptly if the worker died due to user exception</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processWorkerExit</span><span class="hljs-params">(Worker w, <span class="hljs-type">boolean</span> completedAbruptly)</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  如果是意外退出的, 则将工作线程减一</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (completedAbruptly) <span class="hljs-comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span><br>        decrementWorkerCount();<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        completedTaskCount += w.completedTasks;<br>        workers.remove(w);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br><br>    tryTerminate();<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 状态是RUNNING 或者是SHUTDOWN 并且不是意外退出的</span><br><span class="hljs-comment">     *      如果核心数允许超时,则为0，否则为核心数</span><br><span class="hljs-comment">     *      如果核心数等于0 并且任务队列不为空, 的时候最小数为1.</span><br><span class="hljs-comment">     *          工作线程数大于等于最小值的时候不增加新的工作线程, 否则增加新的工作线程</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (runStateLessThan(c, STOP)) &#123;<br>        <span class="hljs-keyword">if</span> (!completedAbruptly) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut ? <span class="hljs-number">0</span> : corePoolSize;<br>            <span class="hljs-keyword">if</span> (min == <span class="hljs-number">0</span> &amp;&amp; ! workQueue.isEmpty())<br>                min = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (workerCountOf(c) &gt;= min)<br>                <span class="hljs-keyword">return</span>; <span class="hljs-comment">// replacement not needed</span><br>        &#125;<br>        addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="tryTerminate"><a href="#tryTerminate" class="headerlink" title="tryTerminate"></a>tryTerminate</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * Transitions to TERMINATED state if either (SHUTDOWN and pool</span><br><span class="hljs-comment">  * and queue empty) or (STOP and pool empty).  If otherwise</span><br><span class="hljs-comment">  * eligible to terminate but workerCount is nonzero, interrupts an</span><br><span class="hljs-comment">  * idle worker to ensure that shutdown signals propagate. This</span><br><span class="hljs-comment">  * method must be called following any action that might make</span><br><span class="hljs-comment">  * termination possible -- reducing worker count or removing tasks</span><br><span class="hljs-comment">  * from the queue during shutdown. The method is non-private to</span><br><span class="hljs-comment">  * allow access from ScheduledThreadPoolExecutor.</span><br><span class="hljs-comment">  * 线程池状态转换为TERMINATED</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryTerminate</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-keyword">for</span> (;;) &#123;<br>         <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>         <span class="hljs-keyword">if</span> (isRunning(c) ||<br>             runStateAtLeast(c, TIDYING) ||<br>             (runStateLessThan(c, STOP) &amp;&amp; ! workQueue.isEmpty()))<br>             <span class="hljs-keyword">return</span>;<br>         <span class="hljs-comment">/**</span><br><span class="hljs-comment">          * 如果工作线程的个数部位0，则中断所有的Idle 线程</span><br><span class="hljs-comment">          */</span><br>         <span class="hljs-keyword">if</span> (workerCountOf(c) != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// Eligible to terminate</span><br>             interruptIdleWorkers(ONLY_ONE);<br>             <span class="hljs-keyword">return</span>;<br>         &#125;<br><br>         <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>         mainLock.lock();<br>         <span class="hljs-keyword">try</span> &#123;<br>             <span class="hljs-comment">//将线程池的状态变为TIDYING</span><br>             <span class="hljs-keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="hljs-number">0</span>))) &#123;<br>                 <span class="hljs-keyword">try</span> &#123;<br>                     terminated();<br>                 &#125; <span class="hljs-keyword">finally</span> &#123;<br>                     <span class="hljs-comment">//将线程池的状态设置为TERMINATED</span><br>                     ctl.set(ctlOf(TERMINATED, <span class="hljs-number">0</span>));<br>                     termination.signalAll();<br>                 &#125;<br>                 <span class="hljs-keyword">return</span>;<br>             &#125;<br>         &#125; <span class="hljs-keyword">finally</span> &#123;<br>             mainLock.unlock();<br>         &#125;<br>         <span class="hljs-comment">// else retry on failed CAS</span><br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h2 id="显示退出"><a href="#显示退出" class="headerlink" title="显示退出"></a>显示退出</h2><h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        checkShutdownAccess();<br>        advanceRunState(SHUTDOWN);<br>        interruptIdleWorkers();<br>        onShutdown(); <span class="hljs-comment">// hook for ScheduledThreadPoolExecutor</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>    tryTerminate();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="interruptIdleWorkers"><a href="#interruptIdleWorkers" class="headerlink" title="interruptIdleWorkers"></a>interruptIdleWorkers</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptIdleWorkers</span><span class="hljs-params">(<span class="hljs-type">boolean</span> onlyOne)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (Worker w : workers) &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * w.tryLock 保证只能对空闲的线程进行中断, 里面调用加锁的方式是不可重入的</span><br><span class="hljs-comment">             *    worker 在开始允许的时候先会上锁, 从而导致正在允许的线程是拿不到锁的</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    t.interrupt();<br>                &#125; <span class="hljs-keyword">catch</span> (SecurityException ignore) &#123;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    w.unlock();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (onlyOne)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow"></a>shutdownNow</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title function_">shutdownNow</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Runnable&gt; tasks;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        checkShutdownAccess();<br>        advanceRunState(STOP);<br>        interruptWorkers();<br>        tasks = drainQueue();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>    tryTerminate();<br>    <span class="hljs-keyword">return</span> tasks;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>shutdown 和 shutdownNow 的区别<ul><li>shutdown将运行状态改为shutdown, 并中断所有的空闲线程</li><li>shutdownNow 是将状态改为STOP, 中断所有线程, 返回为处理的任务</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>jdk</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo-demo</title>
    <link href="/2022/11/19/hexo-demo/"/>
    <url>/2022/11/19/hexo-demo/</url>
    
    <content type="html"><![CDATA[<h3 id="通过npm-安装hexo"><a href="#通过npm-安装hexo" class="headerlink" title="通过npm 安装hexo"></a>通过npm 安装hexo</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs copy">npm install hexo-cli -g  <br></code></pre></td></tr></table></figure><h3 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a>初始化hexo</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs copy">hexo init hexo-archieve<br></code></pre></td></tr></table></figure><p>然后在博客目录下创建 _config.fluid.yml，将主题的 _config.yml 内容复制进去。<br>接下来，修改 Hexo 博客目录中的 _config.yml：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs copy">language: zh-CN  # 指定语言，会影响主题显示的语言。默认为en，英文<br>theme: fluid  # 指定主题<br></code></pre></td></tr></table></figure><h3 id="启动hexo-server"><a href="#启动hexo-server" class="headerlink" title="启动hexo server"></a>启动hexo server</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs copy">hexo server<br></code></pre></td></tr></table></figure><h3 id="关于github-配置"><a href="#关于github-配置" class="headerlink" title="关于github 配置"></a>关于github 配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs copy">deploy:  <br>  type: git  <br>  repo: &lt;repository url&gt; # https://github.com/pc-xie/pc-xie.github.io.git<br>  branch: [branch]  <br>  token: [token]<br></code></pre></td></tr></table></figure><h3 id="推送到github上"><a href="#推送到github上" class="headerlink" title="推送到github上"></a>推送到github上</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs copy">hexo clean<br>hexo deploy<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>demo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/11/19/hello-world/"/>
    <url>/2022/11/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>demo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hashMap</title>
    <link href="/2022/06/22/jdk/hashMap/"/>
    <url>/2022/06/22/jdk/hashMap/</url>
    
    <content type="html"><![CDATA[<h2 id="HashMap-简介"><a href="#HashMap-简介" class="headerlink" title="HashMap 简介"></a>HashMap 简介</h2><p>HashMap 主要用来存放键值对，它基于哈希表的Map接口实现</font>，是常用的Java集合之一。</p><p>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间，具体可以参考 <code>treeifyBin</code>方法。</p><h2 id="底层数据结构分析"><a href="#底层数据结构分析" class="headerlink" title="底层数据结构分析"></a>底层数据结构分析</h2><h3 id="JDK1-8之前"><a href="#JDK1-8之前" class="headerlink" title="JDK1.8之前"></a>JDK1.8之前</h3><p>JDK1.8 之前 HashMap 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。<strong>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash  值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p><p><strong>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</strong></p><p>设计扰动函数原因:</p><pre><code class="hljs">1. 降低hash碰撞, 越越分散越好2. 这是一个高频的操作, 通过采用位运算提升效率</code></pre><p>不可以key 自带的hashCode 去计算hash, 而采用hashCode的高低位的原因:</p><pre><code class="hljs">1. key的hashCode 只是返回了键值自带的hash值，范围是2^-31 到 2^31 大概40亿的映射空间, 问题是那么大的映射空间内存放不下</code></pre><p><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></p><p>JDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-comment">// key.hashCode()：返回散列值也就是hashcode</span><br>    <span class="hljs-comment">// ^ ：按位异或</span><br>    <span class="hljs-comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span><br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>对比一下 JDK1.7的 HashMap 的 hash 方法源码.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(<span class="hljs-type">int</span> h)</span> &#123;<br>    <span class="hljs-comment">// This function ensures that hashCodes that differ only by</span><br>    <span class="hljs-comment">// constant multiples at each bit position have a bounded</span><br>    <span class="hljs-comment">// number of collisions (approximately 8 at default load factor).</span><br><br>    h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);<br>    <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p><p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/jdk1.8%E4%B9%8B%E5%89%8D%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.png" alt="jdk1.8之前的内部结构"></p><h3 id="JDK1-8之后"><a href="#JDK1-8之后" class="headerlink" title="JDK1.8之后"></a>JDK1.8之后</h3><p>相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-22/67233764.jpg" alt="JDK1.8之后的HashMap底层数据结构"></p><ul><li><p><strong>loadFactor加载因子</strong></p><p>loadFactor加载因子是控制数组存放数据的疏密程度，loadFactor越趋近于1，那么   数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。</p><p><strong>loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值</strong>。</p><p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 &#x3D; 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p></li><li><p><strong>threshold</strong></p><p><strong>threshold &#x3D; capacity * loadFactor</strong>，<strong>当Size&gt;&#x3D;threshold</strong>的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。</p></li></ul><p><strong>Node节点类源码:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 继承自 Map.Entry&lt;K,V&gt;</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br>       <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<span class="hljs-comment">// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span><br>       <span class="hljs-keyword">final</span> K key;<span class="hljs-comment">//键</span><br>       V value;<span class="hljs-comment">//值</span><br>       <span class="hljs-comment">// 指向下一个节点</span><br>       Node&lt;K,V&gt; next;<br>       Node(<span class="hljs-type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;<br>            <span class="hljs-built_in">this</span>.hash = hash;<br>            <span class="hljs-built_in">this</span>.key = key;<br>            <span class="hljs-built_in">this</span>.value = value;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> K <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span>        &#123; <span class="hljs-keyword">return</span> key; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span>      &#123; <span class="hljs-keyword">return</span> value; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> key + <span class="hljs-string">&quot;=&quot;</span> + value; &#125;<br>        <span class="hljs-comment">// 重写hashCode()方法</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">setValue</span><span class="hljs-params">(V newValue)</span> &#123;<br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> value;<br>            value = newValue;<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>        <span class="hljs-comment">// 重写 equals() 方法</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>            <span class="hljs-keyword">if</span> (o == <span class="hljs-built_in">this</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Map.Entry) &#123;<br>                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;<br>                <span class="hljs-keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;<br>                    Objects.equals(value, e.getValue()))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>树节点类源码:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;<br>        TreeNode&lt;K,V&gt; parent;  <span class="hljs-comment">// 父</span><br>        TreeNode&lt;K,V&gt; left;    <span class="hljs-comment">// 左</span><br>        TreeNode&lt;K,V&gt; right;   <span class="hljs-comment">// 右</span><br>        TreeNode&lt;K,V&gt; prev;    <span class="hljs-comment">// needed to unlink next upon deletion</span><br>        <span class="hljs-type">boolean</span> red;           <span class="hljs-comment">// 判断颜色</span><br>        TreeNode(<span class="hljs-type">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;<br>            <span class="hljs-built_in">super</span>(hash, key, val, next);<br>        &#125;<br>        <span class="hljs-comment">// 返回根节点</span><br>        <span class="hljs-keyword">final</span> TreeNode&lt;K,V&gt; <span class="hljs-title function_">root</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="hljs-built_in">this</span>, p;;) &#123;<br>                <span class="hljs-keyword">if</span> ((p = r.parent) == <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span> r;<br>                r = p;<br>       &#125;<br></code></pre></td></tr></table></figure><h2 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>HashMap 中有四个构造方法，它们分别如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 默认构造函数。</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="hljs-comment">// all   other fields defaulted</span><br> &#125;<br><br> <span class="hljs-comment">// 包含另一个“Map”的构造函数</span><br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;<br>     <span class="hljs-built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;<br>     putMapEntries(m, <span class="hljs-literal">false</span>);<span class="hljs-comment">//下面会分析到这个方法</span><br> &#125;<br><br> <span class="hljs-comment">// 指定“容量大小”的构造函数</span><br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>     <span class="hljs-built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);<br> &#125;<br><br> <span class="hljs-comment">// 指定“容量大小”和“加载因子”的构造函数</span><br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor)</span> &#123;<br>     <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);<br>     <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>         initialCapacity = MAXIMUM_CAPACITY;<br>     <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> + loadFactor);<br>     <span class="hljs-built_in">this</span>.loadFactor = loadFactor;<br>     <span class="hljs-built_in">this</span>.threshold = tableSizeFor(initialCapacity);<br> &#125;<br></code></pre></td></tr></table></figure><p><strong>putMapEntries方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putMapEntries</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m, <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> m.size();<br>    <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 判断table是否已经初始化</span><br>        <span class="hljs-keyword">if</span> (table == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// pre-size</span><br>            <span class="hljs-comment">// 未初始化，s为m的实际元素个数</span><br>            <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> ((<span class="hljs-type">float</span>)s / loadFactor) + <span class="hljs-number">1.0F</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> ((ft &lt; (<span class="hljs-type">float</span>)MAXIMUM_CAPACITY) ?<br>                    (<span class="hljs-type">int</span>)ft : MAXIMUM_CAPACITY);<br>            <span class="hljs-comment">// 计算得到的t大于阈值，则初始化阈值</span><br>            <span class="hljs-keyword">if</span> (t &gt; threshold)<br>                threshold = tableSizeFor(t);<br>        &#125;<br>        <span class="hljs-comment">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s &gt; threshold)<br>            resize();<br>        <span class="hljs-comment">// 将m中的所有元素添加至HashMap中</span><br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">K</span>, ? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">V</span>&gt; e : m.entrySet()) &#123;<br>            <span class="hljs-type">K</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> e.getKey();<br>            <span class="hljs-type">V</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> e.getValue();<br>            putVal(hash(key), key, value, <span class="hljs-literal">false</span>, evict);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><p>HashMap只提供了put用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。</p><p><strong>对putVal方法添加元素的分析如下：</strong></p><ul><li>①如果定位到的数组位置没有元素 就直接插入。</li><li>②如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果key不相同，就判断p是否是一个树节点，如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)。</li></ul><p>ps:下图有一个小问题，来自 <a href="https://github.com/Snailclimb/JavaGuide/issues/608">issue#608</a>指出：直接覆盖之后应该就会 return，不会有后续操作。参考 JDK8 HashMap.java 658 行。</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/put%E6%96%B9%E6%B3%95.png" alt="put方法"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">                   <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;<br>    <span class="hljs-comment">// table未初始化或者长度为0，进行扩容</span><br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        n = (tab = resize()).length;<br>    <span class="hljs-comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>        tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>    <span class="hljs-comment">// 桶中已经存在元素</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                <span class="hljs-comment">// 将第一个元素赋值给e，用e来记录</span><br>                e = p;<br>        <span class="hljs-comment">// hash值不相等，即key不相等；为红黑树结点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>            <span class="hljs-comment">// 放入树中</span><br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br>        <span class="hljs-comment">// 为链表结点</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 在链表最末插入结点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-comment">// 到达链表的尾部</span><br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// 在尾部插入新结点</span><br>                    p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">// 结点数量达到阈值，转化为红黑树</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-comment">// 跳出循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span><br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-comment">// 相等，跳出循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span><br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 记录e的value</span><br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>            <span class="hljs-comment">// onlyIfAbsent为false或者旧值为null</span><br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                <span class="hljs-comment">//用新值替换旧值</span><br>                e.value = value;<br>            <span class="hljs-comment">// 访问后回调</span><br>            afterNodeAccess(e);<br>            <span class="hljs-comment">// 返回旧值</span><br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 结构性修改</span><br>    ++modCount;<br>    <span class="hljs-comment">// 实际大小大于阈值则扩容</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    <span class="hljs-comment">// 插入后回调</span><br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>我们再来对比一下 JDK1.7 put方法的代码</strong></p><p><strong>对于put方法的分析如下：</strong></p><ul><li>①如果定位到的数组位置没有元素 就直接插入。</li><li>②如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的key比较，如果key相同就直接覆盖，不同就采用头插法插入元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span><br>    <span class="hljs-keyword">if</span> (table == EMPTY_TABLE) &#123;<br>    inflateTable(threshold);<br>&#125;  <br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> putForNullKey(value);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> hash(key);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexFor(hash, table.length);<br>    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="hljs-literal">null</span>; e = e.next) &#123; <span class="hljs-comment">// 先遍历</span><br>        Object k;<br>        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;<br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>            e.value = value;<br>            e.recordAccess(<span class="hljs-built_in">this</span>);<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br><br>    modCount++;<br>    addEntry(hash, key, value, i);  <span class="hljs-comment">// 再插入</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>    Node&lt;K,V&gt; e;<br>    <span class="hljs-keyword">return</span> (e = getNode(hash(key), key)) == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : e.value;<br>&#125;<br><br><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title function_">getNode</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="hljs-type">int</span> n; K k;<br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 数组元素相等</span><br>        <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span><br>            ((k = first.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>            <span class="hljs-keyword">return</span> first;<br>        <span class="hljs-comment">// 桶中不止一个节点</span><br>        <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 在树中get</span><br>            <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)<br>                <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);<br>            <span class="hljs-comment">// 在链表中get</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">return</span> e;<br>            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h3><p>进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCap</span> <span class="hljs-operator">=</span> (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldThr</span> <span class="hljs-operator">=</span> threshold;<br>    <span class="hljs-type">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<br>        &#125;<br>        <span class="hljs-comment">// 没超过最大值，就扩充为原来的2倍</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span><br>        newCap = oldThr;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// signifies using defaults</span><br>        newCap = DEFAULT_INITIAL_CAPACITY;<br>        newThr = (<span class="hljs-type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br>    <span class="hljs-comment">// 计算新的resize上限</span><br>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)newCap * loadFactor;<br>        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-type">float</span>)MAXIMUM_CAPACITY ? (<span class="hljs-type">int</span>)ft : Integer.MAX_VALUE);<br>    &#125;<br>    threshold = newThr;<br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[newCap];<br>    table = newTab;<br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 把每个bucket都移动到新的buckets中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;<br>                oldTab[j] = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)<br>                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)<br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, newTab, j, oldCap);<br>                <span class="hljs-keyword">else</span> &#123;<br>                    Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-keyword">do</span> &#123;<br>                        next = e.next;<br>                        <span class="hljs-comment">// 原索引</span><br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)<br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                loTail.next = e;<br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-comment">// 原索引+oldCap</span><br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)<br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">// 原索引放到bucket里</span><br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;<br>                        loTail.next = <span class="hljs-literal">null</span>;<br>                        newTab[j] = loHead;<br>                    &#125;<br>                    <span class="hljs-comment">// 原索引+oldCap放到bucket里</span><br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-literal">null</span>;<br>                        newTab[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newTab;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>jdk</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>netty</title>
    <link href="/2022/01/24/netty/eventLoop/"/>
    <url>/2022/01/24/netty/eventLoop/</url>
    
    <content type="html"><![CDATA[<h2 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h2><h3 id="创建bossGroup-和-workerGroup"><a href="#创建bossGroup-和-workerGroup" class="headerlink" title="创建bossGroup 和 workerGroup"></a>创建bossGroup 和 workerGroup</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">1</span>);<br><span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">workerGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br><span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br>bootstrap.group(bossGroup, workerGroup)<br>        .channel(NioServerSocketChannel.class)<br>        .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.INFO))<br>        .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ch.pipeline();<br>                pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IdleStateHandler</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, TimeUnit.SECONDS));<br>                pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpResponseEncoder</span>());<br>                pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpRequestDecoder</span>());<br>                pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpObjectAggregator</span>(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">64</span>));<br>            &#125;<br>        &#125;);<br><span class="hljs-type">Channel</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> bootstrap.bind(PORT).sync().channel();<br></code></pre></td></tr></table></figure><h3 id="初始化NioEventLoopGroup"><a href="#初始化NioEventLoopGroup" class="headerlink" title="初始化NioEventLoopGroup"></a>初始化NioEventLoopGroup</h3><ul><li>创建 eventLoopGroup 默认 的core 线程数: 不指定的情况下为核数的2倍</li><li>初始化类的关系NioEventLoopGroup -&gt; MultithreadEventLoopGroup -&gt;MultithreadEventExecutorGroup -&gt; AbstractEventExecutorGroup</li></ul><h4 id="MultithreadEventExecutorGroup-初始化的流程"><a href="#MultithreadEventExecutorGroup-初始化的流程" class="headerlink" title="MultithreadEventExecutorGroup 初始化的流程"></a>MultithreadEventExecutorGroup 初始化的流程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventExecutor</span>[nThreads];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nThreads; i ++) &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        children[i] = newChild(executor, args);<br>        success = <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Think about if this is a good exception type</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;failed to create a child event loop&quot;</span>, e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (!success) &#123;<br>            <span class="hljs-comment">//dosomething</span><br>        &#125;<br>    &#125;<br>&#125;<br>chooser = chooserFactory.newChooser(children);<br><span class="hljs-keyword">final</span> FutureListener&lt;Object&gt; terminationListener = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureListener</span>&lt;Object&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(Future&lt;Object&gt; future)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">if</span> (terminatedChildren.incrementAndGet() == children.length) &#123;<br>            terminationFuture.setSuccess(<span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">for</span> (EventExecutor e: children) &#123;<br>    e.terminationFuture().addListener(terminationListener);<br>&#125;<br>Set&lt;EventExecutor&gt; childrenSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;EventExecutor&gt;(children.length);<br>Collections.addAll(childrenSet, children);<br>readonlyChildren = Collections.unmodifiableSet(childrenSet);    <br></code></pre></td></tr></table></figure><p>其中children 初始化为EventExecutor[];newChild 初始化在 NioEventLoopGroup 中进行了初始化NioEventLoop -&gt; SingleThreadEventLoop -&gt; SingleThreadEventExecutor -&gt; AbstractScheduledEventExecutor -&gt; AbstractEventExecutor 其中在创建时进行传递的 NioEventLoopGroup 用的是this,因此传递过去的 loopGroup 是NioEventLoopGroup 自身EventExecutorChooser 在进行选择的时候会去根据判断loopGroup的size，如果是2的指数的话用指数选择器, 不是的话用普通选择器</p><ul><li>问题:为什么要这样去区分???<br>指数选择器和普通选择器可以更加高效去进行获取到loopGroup，原因是在进行 &amp; 操作比 % 更快</li></ul><h3 id="serverBootStrap相关初始化"><a href="#serverBootStrap相关初始化" class="headerlink" title="serverBootStrap相关初始化"></a>serverBootStrap相关初始化</h3><pre><code class="hljs">ServerBootstrap -&gt; AbstractBootstrap</code></pre><h4 id="绑定boss和worker信息"><a href="#绑定boss和worker信息" class="headerlink" title="绑定boss和worker信息"></a>绑定boss和worker信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">bootstrap.group(bossGroup, workerGroup)<br></code></pre></td></tr></table></figure><p>AbstractBootStrap 的group 绑定boss 信息, serverBootStrap 绑定worker信息</p><h4 id="初始化channel-Factory"><a href="#初始化channel-Factory" class="headerlink" title="初始化channel Factory"></a>初始化channel Factory</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">channel(NioServerSocketChannel.class)<br></code></pre></td></tr></table></figure><p>调用父类 AbstractBootstrap 的反射去构造channel</p><h4 id="绑定handler"><a href="#绑定handler" class="headerlink" title="绑定handler"></a>绑定handler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.INFO))<br>childHandler();<br></code></pre></td></tr></table></figure><p>handler 方法是属于AbstractBootstrap的, childHandler 方法是属于 ServerBootstrap<br>childHandler 用于处理客户端建立连接后, handler 用于处理初始化的过程</p><h4 id="绑定端口号"><a href="#绑定端口号" class="headerlink" title="绑定端口号"></a>绑定端口号</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> ChannelFuture <span class="hljs-title function_">doBind</span><span class="hljs-params">(<span class="hljs-keyword">final</span> SocketAddress localAddress)</span> &#123;<br>    <span class="hljs-comment">//初始化和注册</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">regFuture</span> <span class="hljs-operator">=</span> initAndRegister();<br>    <span class="hljs-comment">//拿到刚刚注册上去的channel</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> regFuture.channel();<br>    <span class="hljs-keyword">if</span> (regFuture.isDone()) &#123;<br>        <span class="hljs-type">ChannelPromise</span> <span class="hljs-variable">promise</span> <span class="hljs-operator">=</span> channel.newPromise();<br>        <span class="hljs-comment">//进行绑定</span><br>        doBind0(regFuture, channel, localAddress, promise);<br>        <span class="hljs-keyword">return</span> promise;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">PendingRegistrationPromise</span> <span class="hljs-variable">promise</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PendingRegistrationPromise</span>(channel);<br>        regFuture.addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelFutureListener</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                <span class="hljs-type">Throwable</span> <span class="hljs-variable">cause</span> <span class="hljs-operator">=</span> future.cause();<br>                <span class="hljs-keyword">if</span> (cause != <span class="hljs-literal">null</span>) &#123;<br>                    promise.setFailure(cause);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    promise.registered();<br>                    doBind0(regFuture, channel, localAddress, promise);<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">return</span> promise;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="初始化和注册"><a href="#初始化和注册" class="headerlink" title="初始化和注册"></a>初始化和注册</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title function_">initAndRegister</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//通过反射去初始化创建channel,NioServerSocketChannel 属性</span><br>        channel = channelFactory.newChannel();<br>        <span class="hljs-comment">//进行初始化channel</span><br>        init(channel);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-comment">//dosomething</span><br>    &#125;<br>    <span class="hljs-comment">//group 注册</span><br>    <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">regFuture</span> <span class="hljs-operator">=</span> config().group().register(channel);<br>    <span class="hljs-keyword">if</span> (regFuture.cause() != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (channel.isRegistered()) &#123;<br>            channel.close();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            channel.unsafe().closeForcibly();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> regFuture;<br>&#125;<br></code></pre></td></tr></table></figure><p>channelFactory 是在 group 初始化channel Factory的时候传进来的，因此调用时创建的时 NioServerSocketChannel<br>NioServerSocketChannel -&gt; AbstractNioMessageChannel -&gt; AbstractNioChannel -&gt; AbstractChannel<br>NioServerSocketChannel 在初始化时指定 SelectionKey.OP_ACCEPT<br>在AbstractChannel 中设置了 pipieline, pipeline 中创建了 DefaultChannelPipeline, 初始化的设置了双链表  </p><h4 id="初始化channel"><a href="#初始化channel" class="headerlink" title="初始化channel"></a>初始化channel</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(Channel channel)</span> &#123;<br>    setChannelOptions(channel, newOptionsArray(), logger);<br>    setAttributes(channel, attrs0().entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY));<br>    <span class="hljs-comment">//拿到 NioServerSocketChannel 属性pipeline(DefaultChannelPipeline)</span><br>    <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> channel.pipeline();<br>    <span class="hljs-comment">//拿到 worker 的 group 信息</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">currentChildGroup</span> <span class="hljs-operator">=</span> childGroup;<br>    <span class="hljs-comment">//拿到 worker 的 handler 信息</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelHandler</span> <span class="hljs-variable">currentChildHandler</span> <span class="hljs-operator">=</span> childHandler;<br>    <span class="hljs-keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;<br>    <span class="hljs-keyword">synchronized</span> (childOptions) &#123;<br>        currentChildOptions = childOptions.entrySet().toArray(EMPTY_OPTION_ARRAY);<br>    &#125;<br>    <span class="hljs-keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs = childAttrs.entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY);<br>    <span class="hljs-comment">// 增加pipeline</span><br>    p.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Channel ch)</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ch.pipeline();<br>            <span class="hljs-comment">//将初始化的handler 进行加入进来</span><br>            <span class="hljs-type">ChannelHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> config.handler();<br>            <span class="hljs-keyword">if</span> (handler != <span class="hljs-literal">null</span>) &#123;<br>                pipeline.addLast(handler);<br>            &#125;<br><br>            ch.eventLoop().execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrapAcceptor</span>(ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>在进行 addLast 的时候将ChannelInitializer 封装成一个 task 用于后面的回掉</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title function_">addLast</span><span class="hljs-params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> &#123;<br>    <span class="hljs-keyword">final</span> AbstractChannelHandlerContext newCtx;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        checkMultiplicity(handler);<br>        newCtx = newContext(group, filterName(name, handler), handler);<br>        addLast0(newCtx);<br>        <span class="hljs-keyword">if</span> (!registered) &#123;<br>            newCtx.setAddPending();<br>            callHandlerCallbackLater(newCtx, <span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>        <span class="hljs-comment">//dosomething</span><br>    &#125;<br>    <span class="hljs-comment">//dosomething</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="将channel-注册绑定"><a href="#将channel-注册绑定" class="headerlink" title="将channel 注册绑定"></a>将channel 注册绑定</h4><p>ChannelFuture regFuture &#x3D; config().group().register(channel);<br>其中EventGroup 是 刚刚在进行 group 绑定的是 bossGroup, bossGroup 中register 注册的是 MultithreadEventLoopGroup, MultithreadEventLoopGroup 在获取 EventLoop 的时候<br>调用的是父类的MultithreadEventExecutorGroup 的chooser选择一个线程池去创建，这里面选择的线程池是(初始化NioEventLoopGroup) 中提及的, NioEventLoop 调用<br>SingleThreadEventLoop中的register(Channel), 最终调用AbstractChannel 中 AbstractUnsafe 内部类 的 register 方法终于到了实际注册的地方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(EventLoop eventLoop, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> &#123;<br>    <span class="hljs-comment">//dosomething</span><br>    AbstractChannel.<span class="hljs-built_in">this</span>.eventLoop = eventLoop;<br>    <span class="hljs-keyword">if</span> (eventLoop.inEventLoop()) &#123;<br>        register0(promise);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            eventLoop.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    register0(promise);<br>                &#125;<br>            &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            <span class="hljs-comment">//dosomething</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="register0"><a href="#register0" class="headerlink" title="register0"></a>register0</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register0</span><span class="hljs-params">(ChannelPromise promise)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">firstRegistration</span> <span class="hljs-operator">=</span> neverRegistered;<br>        doRegister();<br>        neverRegistered = <span class="hljs-literal">false</span>;<br>        registered = <span class="hljs-literal">true</span>;<br><br>        pipeline.invokeHandlerAddedIfNeeded();<br>        safeSetSuccess(promise);<br><br>        pipeline.fireChannelRegistered();<br>        <span class="hljs-keyword">if</span> (isActive()) &#123;<br>            <span class="hljs-keyword">if</span> (firstRegistration) &#123;<br>                pipeline.fireChannelActive();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (config().isAutoRead()) &#123;<br>                beginRead();<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-comment">//dosomething</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="注册过程"><a href="#注册过程" class="headerlink" title="注册过程"></a>注册过程</h4><p>将自己去调用jdk 原生的进行注册<br>selectionKey &#x3D; javaChannel().register(eventLoop().unwrappedSelector(), 0, this);再去回掉绑定handler 时的 pendingHandlerCallbackHead, 里面会将child pipeline 和 boosBootStrap 绑定在一起拿到 boosBootStrap 的channel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ch.pipeline();<br><span class="hljs-type">ChannelHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> config.handler();<br><span class="hljs-keyword">if</span> (handler != <span class="hljs-literal">null</span>) &#123;<br>    pipeline.addLast(handler);<br>&#125;<br>ch.eventLoop().execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//boosBootStrap的pipeline 添加ServerBootstrapAcceptor, 其中currentChildHandler 为worker的handler</span><br>        pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrapAcceptor</span>(<br>                ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><pre><code class="hljs">inBound handler 中事件进行传递pipeline.fireChannelRegistered();</code></pre><p>#2. reactor 思想<br>#3. bossEventLoop 是如何接收到客户端的请求的?<br>#4. bossEventLoop 如何将事件给workerEventLoop的？<br>#5. eventLoop 轮训的时候，如何解决jdk的空轮训的bug 的？</p>]]></content>
    
    
    <categories>
      
      <category>netty</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
