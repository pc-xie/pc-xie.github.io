<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>开放性问题</title>
    <link href="/2024/09/24/interview/%E5%BC%80%E6%94%BE%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    <url>/2024/09/24/interview/%E5%BC%80%E6%94%BE%E6%80%A7%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="印象比较深的case"><a href="#印象比较深的case" class="headerlink" title="印象比较深的case"></a>印象比较深的case</h1><pre><code class="hljs">  自己有价值, 有意义的项目 或者事情  自己觉得厉害的事情  自己觉得比较厉害的case事件背景 + 难点表述 + 解决方案 + 最终产物    由此酒店有个用户反馈过来说配置变更后推送没有推送成果, 需要进程重启后再去拉取配置文件. 并且出现的概率的话, 大概是在半年前出现过一次, 现在改了一个配置, 几百台机器里面有一台配置是没有拉取到.    并且不是说必现的. 同时改bug 如果大规模出现的话, 会导致配置推送失败1.1 客户端请求丢失, 因为场景比较难以复线, 是在用户发生了OOM, 并且主动去触发, 触发的时候也不是说每次都可以发生的    为什么觉得难:        1. 线程丢了        2. 日志不符合预期        3.  难以复现    怎么排查的:         1. 用户当时的内存文件进行 dump 下来.         2. 通过 MAT 去分析线程的dump        3. 分析内存中客户端使用到的对象属性        4. 本地封装netty 发送请求的代码, 进行复现        5. 请求的时候一直增加压力, 进行主动System.gc()        6. 可以复线. 再去增加日志. 堆着代码排查        7. 原因: netty 3.X 的版本中在OOM的时候对超时的设置有bug. 还有就是发生了OOM 后 抛出异常, 自身异常没有catch主        8. 解决办法, 升级netty 的版本</code></pre><h1 id="个人优点"><a href="#个人优点" class="headerlink" title="个人优点:"></a>个人优点:</h1><pre><code class="hljs">抗压能力强, 有责任心</code></pre><h1 id="个人缺点"><a href="#个人缺点" class="headerlink" title="个人缺点"></a>个人缺点</h1><pre><code class="hljs">我的演讲能力比较差，面对着太多人说话会感到紧张，不过讨论熟悉的领域我会比较放松。所以当我需要公开发言时，必须做足准备才行</code></pre><h1 id="自己觉得厉害的事情"><a href="#自己觉得厉害的事情" class="headerlink" title="自己觉得厉害的事情"></a>自己觉得厉害的事情</h1><pre><code class="hljs">非技术上的: 日志的透明化,</code></pre><h1 id="个人关注的技术方向有哪些、以及了解渠道-如何提升自己"><a href="#个人关注的技术方向有哪些、以及了解渠道-如何提升自己" class="headerlink" title="个人关注的技术方向有哪些、以及了解渠道, 如何提升自己"></a>个人关注的技术方向有哪些、以及了解渠道, 如何提升自己</h1><pre><code class="hljs">1. 一些技术文章2. 开源社区</code></pre><h1 id="压力最大的事情"><a href="#压力最大的事情" class="headerlink" title="压力最大的事情:"></a>压力最大的事情:</h1><pre><code class="hljs">1. P0 级别的线上故障, 北京那边有用户请求过来, 有时候请求发现超时了, 但是后端业务那边说没有收到对应的请求内容, 由于请求量比较大, 网关这边也没有具体的请求, 因此怀疑用户是不是请求没有发过来, 自己确定日志是否有漏, 业务同学也确定日志是否有漏, 同时对应接口的其他请求是正常的, 由于该用户是大客户, 因此和领导以及业务同学协商, 决定在北京申请对应的机器, 网关也在那边部署服务, 业务也在那边部署服务. 最终用户请求稳定了</code></pre><h1 id="未来规划"><a href="#未来规划" class="headerlink" title="未来规划"></a>未来规划</h1><pre><code class="hljs">面试基础架构: 希望在XXX 方面有足够多的了解, 可以争取独当一面近期目标: 尽快融入新团队, 积累业务的相关背景知识, 将我以前的经验更好的在业务领域进行实践长期目标: 可以在某个业务领域可以独挡一面, 承担更多的责任</code></pre><h1 id="如何评价自己-x2F-朋友怎么评价你-x3D-x3D-x3D-x3D-x3D"><a href="#如何评价自己-x2F-朋友怎么评价你-x3D-x3D-x3D-x3D-x3D" class="headerlink" title="如何评价自己 &#x2F; 朋友怎么评价你 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;"></a>如何评价自己 &#x2F; 朋友怎么评价你 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</h1><pre><code class="hljs">1. 说我抗压能力强, 做事情比较认真在做网关的时候, 有个大客户在给我们发送请求的时候, 有个别请求会超时, 但是网关侧是没有相关的日志, 用户那边也是没有日志展示, 客户那边就是请求发过来30秒超时了。 就是在某个时间点后的有万份之一的概率丢失, 这个用户的是在北京那边, 然后我们公司内部的机器都是在上海这边的.1. 先帮用户解决问题:    1.1 北京搭建一样的网关机器, 然后通过专线到上海的机器来2. 用户问题解决了3. 为啥自身搭建专线就好了3.1 自己模拟这个现象去进行排查3.2 通过域名去发送请求, 直接走网关去进行发送请求, 发现过域名的时候, 有时候会有丢包的现象, 从而定位到是slb 到网关转发失败了, 再将这个现象给运维和阿里云的说, 最终是定位到阿里云内部升级了. 导致的问题。</code></pre><h1 id="核心竞争力是什么-为什么要录用我"><a href="#核心竞争力是什么-为什么要录用我" class="headerlink" title="核心竞争力是什么, 为什么要录用我"></a>核心竞争力是什么, 为什么要录用我</h1><pre><code class="hljs">1. 以前从事的是基础架构相关的工作, 由于公司业务发展的需要, 通过对服务端的修改, 使得网关服务端性能有了5倍的提升, 配置中心的端到端配置修改延迟在一秒内. 这些数据可以说明我在支持高并发, 性能提升上有足够的经验, 这些经验在业务领域也是需要的, 如何保证对外系统的稳定上, 是可以迁移的, 尤其是在服务端的处理上. </code></pre><h1 id="对公司有什么期望"><a href="#对公司有什么期望" class="headerlink" title="对公司有什么期望"></a>对公司有什么期望</h1><pre><code class="hljs">更好的为产品服务, </code></pre><h1 id="什么样的上级"><a href="#什么样的上级" class="headerlink" title="什么样的上级"></a>什么样的上级</h1><pre><code class="hljs">刚到公司有很多需要学习的, 适应环境是我首要的任务, 希望可以尽快发挥自己的能力, 专长希望上级可以在工作中多多指导, 我也立马纠正自己的错误</code></pre><h1 id="为什么选择这个公司"><a href="#为什么选择这个公司" class="headerlink" title="为什么选择这个公司"></a>为什么选择这个公司</h1><pre><code class="hljs">1. 公司潜力比较好, </code></pre><h1 id="如何处理压力"><a href="#如何处理压力" class="headerlink" title="如何处理压力"></a>如何处理压力</h1><pre><code class="hljs">1. 压力是工作中的一部分, 会找到压力的来源</code></pre><h1 id="你找工作时最看重的是什么？"><a href="#你找工作时最看重的是什么？" class="headerlink" title="你找工作时最看重的是什么？"></a>你找工作时最看重的是什么？</h1><pre><code class="hljs">公司的发展, 公司是比较注重实事的氛围1. 工作中的挑战, 可以快速提升自己, 经快发挥自己的能力, 实现自我价值</code></pre><h1 id="如何高效的学习"><a href="#如何高效的学习" class="headerlink" title="如何高效的学习"></a>如何高效的学习</h1><pre><code class="hljs">1. 碎片的时间会去看一些公众号啥的2. 然后固定的话会去看一下书啥的</code></pre><h1 id="针对一些临时的开放性问题"><a href="#针对一些临时的开放性问题" class="headerlink" title="针对一些临时的开放性问题"></a>针对一些临时的开放性问题</h1><pre><code class="hljs">分析问题 + 背后产生的原因</code></pre><h1 id="怎么看待加班"><a href="#怎么看待加班" class="headerlink" title="怎么看待加班"></a>怎么看待加班</h1><pre><code class="hljs">1. 可以, 公司业绩需要</code></pre><h1 id="离职原因"><a href="#离职原因" class="headerlink" title="离职原因:"></a>离职原因:</h1><pre><code class="hljs">1. 降薪</code></pre><h1 id="最后的提问"><a href="#最后的提问" class="headerlink" title="最后的提问"></a>最后的提问</h1><pre><code class="hljs">您希望这个岗位的人, 在入职半年或者一年后, 有什么样的成果, 或者是您对于这个岗位有什么要求</code></pre>]]></content>
    
    
    <categories>
      
      <category>总结</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面经</title>
    <link href="/2024/09/18/interview/%E9%9D%A2%E7%BB%8F/"/>
    <url>/2024/09/18/interview/%E9%9D%A2%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><h2 id="SHEIN"><a href="#SHEIN" class="headerlink" title="SHEIN"></a>SHEIN</h2><pre><code class="hljs">1. 项目2. 堆外内存的排障3. gdb --batch --pid 36563 --ex &#39;call malloc_trim() 进行内存释放2. 并发压不上去怎么处理3. dubbo4. grpc5. kafka6. redis7. HTTP 1.1 2.0 等8. jdk 各个版本的差异 为了解决什么问题9. spring spring boot 各个协议的问题, 并在下一个协议上怎么去解决的</code></pre><h2 id="哈罗单车"><a href="#哈罗单车" class="headerlink" title="哈罗单车"></a>哈罗单车</h2><pre><code class="hljs">1. 配置下发的流程2. 长轮训怎么实现的3. 服务端如何保证在超时后返回4. 服务端和客户端的负载均衡5. static 关键字修饰哪些6. 类加载的时候做一些事情, 怎么去实现7. 范型 好处, 为什么要引入范型8. 创建线程的方式    8.1. Thread 和 runnable 和 Callable 有什么关系???9. 线程池运行的逻辑是什么样的10. static int a 两个线程 执行100 次, 最终 a 的值是什么11. 数据库的事物是什么12. 代码中如何使用事物的    12.1 Transaction 注解, 怎么实现的    12.2 两个方法都加了transaction, transaction 是否在一个事物中还是多个事物下13. springBoot 的自动装配========14. 操作日志中怎么获取到当前用户    14.1 threadLocal15. 网关的突破性亮点是什么16. 工作量大不大17. 对其他中间件有没有了解18. redis 有哪些特性19. rocket mq 和 kafka 分别的场景</code></pre><h2 id="极兔速递"><a href="#极兔速递" class="headerlink" title="极兔速递"></a>极兔速递</h2><pre><code class="hljs">1. 网关为什么要用netty2. 线程数怎么去定的 为什么大多数是CPU 核数+1    2. 每个请求耗时比较高    3. 4. pipeline handler 是做什么用的5. 后端机器上下线    下游应用存在非RPC 或者是非6. 鉴权怎么做的?7. 限流怎么做的    7.1 为什么要自己去进行限流8. 为什么使用4C 8G 升级到4C 16G9. 全链路灰度怎么做的    全链路定义:    请求头的识别        9.1 header、body、param、cookie、流量比例10. 网关自身怎么灰度11. 针对异步的请求怎么去做灰度12. 配置中心怎么去做灰度的, 数据库等的话 需要影子库13. 自动生成API 文档怎么说的 -&gt; 自动性怎么体现14. serverless 架构思想怎么体现的15. 流量怎么监控, 监控的告警阈值怎么配置??????????  告警 限流 等治理?????16. Agent17. 个人评估觉得厉害的:    17.1     17.2     17.3 MQ 延迟队列、灰度功能18. spring boot 的扩展点有哪些19. 什么是动态代理20. 如果自己去实现动态代理怎么去做21. MQ 的消息扭转, 生产者 消费者怎么消费22. 长轮训 怎么理解???    为什么要用长轮训去做23. 时间轮 怎么做的24. 语言表达不清楚</code></pre><h2 id="霸王茶姬"><a href="#霸王茶姬" class="headerlink" title="霸王茶姬"></a>霸王茶姬</h2><pre><code class="hljs">1. 请求的URL 配置2. 全链路灰度怎么做的3. 自研网关和spring cloud 或者zuul 4. 限流的模式是什么    4.1 和sentional 5. zk 脑裂问题6. netty 中的 channel 作用是什么7. netty 中的 eventLoop 作用8. 线程数中各个参数的关系是什么9. mysql 的隔离级别10. 幻读怎么解决的11. 缓存和数据库的一致性问题12. redis 缓存穿透和 击穿13. synchronized14. hashMap 中的扩容因子选取    14.1 为什么是0.75</code></pre><h2 id="神舟"><a href="#神舟" class="headerlink" title="神舟"></a>神舟</h2><pre><code class="hljs">1. 集群化分2. 和spring Cloud 怎么去对比3. 后端 IP信息怎么动态感知4. 日志是怎么记录的6. spring 注解 和 配置中心加载读取的顺序</code></pre><h2 id="茄子科技"><a href="#茄子科技" class="headerlink" title="茄子科技"></a>茄子科技</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><pre><code class="hljs">1. 网关内外网流量怎么区分1. 内部服务治理有哪些    1.1 负载均衡    1.2 服务路由    1.3 服务降级    1.4 服务限流    1.5 服务监控2. 限流机制    1. 如何进行自我保护3. 网关下游处理时长抖动怎么保证网关的可用性4. 一次RPC 调用的过程请求的过程    服务注册:        服务的提供方在启动的时候将请求接口、方法、版本协议等信息注册到注册中心上        服务的消费者从注册中心订阅所依赖服务的信息, 注册中心会返回服务提供者地址的列表    服务发现        服务发现的过程, 服务的消费者会从注册中心拉取到服务提供者的列表并保存到本地缓存中, 当有新的服务的提供方或者老的服务提供方需要下线的时候, 注册中心会通知消费者, 消费者动态更新服务的提供者列表    服务准备调用        proxy 生成: 服务的消费者使用动态代理机制, 生成服务接口的代理对象, 当消费者调用接口方法时, 实际上是调用这个接口对象的方法        Cluster &amp; LoadBalance    网络通信准备        编码和序列化: 代理对象将方法调用, 参数信息封装成一个RPC请求, 通过编解码器对请求进行序列化和反序列化        Netty 通道管理: 使用 Netty 作为底层通信框架, 消费者和提供方之间的通信依赖 Netty 去进行传输数据    发送请求        consumer: 消费者通过Netty 客户端将序列化后的RPC 请求发送到指定的服务提供方        provider: 提供方的Netty server 会去接收请求, 并将其传递给指定的服务处理线程池去进行处理    请求处理        服务的提供方接收到请求并对接收到的数据进行反序列化, 恢复出原始请求对象        调用服务: 服务的提供方根据请求对象的服务名、方法名、通过反射的方式执行实际的业务逻辑        返回结果: 提供方将执行结果返回给响应对象, 并序列化后, 返回给发送方    接收响应        consumer: 消费者的Netty 客户端接收到响应后, 并将其反序列化成对象        结果处理: 将拿到的结果反序列化成对象返回给上层调用者    服务调用完成        上层的程序获得结果, 整个RPC 请求结束5. Netty 的一次网络请求过程是什么    客户端        初始化:            EventLoopGroup 的创建, 用于管理和服务之间网络链接和IO 操作, Bootstrap 配置客户端的各种参数, 包括线程模型, NioSocketChannel, 远端服务器的地址, 以及客户端的handler        建立链接            连接服务器: 通过Bootstrap.connect() 方法启动连接过程, 链接成功后会将channel 注册到event loop 上            等待建立连接完成:  connect() 返回一个ChannelFuture, 可以通过sync() 或者是addListener 进行完成        发送请求            构造数据进行请求, 连接成功后, 通过channel 向服务器发送数据, 通常是将请求封装成ByteBuf             对数据进行writeAndFlush 写数据, 数据会通过ChannelPipeline 的outbounder 进行处理, 通过底层的socket 发送到服务器        接收响应            pipeline 处理, 当服务器响应数据到的时候, 数据会到channelHander 的inbounder,            处理响应数据: 业务逻辑进行处理, 处理完后返回给应用层        关闭连接            主动关闭连接: channel.close 关闭连接, 释放资源            监听关闭操作: close 返回的future 进行监听, 进行监听关闭是否成功。        资源清理            group.shutDownGracefully() 进行清理    服务端        初始化阶段            创建EventLoopGroup, bossGroup 和 workerGroup, bossGroup 负责接受请求, workerGroup 负责处理BossGroup 分配过来的IO 操作            配置serverBootstrap: 使用ServerBootstrap 来配置Netty 服务, 包括channel 的类型, 指定EventLoopGroup, 配置channelPipeline, 以及设置服务器的监听端口        绑定端口            serverBootStrap.bind() 方法绑定服务器的监听端口, 会启动一个异步操作过程, bossGroup 中的线程会监听这个连接请求            bind() 返回一个future, 可以通过sync()  或者是addListener 来等待响应        接受客户端请求            bossGroup 中的线程会去监听端口的连接请求, 当有新的请求进来的时候, Netty会为这个连接创建一个channel, 并将其分配给worker 的EventLoop上,            注册channel: 新的channel 会被注册在worker Group 中的eventLoop 上, 接下来和这个连接的相关读写操作都是在这个EventLoop 上        处理客户端请求            每个channel 关联的channelpipeline, 包含了一系列的handler            当客户数据到达的时候, 数据会通过channelPipeline 中的inbounder 来进行处理, 负责数据的读取, 解码，业务逻辑处理等        响应客户端            当业务逻辑处理完后, 通过会通过ChannelHandlerContext.writeAndFlush() 将数据响应回给客户端            数据会通过channelpipeline 中的outbounder，然后通过底层的socket 发送给客户端        关闭连接            客户端关闭连接, 或者是服务端主动关闭连接的时候, Netty 会处发ChannelInbounderHandler 的channelInactive 或者是channelUnregistered, 可以进行资源清理            在关闭服务器的时候, 需要调用bossGroup 和worker Group 的shutdownGracefully 进行线程资源的释放6. TCP 流式处理怎么对流量进行拆分7. Redis 的高可用怎么保证的,     哨兵模式和主从模式    哨兵负责三个事情:         监控:             主观下线                发送Ping 命令给主节点, 如果主节点在一定时间内没有相应的话, 会被标记为SDOWN, 主观下线,            客观下线                多个哨兵节点通信认为某个节点不可用, 则认为改节点为客观下线, ODOWN        哨兵节点的选主:            在主节点被标记为ODOWN 后, 哨兵节点会通过RAFT进行一次投票选举, 确定哪个哨兵节点作为领导者, 负责执行故障转移, 每个哨兵节点可以发起投票,并且每个哨兵节点只能投票给一个哨兵节点            获得多数票的哨兵节点被选为领导者, 负责后续的主从切换        选择主节点            哨兵的leader 从可用的从节点中选主一个新的主节点, 主节点标准:                1. 从节点的优先级高的更可能被选中                2. 复制偏移量, (代表和主节点是否更接近的,) 更有可能选中                3. 链接状态好的            哨兵的leader 会向其他哨兵节点通知选主的主节点        主从切换            选中的从节点会倍提升为主节点, 新的主节点会停止从旧的主节点同步数据, 并且开始接受写入操作            重新配置集群,  其他从节点开始从新的主节点上去同步数据, 包含和旧的主节点连接的断开. 从新的主节点获取数据            通知客户端, 客户端根据配置更新配置        恢复正常运行8. 问题:    底层技术不是太差? 广度上不够, 需要对各个原理有了解</code></pre><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><pre><code class="hljs">1. 描述一下突出个人价值, 个人在项目中的重要性2. 开放性问题 一个是银行的 取号 一个是火车站排队3. 比较难熬的时间点    3.1. 怎么解决的4. 最近在看哪些东西的</code></pre><h2 id="得物"><a href="#得物" class="headerlink" title="得物"></a>得物</h2><pre><code class="hljs">1. java 中线程的状态有哪些2. sleep 和 wait 方法的区别3. 可见性和原子性    3.1 可见性如何保证</code></pre><ol start="4"><li><p>A 机器中数据发送到B 机器上 会有哪些数据拷贝<br><a href="https://www.xiaolincoding.com/os/8_network_system/zero_copy.html#%E4%BC%A0%E7%BB%9F%E7%9A%84%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E6%9C%89%E5%A4%9A%E7%B3%9F%E7%B3%95">答案</a></p></li><li><p>当前机器网线拔掉了, 然后过了一秒钟插回去, 这个时候对于TCP 连接有影响么<br><a href="https://www.xiaolincoding.com/network/3_tcp/tcp_unplug_the_network_cable.html#%E6%8B%94%E6%8E%89%E7%BD%91%E7%BA%BF%E5%90%8E-%E6%9C%89%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93">答案</a></p><ol start="6"><li>http 如何保证读取到响应的完整性</li><li>NIO 和 BIO 的主要区别<br> 7.1 非阻塞 怎么实现的<br> 7.2 epool 怎么工作的</li><li>netty 的 eventLoop 执行逻辑 </li><li>如果在GC 过程时内存不够分配怎么处理</li></ol></li></ol><h2 id="传音"><a href="#传音" class="headerlink" title="传音"></a>传音</h2><h3 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h3><pre><code class="hljs">1. 网关是不是从0 到 1 去做的2. 原来网关在哪里有问题3. 恶意流量怎么拦截    3.1 为什么耗时会比较长4. 把性能拖慢掉了 是因为什么5. 网关上考虑的核心指标是什么6. 网关机器上的连接数怎么看7. waf 在前面, 网关能否抗住8. 网关的签名是怎么做的9. 有哪些业务线在用网关10. 当前网关可以给业务提供什么能力????11. qconfig 和 apollo 的区别是什么12. netty 和 tomcat 上的改进是什么, 怎么去选择13. netty 去起一个服务端 和 一个客户端 怎么去做的14. 为什么要用 netty 去进行请求转发15. 对后面职业规划是怎么考虑的16. 技术 + 业务的面试    16.1 业务思维    16.2 业务困难点在什么上:        16.2.1 业务困难方在什么上, 如何站在业务的角度上去考虑问题        16.2.2 业务支付上的关心安全, 业务不同的需求是什么        16.2.3 </code></pre><h3 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h3><pre><code class="hljs">1. 自身的职业规划是什么2. 服务端团队有多少人3. 高可靠 + 高并发4. 个人优势5. 个人爱好6. 个人学习怎么学习的7. 对公司有什么期望8. 个人属于什么样的人</code></pre><h2 id="美团-DTS-组"><a href="#美团-DTS-组" class="headerlink" title="美团 DTS 组"></a>美团 DTS 组</h2><h3 id="一面-2"><a href="#一面-2" class="headerlink" title="一面"></a>一面</h3><pre><code class="hljs">1. qconfig 服务端 CAP 怎么选择, 为什么这样去选2. qconfig 元数据是否放在ZK 中3. 单元化的理解3.1 单元化如何实现的, 就是从整个公司的角度, 以及从配置中心角度=====3.2 单元化的时候数据怎么落到正确的存储上去    3.2.1 单元化的目的:4. 数据批量变换和数据预热怎么处理, 为什么要这样去做5. 批量变更在什么情况下有问题    5.1 批量变更不是delay 去做, 是从请求方开始就聚集去做处理6. jmap 查看堆上的内存, 查看内存占用的过程是什么样的7. pmap 查看堆外内存的场景,为什么会怀疑和malloc 分配内存有关联    7.1. ptmalloc 申请内存 和 jemlloc 为什么 ptmalloc    7.2 ptmalloc 中用户释放掉的内存, 为了下次快速使用, 会存到自己的空闲列表中, 因此导致了很多的64M 内存占用的问题8. 线程资源占用 应该调整哪个参数 或者jvm 应该怎么调整=======    1. 需要调整线程栈的大小 和 堆上的大小9. 稳定性有什么总结性的    9.1 幂等服务    =======    事物管理    限流熔断    重试机制10. 网关 为什么要从tomcat 换成netty11. 为什么netty 可以用更少的线程来做同样的事情12. netty 怎么去管理堆外内存    12.1 mmap + bytebuf    12.1 每个bytebuf 有个引用计数器, 当bytebuf 被使用的时候, 计数器+1, 不再需要使用的时候, 计数器-1, 当byteBuf关联的计数器降为0的时候。    通过PooledByteBufAllocator 和 ByteBuf 来实现的, 在需要使用堆外内存的时候, 分配一个新chunk 或者直接向操作系统申请一个, 然后通过ByteBuf 的API 对堆外内存去进行读写. 内存释放的时候通过引用计数机制的减少ResourceLeakDetector 可以用来检测-XX:MaxDirectMemorySize=1G 限制堆外内存的使用13. 网关上降本增效 怎么去做这个事情14. 读已提交 和 可重复读 怎么保证的15. mvcc 是利用什么机制实现的16. undo log 在什么时候会去删除掉17. undo log 在多版本比较的时候会在什么时候可以删除 ===============    17.1 当所有以来undo log 的事物都不再使用的时候就可以删除了18. 内存写了, 磁盘还没有落的时候, crash 了.  怎么去保证19. synchronized 的锁升级的过程20. cas 会有什么问题</code></pre><h3 id="二面-2"><a href="#二面-2" class="headerlink" title="二面"></a>二面</h3><pre><code class="hljs">1. 项目哪个印象更深刻一点2. 详细介绍一下配置中心做了哪些事情3. 配置读取的单元化    3.1 配置读取的就近读、就近写的单元化, 配置中心底层的数据读取怎么做到单元化    3.2 配置中心数据放在MGR数据库上, MGR集群4. 网关tomcat 换成netty 为什么要去做这个事情5. 对重要应用的隔离是怎么去做的    5.1 重要应用的定义怎么定义    5.1 重要性怎么收集6. 网关集群流量配置的灰度, 配置的灰度怎么去做的7. 网关流量权重怎么设计的8. 网关灰度的机器和普通机器怎么做, 其他人是怎么做的 业界方案怎么做的9. 单台机器QPS 从多少提升到10000    9.1 原来值是多少 2000    9.2 做了哪些改造有那么高提升10. 网关服务的容灾 和 高可用11. 网关的水平扩、缩容怎么做的12. 基于k8s 的自动扩缩容, 提供给业务同学用, 和网关之间的关联性    12.1 进行扩缩绒的标准是什么    12.2 自动扩缩容的机制是怎么实现的    12.3 采集流量的QPS 信息    12.4 如何确定好下游的节点是够的???    12.5 弹性伸缩为什么要放在网关侧去做13. 网关项目的参与人    13.1 为啥人那么少14. 项目的迭代周期是什么    14.1 网关项目的重点是什么15. 网关转发的同样的请求, 转发到不同的应用、集群、机器上去16. 项目有什么做的不好的???17. 项目中长期的规划, 有哪些可以做的18. 对标其他公司的差距有哪些?                            网关 和 配置中心    18.1. 稳定性、容灾性、性能上的差距, 支持的能力上差距19. 性能优化的思路、流程    19.1 以耗时高的为例子    19.2 CPU比较高的话 排查工具20. 如何快速定位full GC21. java 服务 的full GC 多久是属于正常的22. java 服务日常关注哪些指标23. mysql 的高可用架构24. 主从架构下, mysql update 的数据流程25. 有了解过消息中间件么?? 使用的场景有么?26. 多线程并发工具, 如何控制多线程同步, 控制线程的调度顺序27. 网关部分线程池在什么情况下会用到28. 算法题: 接雨水29. 为什么离职30. 是否有其他offer31. 容灾、可用性、稳定性32. 个人关注的技术方向有哪些、以及了解渠道33. 日常自己总结, 提升效率的有什么方法</code></pre><h2 id="美团RPC"><a href="#美团RPC" class="headerlink" title="美团RPC"></a>美团RPC</h2><h3 id="一面-3"><a href="#一面-3" class="headerlink" title="一面"></a>一面</h3><pre><code class="hljs">1. 网关的部署架构是什么样的2. 网关按照不同的集群是根据什么去进行划分的3. 网关有多少个集群4. 后端的业务机器数量有多少个    4.1 机器数量    4.2 服务数量有多少5. 对比开源网关有什么区别     对比功能有什么区别    所有对比有哪些6. 网关部署的架构是什么样的7. 网关中 mysql 和 zk 数据有哪些区别8. 有哪些数据通过zk 进行通知9. 网关的灰度指的是什么10. 性能优化 tomcat 怎么分析    10.1 对比tomcat 的 startAsync 有什么区别    10.2 客户端的一个优化11. 日志的异步化 为什么要这样去做12. qconfig 的工作原理 数据架构是什么样的13. eureka 在 qconfig 作用是什么的14. 客户端和服务端数据, 如何拿到服务端的节点数据15. 服务端是否每次都是向数据库去要16. 如何保证服务端机器中的数据要老    16.1 轮训数据库是否会给数据库压力太大17. 推送延迟的一秒是如何计算的    17.1 各个计算节点耗时是怎么做的18. 自身怎么做单元化19. 客户端访问服务端 长轮训具体怎么做的    19.1 长轮训有什么缺陷20. 实际过程中CPU 高的情况21. GC 比较频繁怎么看    21.1 CPU 22. 印象比较深的case23. 技术文章啥的24. 链表反转</code></pre><h3 id="二面-3"><a href="#二面-3" class="headerlink" title="二面"></a>二面</h3><pre><code class="hljs">1. 换工作的原因2. 找新的工作, 比较看重什么3. 具体做的事情希望做什么4. 公司里面的项目角色是什么5. 过往的绩效, 老板的反馈是什么6. 过往经历的优势 和 劣势7. 配置中心是全局的大集群么8. 配置中心部署的模式9. 感知到变更 推送给所有服务端是否依赖于eureka10. 为什么不尝试扫表的逻辑, 通过 changeLog 来做   ==========   11. 小于一秒的延迟 是什么单位12. 怎么解决全局大集群的问题  控台上资源进行限制========13. 配置中心热点 key 怎么解决14. 怎么解决推送风暴的问题15. 怎么保证缓存一致性的, 服务端数据和MGR数据的一致性16. 推拉结合做作的    16.1 注册中心和配置中心的架构是不是差不多17. 异地多活和配置中心的关系18. API 网关前面那一层是否有nginx 负载19. 给下游转发的时候, 没有做范化调用20. api 平台通用的路由插件, 是否支持热更新, tomcat 换成netty21. 过往的经验中 有独立的探索和学习, 然后交付的事情22. 过往中, 最难的经历是怎么解决的23. 除去配置中心和网关, 是否学习过哪些其他的开源项目</code></pre><h2 id="华为"><a href="#华为" class="headerlink" title="华为"></a>华为</h2><h3 id="一面-4"><a href="#一面-4" class="headerlink" title="一面"></a>一面</h3><pre><code class="hljs">1. 单元化是什么意思2. 怎么做的单元化3. 配置中心是怎么做的4. 本地的降级文件为什么没有做成可推送的方式    4.1 热加载的情况下, 通过域名也有可能出问题5. 单元化里面数据库优化怎么做的6. GC 做了哪些优化    6.1. yong GC 做了哪些    6.2. full GC 做了哪些    6.3. 堆内哪些查看到7. 项目部署的是用什么方式部署的</code></pre><h3 id="二面-4"><a href="#二面-4" class="headerlink" title="二面"></a>二面</h3><pre><code class="hljs">1. 配置中心最具有复杂和挑战的是什么情况2. 在过程中日常开发怎么保持3. 单元化怎么理解的4. 数据库的预热读取具体指的是什么措施5. mysql MGR 提升数据的高可用实例指的是什么6. 内外流量是否有做区分7. serverless 架构的思想是什么8. 网关的机器配置9. netty httpClient 替换的思路, 启发 总结有什么.10. 异步调用链, traceId 和 spanId 是怎么做的11. 整体架构上有什么想法12. 线程和非线程安全collection 有哪些13. 抽象类和接口在什么情况下使用14. 锁的问题怎么处理15. 悲观锁和乐观锁的区别是什么</code></pre><h2 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h2><h3 id="抖音电商平台治理-一面"><a href="#抖音电商平台治理-一面" class="headerlink" title="抖音电商平台治理 一面"></a>抖音电商平台治理 一面</h3><pre><code class="hljs">1. </code></pre>]]></content>
    
    
    <categories>
      
      <category>总结</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>项目介绍</title>
    <link href="/2024/09/06/interview/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/"/>
    <url>/2024/09/06/interview/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="项目问题"><a href="#项目问题" class="headerlink" title="项目问题"></a>项目问题</h1><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>面试官, 您好, 我叫谢鹏程, 我是18年毕业于电子科技大学的, 我的工作经历都是和基础架构相关, 我的第一份工作是在携程的框架架构部门从事的是配置中心的相关工作, 第二份工作是在汇付天下做的api 网关相关的工作. 配置中心是公司各个系统用来对配置的管理、变更、以及维护的系统, 用户在界面上或者是通过restAPI 对配置文件进行变更, 可以在一秒以内推送到用户的机器上去, 其中像一些中间件的配置放在了配置中心上, 例如SOA 的一些超时配置、数据库的连接串、数据的超时配置等等. 其中在机房演练期间, 需要保证将数据库的连接串快速的推送到用户的机器上. 然后我在里面承担着配置中心的稳定性提升以及可用性易用性开发等职责. 另外一个项目在汇付天下从事的API网关, API网关是将外网流量转发到内网的机器上去, 同时也肩负着内网一些流程的转发, 例如前端或者一些控台类的, 需要走http 请求的. 我在里面承担着如何提升网关的性能, 以及稳定性易用性提升的一些相关工作.</p><h2 id="为什么需要将tomcat-换成netty"><a href="#为什么需要将tomcat-换成netty" class="headerlink" title="为什么需要将tomcat 换成netty"></a>为什么需要将tomcat 换成netty</h2><pre><code class="hljs">vmstat 1在请求量大的情况下:    1. CPU 负载发现急剧上升,     2. 整体请求的耗时一下子上来了排查原因:    1. 由于线程开的太多了, 上下文切换比较频繁    2. 有一些请求会由于tomcat 阻塞住了. 导致外部请求有堆积. 将允许的线程数开大的话, 会导致线程切换更加频繁解决办法: 将网络框架换成netty 去处理    1. tomcat 相比较于netty 的线程模型        1.1 tomcat 采用的是多线程阻塞模式, 每个请求对应到一个线程上去, 在请求量变多的情况下, 会导致线程数急剧上涨, 从而带来线程上下文的开销, 同时线程池中的核心线程数到了上限后, 后面过来的请求就是需要等待了. 对比netty 的线程模型, netty 采用了基于NIO 和 事件异步驱动的方式来处理的, 只需要通过少量的线程和eventLoop 机制就可以处理大量的并发请求, 它不会为每个请求创建一个线程, 通过少量的线程来管理多个IO 事件, 从而极大的避免了线程的上下文切换    2. IO 模型:        tomcat 采用的是 blockingIO, netty 采用的是NIO 来做的</code></pre><h3 id="netty-做为客户端发送请求-netty-做为服务端接收请求的完整流程是什么样的"><a href="#netty-做为客户端发送请求-netty-做为服务端接收请求的完整流程是什么样的" class="headerlink" title="netty 做为客户端发送请求, netty 做为服务端接收请求的完整流程是什么样的"></a>netty 做为客户端发送请求, netty 做为服务端接收请求的完整流程是什么样的</h3><pre><code class="hljs">客户端    初始化:        EventLoopGroup 的创建, 用于管理和服务之间网络链接和IO 操作, Bootstrap 配置客户端的各种参数, 包括线程模型, NioSocketChannel, 远端服务器的地址, 以及客户端的handler    建立链接        连接服务器: 通过Bootstrap.connect() 方法启动连接过程, 链接成功后会将channel 注册到event loop 上        等待建立连接完成:  connect() 返回一个ChannelFuture, 可以通过sync() 或者是addListener 进行完成    发送请求        构造数据进行请求, 连接成功后, 通过channel 向服务器发送数据, 通常是将请求封装成 ByteBuf         对数据进行writeAndFlush 写数据, 数据会通过ChannelPipeline 的outbounder 进行处理, 通过底层的socket 发送到服务器    接收响应        pipeline 处理, 当服务器响应数据到的时候, 数据会到channelHander 的inbounder,        处理响应数据: 业务逻辑进行处理, 处理完后返回给应用层    关闭连接        主动关闭连接: channel.close 关闭连接, 释放资源        监听关闭操作: close 返回的future 进行监听, 进行监听关闭是否成功。    资源清理        group.shutDownGracefully() 进行清理服务端    初始化阶段        创建EventLoopGroup, bossGroup 和 workerGroup, bossGroup 负责接受请求, workerGroup 负责处理; BossGroup 分配过来的IO 操作        配置 serverBootstrap : 使用 ServerBootstrap 来配置 Netty 服务, 包括 channel 的类型, 指定 EventLoopGroup, 配置 channelPipeline , 以及设置服务器的监听端口    绑定端口        serverBootStrap.bind() 方法绑定服务器的监听端口, 会启动一个异步操作过程, bossGroup 中的线程会监听这个连接请求        bind() 返回一个future, 可以通过sync()  或者是addListener 来等待响应    接受客户端请求        bossGroup 中的线程会去监听端口的连接请求, 当有新的请求进来的时候,bossGroup 中的某个eventLoop 会调用 NIO 的 selector 来监听OP_ACCEPT 事件, 一旦有新的连接时间发生, Boss Group 会接受这个连接并为这个连接创建一个channel, 并将连接对应的 channel 分配给worker 的EventLoop上,        注册channel: 新的channel 会被注册在worker Group 中的eventLoop 上, 接下来和这个连接的相关读写操作都是在这个EventLoop 上    处理客户端请求        每个channel 关联的channelpipeline, 包含了一系列的handler        当客户数据到达的时候, 数据会通过channelPipeline 中的inbounder 来进行处理, 负责数据的读取, 解码，业务逻辑处理等    响应客户端        当业务逻辑处理完后, 通过会通过ChannelHandlerContext.writeAndFlush() 将数据响应回给客户端        数据会通过channelpipeline 中的outbounder，然后通过底层的socket 发送给客户端    关闭连接        客户端关闭连接, 或者是服务端主动关闭连接的时候, Netty 会触发ChannelInbounderHandler 的channelInactive 或者是channelUnregistered, 可以进行资源清理        在关闭服务器的时候, 需要调用bossGroup 和worker Group 的shutdownGracefully 进行线程资源的释放</code></pre><h3 id="为什么tomcat-要用那么多线程去进行处理-而netty-用几个线程就可以去完成同样的事情"><a href="#为什么tomcat-要用那么多线程去进行处理-而netty-用几个线程就可以去完成同样的事情" class="headerlink" title="为什么tomcat 要用那么多线程去进行处理, 而netty 用几个线程就可以去完成同样的事情"></a>为什么tomcat 要用那么多线程去进行处理, 而netty 用几个线程就可以去完成同样的事情</h3><pre><code class="hljs">1. IO 模型上的差异    1. tomcat 是基于blocking IO 来实现的, 每个HTTP 请求创建一个独立的线程来做的, 如果线程被阻塞住了, 会导致无法处理其他任务. 为了保证高并发下可以去处理, tomcat 需要在配置足够多的线程去预先准备好, 但是线程数过多后会导致线程的上下文切换和内存开销, netty 是基于 NIO 和 事件驱动机制来做的, 不用为每个请求去创建一个线程去处理1. 事件驱动的设计    因为netty 是基于reactor 的事件驱动模型,worker 不处理整个请求的生命周期, 只响应或底层发出的网络事件, 使得只有事件触发的时候才去执行任务, 而不是阻塞等待2. 非阻塞 I/O    netty 使用的NIO 为非阻塞IO, selector 机制: 通过NIO的selector的机制, netty 可以让worker 线程管理多个channel, 当selector监听到某个channel 有IO 事件的时候, 该线程才会去处理这个channel, 在没有事件时, 线程会去监听而不被阻塞3. 任务划分与分离    bossGroup 和 workerGroup 的职责分离, bossGroup 专门处理连接的建立和关闭, 而worker Group 专注于处理已建立的连接的读写操作. 从而避免了线程资源的抢占4. 避免线程上下文的切换.     IO 的多路复用技术, 可以让一个线程监听多个channel 上的事件, 当channel 准备好读写的时候, 线程可以立即处理, 从而显著减少了线程数量</code></pre><h3 id="netty-的几个概念"><a href="#netty-的几个概念" class="headerlink" title="netty 的几个概念"></a>netty 的几个概念</h3><h4 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h4><pre><code class="hljs">负责网络IO操作相关的1.1 管理IO 操作    对数据读取、发送、和连接的管理1.2 处理事件    从网络传输到channelPipeline, 将channelPipeline 处理后的数据返回到网络中去1.3 支持异步IO    即将数据异步写入到网络中,不会阻塞当前线程</code></pre><h4 id="eventLoop"><a href="#eventLoop" class="headerlink" title="eventLoop"></a>eventLoop</h4><pre><code class="hljs">1.每一个EventLoop 维护着一个 Selector 和 线程2.处理IO 事件和任务    监视和处理IO事件, 基于Java NIO 的selector 事件3. 任务的调度    还可以管理定时任务和普通任务, 可以提交任务到eventLoop上, 按照顺序和指定周期执行4. 线程管理    一个eventLoop通常和一个线程绑定, 每个eventLoop 可以维护多个channel, 但一个channel 始终绑定在一个eventLoop 上, 确保了同一个channel 上的事件处理是线程安全的5. 事件的派发与处理    负责从IO操作中获取事件, 将这些事件派发到对应的ChannelHandler中, 每个channel 代表一个连接或者IO操作, 在其pipeline中的一系列处理</code></pre><h4 id="channelPipeline"><a href="#channelPipeline" class="headerlink" title="channelPipeline"></a>channelPipeline</h4><pre><code class="hljs">是一个处理链, 每个IO 事件都会按照顺序通过channelPipeline, 将多个channelHandler连接起来, 形成一条链, 每个channelHandler只负责处理特定的事件</code></pre><h4 id="channelHandler"><a href="#channelHandler" class="headerlink" title="channelHandler"></a>channelHandler</h4><pre><code class="hljs">用于处理特定类型事件的处理器, 不同的channelHandler 实现不同的功能, 有的可以用来编解码, 有的可以用来处理连接事件常见的inbounderHandler, outBounderHandler, IdleStateHandler,</code></pre><h4 id="netty-的堆外内存是怎么管理的"><a href="#netty-的堆外内存是怎么管理的" class="headerlink" title="netty 的堆外内存是怎么管理的"></a>netty 的堆外内存是怎么管理的</h4><pre><code class="hljs">通过PooledByteBufAllocator 和 ByteBuf 来实现的, 在需要使用堆外内存的时候, 分配一个新chunk 或者直接向操作系统申请一个, 然后通过ByteBuf 的API 对堆外内存去进行读写. 内存释放的时候通过引用计数机制的减少ResourceLeakDetector 可以用来检测-XX:MaxDirectMemorySize=1G 限制堆外内存的使用</code></pre><h4 id="netty-的事件驱动是怎么体现的"><a href="#netty-的事件驱动是怎么体现的" class="headerlink" title="netty 的事件驱动是怎么体现的"></a>netty 的事件驱动是怎么体现的</h4><pre><code class="hljs">基于reactor模式去做的, 通过EventLoop来管理IO 操作事件, 并将这些事件派发给相关的channelHandler, 实现高效的网络通信, 可以处理大量的并发连接核心组建:    eventLoop            1.每一个EventLoop 维护着一个 Selector 和 线程            2.处理IO 事件和任务                监视和处理IO事件, 基于Java NIO 的selector 事件            3. 任务的调度                还可以管理定时任务和普通任务, 可以提交任务到eventLoop上, 按照顺序和指定周期执行            4. 线程管理                一个eventLoop通常和一个线程绑定, 每个eventLoop 可以维护多个channel, 但一个channel 始终绑定在一个eventLoop 上, 确保了同一个channel 上的事件处理是线程安全的            5. 事件的派发与处理                负责从IO操作中获取事件, 将这些事件派发到对应的ChannelHandler中, 每个channel 代表一个连接或者IO操作, 在其pipeline中的一系列处理    channel            负责网络IO操作相关的            1.1 管理IO 操作                对数据读取、发送、和连接的管理            1.2 处理事件                从网络传输到channelPipeline, 将channelPipeline 处理后的数据返回到网络中去            1.3 支持异步IO                即将数据异步写入到网络中,不会阻塞当前线程    channelPipeline: 是一个处理链, 每个IO 事件都会按照顺序通过channelPipeline, 将多个channelHandler连接起来, 形成一条链, 每个channelHandler只负责处理特定的事件    channelHandler: 用于处理特定类型事件的处理器, 不同的channelHandler 实现不同的功能, 有的可以用来编解码, 有的可以用来处理连接事件    Selector: 用于监听多个Channel 上的IO 事件, 当selector 发现某个Channel 上有事件发生的时候, 会通过EvenetLoop 来进行处理工作流程:    boosGroup 和 workerGroup        bossGroup 负责监听客户端的连接请求事件, 将接收请求并将连接交给workerGroup进行处理        workerGroup负责处理具体的IO 操作    事件的监听与触发        当一个新的连接到达的时候, boss group 中的某个 eventLoop 会去调用 NIO  的selector 来监听 OP_ACCPEPT 事件, 一旦有连接事件发生, bossGroup 会接受这个连接并创建一个新的channel 对象, 并将这个channel 对象分配给workerGroup 中的一个eventLoop,  workerGroup 中的eventLoop 负责处理后续这个 channel 上的IO事件, 后续事件会按照事件类型依次在 channelPipeline 上流过, 通过channelHandler 来具体处理    channelHandler 处理事件        入站事件有inbounder 处理, 出站事件由outbounder 处理        每个channelHandler 可以对事件进行处理, 处理完成后让下一个处理器进行处理线程模型    EventLoop 绑定一个线程, 因此EventLoop管理的channel 也是在同一个线程上去运行的, 确保每个channel 上的事件处理是安全的, 从而减少了上下文切换的开销</code></pre><h4 id="netty-的零拷贝怎么实现的"><a href="#netty-的零拷贝怎么实现的" class="headerlink" title="netty 的零拷贝怎么实现的"></a>netty 的零拷贝怎么实现的</h4><pre><code class="hljs">零拷贝: 数据传输的过程中避免 CPU 参与多次不必要的数据拷贝, 从而提高IO 效率, 常见的方式有  sendfile mmap</code></pre><h2 id="为什么需要对后端连接去-池化-处理"><a href="#为什么需要对后端连接去-池化-处理" class="headerlink" title="为什么需要对后端连接去 池化 处理"></a>为什么需要对后端连接去 池化 处理</h2><pre><code class="hljs">1. 减少连接的创建和销毁带来的开销    1.1 每次创建新的连接都是需要建立TCP 链接的握手等操作, 连接池通过复用的连接, 避免了频繁的创建和销毁连接的开销, 同时可以降低资源的消耗2. 避免资源耗尽    2.1 连接池允许多个请求同时使用共存的连接, 同时会对后端机器、整个应用级别有连接数的限制, 防止资源的耗尽3. 优化响应时间    3.1 通过对连接的复用, 应用不需要等待新连接的创建或者释放, 提高了响应速度</code></pre><h2 id="为什么需要将请求去做全异步化-这样可以带来什么好处"><a href="#为什么需要将请求去做全异步化-这样可以带来什么好处" class="headerlink" title="为什么需要将请求去做全异步化, 这样可以带来什么好处"></a>为什么需要将请求去做全异步化, 这样可以带来什么好处</h2><pre><code class="hljs">1. 提高网关自身的稳定性2. 防止由于后端应用处理耗时上涨, 将整体性能拖垮</code></pre><h2 id="集群拆分可以带来什么好处"><a href="#集群拆分可以带来什么好处" class="headerlink" title="集群拆分可以带来什么好处"></a>集群拆分可以带来什么好处</h2><pre><code class="hljs">1. 提高系统的可用性和容错性值    1.1 避免个别应用的问题影响到全局的, 进行了故障隔离, 2. 提升了可维护性    2.1 针对指定功能的使用上,</code></pre><h2 id="日志异步化处理怎么理解"><a href="#日志异步化处理怎么理解" class="headerlink" title="日志异步化处理怎么理解"></a>日志异步化处理怎么理解</h2><pre><code class="hljs">1. 将日志异步化去记录. 通过log4j2 去做. 2. log4j2 更快的是通过 disruptor 做为核心技术队列, 通过无锁的方式处理线程的间的数据传递, 降低了上下文切换的开销    LMAX disruptor的原理:        通过使用ringBuffer 环形缓冲区来实现的</code></pre><h2 id="serverless-网关流量转发是怎么处理的-在什么情况下需要去对集群扩所容"><a href="#serverless-网关流量转发是怎么处理的-在什么情况下需要去对集群扩所容" class="headerlink" title="serverless 网关流量转发是怎么处理的. 在什么情况下需要去对集群扩所容"></a>serverless 网关流量转发是怎么处理的. 在什么情况下需要去对集群扩所容</h2><h2 id="api-文档平台怎么理解自动的-以及可以解决业务什么问题"><a href="#api-文档平台怎么理解自动的-以及可以解决业务什么问题" class="headerlink" title="api 文档平台怎么理解自动的, 以及可以解决业务什么问题"></a>api 文档平台怎么理解自动的, 以及可以解决业务什么问题</h2><h2 id="针对大的请求需要怎么处理"><a href="#针对大的请求需要怎么处理" class="headerlink" title="针对大的请求需要怎么处理?"></a>针对大的请求需要怎么处理?</h2><pre><code class="hljs">1. 会限制单个请求的大小, 每个请求的大小限制在64M, 同时针对大文件请求有专门的集群去处理。2. 返回数据的时候会开启gzip 压缩。 频繁压缩会吃CPU</code></pre><h2 id="针对耗时长的需要怎么处理"><a href="#针对耗时长的需要怎么处理" class="headerlink" title="针对耗时长的需要怎么处理"></a>针对耗时长的需要怎么处理</h2><pre><code class="hljs">1. 将耗时长的应用和核心交易应用的集群分开, 防止耗时长的应用占用过多的TCP 连接2. 由于做了全异步处理, 耗时长的应用只会占用过多的端口号3. 监控上去处理, 针对耗时长的是否合理, 对于不合理的请求直接限流4. 自身保护机制上和后端单台机器限制1000个TCP 连接, 整个应用限制在5000 个连接。</code></pre><h2 id="网关后端机器的CAP-是怎么考虑的-为什么要用zk"><a href="#网关后端机器的CAP-是怎么考虑的-为什么要用zk" class="headerlink" title="网关后端机器的CAP 是怎么考虑的, 为什么要用zk"></a>网关后端机器的CAP 是怎么考虑的, 为什么要用zk</h2><h2 id="网关给后端服务转发的时候负载均衡怎么考虑的"><a href="#网关给后端服务转发的时候负载均衡怎么考虑的" class="headerlink" title="网关给后端服务转发的时候负载均衡怎么考虑的"></a>网关给后端服务转发的时候负载均衡怎么考虑的</h2><pre><code class="hljs">1. 随机2. 加权随机</code></pre><h2 id="cat-的-transaction-是通过什么方式去进行传递的-遇到跨线程了怎么处理"><a href="#cat-的-transaction-是通过什么方式去进行传递的-遇到跨线程了怎么处理" class="headerlink" title="cat 的 transaction 是通过什么方式去进行传递的, 遇到跨线程了怎么处理"></a>cat 的 transaction 是通过什么方式去进行传递的, 遇到跨线程了怎么处理</h2><pre><code class="hljs">1. threadLocal2. 跨线程传递的话 可以直接传递整个对象.</code></pre><h3 id="threadLocal-的原理"><a href="#threadLocal-的原理" class="headerlink" title="threadLocal 的原理"></a>threadLocal 的原理</h3><pre><code class="hljs">每个线程维护一个叫threadLocals 的 ThreadLocalMap,每个线程维护自己的ThreadLocalMap, threadLocalMap 中其中key 是ThreadLocal 对象, value 是要保存的值, 因此是线程安全的多个threadLocal 通过ThreadLocal 对象的hash值 来定位到table 中的位置,ThreadLocal 实例被创建的对象持有, ThreadLocal 值也是被线程实例持有, 都是位于堆上的</code></pre><h5 id="threadLocal-为什么会导致内存泄漏"><a href="#threadLocal-为什么会导致内存泄漏" class="headerlink" title="threadLocal 为什么会导致内存泄漏"></a>threadLocal 为什么会导致内存泄漏</h5><pre><code class="hljs">由于ThreadLocal 保存的时候把自己当作key 防盗了ThreadLocalMap 中, 同时是弱引用的, 由于发生了GC的时候, 会被回收, 但是由于线程一直运行, value 是无法得到回收的,  在线程池中, 容易造成内存泄漏, 容易导致ThreadLocalMap 中的key 变为了null, 但是由于threadLocal线程还是一直在运行的, 这个value 一直得不到回收, 导致内存泄漏, 需要在最后使用的地方加上remove, 如果Entry 中的key 是强引用的, 容易导致key 也内存泄漏如果k v 都是弱引用的话, 会导致获取值的不确定性fastThreadLocal 通过InternaleThreadLocal 来避免了内存泄漏, 通过数组的索引可以直接访问数据, 线程退出的时候, 会自动进行清理与该线程相关的FastThreadLocal 信息</code></pre><h2 id="网关自身的灰度特性-灰度机器的配置下发"><a href="#网关自身的灰度特性-灰度机器的配置下发" class="headerlink" title="网关自身的灰度特性, 灰度机器的配置下发"></a>网关自身的灰度特性, 灰度机器的配置下发</h2><h2 id="单元化是怎么理解的"><a href="#单元化是怎么理解的" class="headerlink" title="单元化是怎么理解的"></a>单元化是怎么理解的</h2><pre><code class="hljs">指一个能完成所有业务操作的自包含集合，在这个集合中包含了所有业务所需的所有服务，以及分配给这个单元的数据. 请求需要根据用户的region 或者是uuid 去做sharding单元化:1. 数据按照用户的属性进行shard, 拆分, 到数据库后怎么处理    各个数据库做了数据同步, 拆分后的数据会落到对应的数据库上去, 2. 对于无法拆分的数据应该怎么做处理3. 不同单元之间需要进行数据同步,两边的唯一性索引 通常采用分布式ID生成器来做, 那对于已有的怎么处理的?对于已有的数据怎么处理? 假设已经有了1KW条数据, 存量数据通过什么方式同步??DDL 已有的怎么处理数据回环怎么处理    额外插入一张表来进行处理, 相当于在事物中增加了一条sql 语句        BEGIN;        #往目标库同步时，首先额外插入一条记录，表示这个事务中的数据都是A产生的。        insert into direction(idc,db_cluster) values(&quot;IDC1”,&quot;DB_A”)        #插入原来的记录信息        insert into users(name) values(&quot;tianshouzhi”);        COMMIT;    通过mysql 的binLog 同步的时候, 判断gtId 是否执行过, 来进行决定是否要执行同步, 因此可以主动设置next gtId 来做, set next gtId</code></pre><h3 id="配置中心如何去实现单元化"><a href="#配置中心如何去实现单元化" class="headerlink" title="配置中心如何去实现单元化"></a>配置中心如何去实现单元化</h3><pre><code class="hljs">1. 配置的单元化，客户端读取配置的时候带上机器所属的信息, 配置的时候读取不同环境下的值2. 客户端请求到对应的机房上去</code></pre><h3 id="公司整体的单元化是怎么看的"><a href="#公司整体的单元化是怎么看的" class="headerlink" title="公司整体的单元化是怎么看的"></a>公司整体的单元化是怎么看的</h3><pre><code class="hljs">1. 通过用户的uuId 去做sharding, 或者是按照地理位置信息 将用户请求到不同的机房上去, 通过网关入口开始流量分割, </code></pre><h2 id="数据的批量变更-数据预热处理为什么要这样去做-可以带来什么样的收益"><a href="#数据的批量变更-数据预热处理为什么要这样去做-可以带来什么样的收益" class="headerlink" title="数据的批量变更, 数据预热处理为什么要这样去做, 可以带来什么样的收益"></a>数据的批量变更, 数据预热处理为什么要这样去做, 可以带来什么样的收益</h2><pre><code class="hljs">1. 配置变更的整体耗时降低不下来. 由于数据库到达了瓶颈, 配置文件挨个去变更, 以及客户端收到配置变更后, 并发的读取, 导致缓存击穿, 向数据库查询配置文件信息, 导致压力变大2. 配置变更的过程本身就是批量变更的, 一些DB的配置文件, 通过restAPI 的方式, 一次性变更了100个, 但是处理保存到数据库的时候是挨个保存的, 并且是挨个通知的. 3. 将保存的数据库进行批量保存, 同时通知的话也改成批量通知, 降低DB的压力了4. 整体耗时从3分钟下降到1分钟左右。 </code></pre><h2 id="full-gc的排查思路"><a href="#full-gc的排查思路" class="headerlink" title="full gc的排查思路"></a>full gc的排查思路</h2><pre><code class="hljs">1. 使用jmap 去对内存进行dump2. 启动的时候增加gc 日志查看    2.1 如果是full GC 很频繁, 说明老年代空间不足, 或者是老年代内存被填满了, 有可能是对象过早的进入老年代,可以调整对象的晋升比例, 防止过早的进入老年代    2.2 如果是full GC 很长, 说明GC 无法及时的释放内存, 可以增加老年代的内存, 同时可以通过分析文件, 确定是否有内存泄漏    2.3 查看每次GC 后堆内的使用情况, 判断是否有内存持续增长无法回收, 3. 查看dump 下来的内存文件    3.1 通过MAT 查看 大对象、对象的引用链路、4. 如果是堆内存不足    4.1 尝试增加堆内存    4.2 针对频繁的full gc, 或者是yong gc 对内存占用分析, 调整比例    4.3 对频繁创建和销毁的对象可以通过polling, 减少不必要的重复创建    4.2 更换GC 算法</code></pre><h3 id="OOM-怎么去排查"><a href="#OOM-怎么去排查" class="headerlink" title="OOM 怎么去排查"></a>OOM 怎么去排查</h3><pre><code class="hljs">1. Java heap space：堆内存不足    1.1 增大内存空间    1.2 排查是否有内存泄漏    1.3 对象polling     1.4 减少大对象的使用2. GC overhead limit exceeded GC 频率过多, 但是回收了很少    2.1 增大内存空间    2.2 排查是否有内存泄漏    2.3 -xx MaxGCPauseMillis. G1 的话可以调整GC 预期事件3. Metaspace 元空间不足    3.1 排查内存泄漏, 例如反射是不是使用了很多??4. Direct buffer memory：直接内存不足    4.1 NIO 排查,  排查是否有内存泄漏5. Unable to create new native thread：无法创建新的线程，线程数超出系统资源限制    5.1 创建过多的线程了, 排查线程数的创建, 使用线程池</code></pre><h3 id="full-gc-频繁的时候应该怎么去排查"><a href="#full-gc-频繁的时候应该怎么去排查" class="headerlink" title="full gc 频繁的时候应该怎么去排查"></a>full gc 频繁的时候应该怎么去排查</h3><pre><code class="hljs">1. 打开GC 日志    1.1 如果每次full gc 后, 老年代的内存占用没啥变化, 说明老年代有大量无法回收的对象        1.1.1 dump 内存快照, 查看内存占用的情况        1.1.2 排查是否有内存泄漏        1.1.3 排查这些对象是否合理    1.2 查看晋升的情况        1.2.2 yong gc 后大量对象晋升到了老年代, 晋升频率是否过低, 导致很多应该在yong gc 回收的对象到了老年代来, 通过调整MaxTenuringThreshold, 避免过早晋升到老年代2. 排查堆内存占用情况    2.1 full GC 后老年代使用率都是100%3. 检查是否有大对象创建    3.1 在GC 日志中老年代内存快速上涨4. gc 算法</code></pre><h3 id="full-gc-耗时比较高怎么去排查"><a href="#full-gc-耗时比较高怎么去排查" class="headerlink" title="full gc 耗时比较高怎么去排查"></a>full gc 耗时比较高怎么去排查</h3><pre><code class="hljs">1. 打开GC 日志    1.1 如果每次full gc 后, 老年代的内存占用没啥变化, 说明老年代有大量无法回收的对象        1.1.1 dump 内存快照, 查看内存占用的情况        1.1.2 排查是否有内存泄漏        1.1.3 排查这些对象是否合理    1.2 查看晋升的情况        1.2.2 yong gc 后大量对象晋升到了老年代, 晋升频率是否过低, 导致很多应该在yong gc 回收的对象到了老年代来, 通过调整MaxTenuringThreshold, 避免过早晋升到老年代2. 排查堆内存占用情况    2.1 full GC 后老年代使用率都是100%    2.2 如果用的是CMS 的话, 排查是否有大量的内存碎片, 导致老年代空间不够连续3. 检查是否有大对象创建    3.1 在GC 日志中老年代内存快速上涨4. gc 算法</code></pre><h3 id="yong-gc-耗时比较高怎么排查"><a href="#yong-gc-耗时比较高怎么排查" class="headerlink" title="yong gc 耗时比较高怎么排查"></a>yong gc 耗时比较高怎么排查</h3><pre><code class="hljs">1. 打开GC日志2. eden 区是否设置过大, 导致扫描的对象过多2. 是否有临时对象在短期内大量创建, 这些对象是否会到老年代去, 这些对象是否可以池化处理3. GC 算法, 避免内存碎片</code></pre><h3 id="yong-gc-频繁怎么去排查处理"><a href="#yong-gc-频繁怎么去排查处理" class="headerlink" title="yong gc 频繁怎么去排查处理"></a>yong gc 频繁怎么去排查处理</h3><pre><code class="hljs">1. 打开GC日志2. eden 区是否设置过大, 导致扫描的对象过多2. 是否有临时对象在短期内大量创建, 这些对象是否会到老年代去, 这些对象是否可以池化处理3. GC 算法, 避免内存碎片</code></pre><h3 id="jvm-每个区域的作用"><a href="#jvm-每个区域的作用" class="headerlink" title="jvm 每个区域的作用"></a>jvm 每个区域的作用</h3><pre><code class="hljs">1. 堆2. 虚拟机栈3. 程序计数器4. 本地方法栈5. metaspace</code></pre><h3 id="GC-算法"><a href="#GC-算法" class="headerlink" title="GC 算法"></a>GC 算法</h3><pre><code class="hljs">1. CMS    1. 初始标记        从GCRoots 出发的直接可达性对象, 需要进行STW,     2. 并发标记        在初始标记的基础上, 标记处内存中所有的可达性对象, 此时没有进行STW, 用户线程和GC 线程同时在运行.    3. 重新标记        需要进行STW, 对并发标记遗漏的对象进行修正, 在并发标记起期间产生的不可达对象需要在下一次GC 周期才能被回收    4. 并发清除        清除所有未被标记的对象, 进行对象回收, GC 线程和 用户线程同时在运行    缺点:         1. 碎片化验证, 清除过程中不对内存进行压缩整理, 导致内存碎片话严重        1.1 影响: 碎片化严重, 可能会导致老年代无法分配达对象, 触发full GC        2. 浮动垃圾: 在并发标记期间产生的垃圾, 无法在当前GC周期被清除, 只能等到下一次GC        2.1 影响: GC 效果不如预期, 需要预留更多的内存空间        3. 某些情况下会退化成单线程回收        3.1 如果堆内存不足以支撑程序的内存分配, 进而出发一次Full GC        3.2 年轻代向老年代晋升, 如果老年代没有足够的空间去容纳这些对象的时候, 也会导致CMS 失败, 从而退化成单线程的Serial Old 收集器        3.3 空间碎片化, 由于CMS 回收产生的碎片化, 导致大对象无法找到连续的内存进行分配, 最终触发full GC2. G1    其中-XX:G1NewSizePercent  新生代比列默认时5%    使用标记-整理算法        1. 标记阶段            1. 初始标记            从GC Roots 出发, 标记直接可达的对象, 需要进行STW            2. 并发标记                从GCRoots 出发, 找出存活对象, 应用线程和GC线程是可以同时活动的,             3. 再标记                标记在并发标记时转移的对象        2. 清理阶段                清点出有存活的对象和没有存活的对象        3. 复制阶段            重新分配对象内存和复制成员变量, 转移的时候需要进行STW, 复制的耗时和存活对象的数量以及对象的复杂程度成正比                  **初始标记**            标记从GC Roots 出发的可达对象 需要进行STW        - **并发标记**            标记整个堆中的存活对象, 不会进行STW        - **最终标记**            完成并发标记, 并且处理在并发标记期间导致应用对象的变化, 需要进行STW        - **筛选回收**            确定进行回收, 并根据收集的数据区域进行回收        - **拷贝回收**            将存活的对象从回收区拷贝到新的区块, 方便进行回收            特点:                region 管理, 每个区域可能是Eden 区, 也可能是Survivor区, 也可能是old区                并发标记和整理, 支持并发标记, 降低了STW                 可预测的停顿时间                优先回收: 维护一个优先队列, 根据各个区域回收的价值(回收成本和收益) 决定哪些要优先回收            G1 怎么解决浮动垃圾:                将对分割成多个region, 更加灵活的去管理和回收内存, 降低浮动垃圾的影响                垃圾回收的时候, 可以进行并发标记和整理, 最大限度的降低程序的停顿3. ZGC    通过染色指针和读屏障技术解决了对象转移的问题, 从而降低了耗时    染色指针: 指针中存放了对象的一些信息, 例如对象是否被标记, 是否移动了, 相当于用空间换时间</code></pre><h2 id="yong-gc-怎么降低时间"><a href="#yong-gc-怎么降低时间" class="headerlink" title="yong gc 怎么降低时间"></a>yong gc 怎么降低时间</h2><pre><code class="hljs">1. 调整yong区的比列大小2. 调整G1 的MaxGCPauseMillis, 到MaxGCPauseMillis。3. 调整gc 方式</code></pre><h2 id="pmap-怎么关联到是malloc-导致rss-内存上涨"><a href="#pmap-怎么关联到是malloc-导致rss-内存上涨" class="headerlink" title="pmap 怎么关联到是malloc 导致rss 内存上涨"></a>pmap 怎么关联到是malloc 导致rss 内存上涨</h2><pre><code class="hljs">1. 发现RSS 上涨, NMT 参数打开, 检查内存占用的情况1. gdb --batch --pid 36563 --ex &#39;call malloc_trim()2. ptmalloc 中用户释放掉的内存, 为了下次快速使用, 会存到自己的空闲列表中, 因此导致了很多的64M 内存占用的问题ptmalloc 的分级分配和缓存机制来优化内存管理, 但是运行的时候进行了内存池化, 为什么是64M? 因为他在64位机器上每次申请的虚拟内存区块为64M</code></pre><h2 id="配置文件切换的时候-走IP-直连-为什么没有走VIP"><a href="#配置文件切换的时候-走IP-直连-为什么没有走VIP" class="headerlink" title="配置文件切换的时候, 走IP 直连, 为什么没有走VIP"></a>配置文件切换的时候, 走IP 直连, 为什么没有走VIP</h2><pre><code class="hljs">1. VIP 还会涉及到dns 缓存解析, 需要通过dns 解析缓存刷新的时候, 就是最终切换的时间, 相比较于客户端之连, 会慢一点, 主从直接通过IP连上去.2. 主从连接的账号密码的话, 用户不需要感知, 用户只需要知道这个对应的陪文件即可</code></pre><h3 id="堆外内存怎么排查"><a href="#堆外内存怎么排查" class="headerlink" title="堆外内存怎么排查"></a>堆外内存怎么排查</h3><pre><code class="hljs">1. 排查代码中哪里使用了堆外内存, 发生了内存泄漏2. dump 一下内存文件,通过MAT 查看哪些对象是堆 DirectByteBuffer 有引用关系的3. rss 内存查看4. NativeMemoryTracking 可用查看堆内外的信息    Java Heap 是堆内的    Thread:  线程是占用的内存空间, 可以通过Xss 配置    class: 加载的类和方法信息, 为metaspace 信息    GC: GC 占用的内存大小5. async-profiler    ./profiler.sh -e malloc,free -f malloc_free.svg &lt;PID&gt;    频繁的出现malloc 但是没有调用free 说明可能有泄漏</code></pre><h2 id="MGR-原理"><a href="#MGR-原理" class="headerlink" title="MGR 原理"></a>MGR 原理</h2><pre><code class="hljs">1. 基于 Paxos 分布式一致性协议和自动化故障恢复机制, 允许多个Mysql 服务器组成一个复制组, 实现高可用性和容错能力1.1 分布式协议基于 paxos 协议1.2 所有写操作都是需要经过所有组员的一致同意, 写操作先在主节点上提交, 主节点会通过 GTID (全局事物ID) 将事物广播给其他节点, 只有多数节点同意了, 事物才是被认为可执行的1.2.1 冲突检测机制, 确保全局唯一    基于writeSet 的冲突检测机制: 每个事物提交的时候, MGR 会生成一个write-set, 记录了该事物中所有的修改, 相当于对该事物的写操作生成了一个集合                    冲突检测: 当一个节点尝试提交事物的时候, 会将该事物的write-set 与组内其他节点已提交但未应用的事物write-set 进行比较, 判断是否有冲突发生</code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="1-FullGc消除-young-gc-从2秒到10ms-怎么做到的"><a href="#1-FullGc消除-young-gc-从2秒到10ms-怎么做到的" class="headerlink" title="1. FullGc消除, young gc 从2秒到10ms 怎么做到的"></a>1. FullGc消除, young gc 从2秒到10ms 怎么做到的</h2><p>背景: 每次演练后, 通过CAT 的老年代明显的上涨, 再过1-2周, 会导致应用发生OOM<br>1.1 FullGC 怎么消除<br>1.1.1 增加jvm 的OOM 文件dump, -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;${DUMP_LOG_DIR}<br>1.1.2 主动去dump 文件 jmap -dump:live,format&#x3D;b,file&#x3D;test.hprof pid<br>1.1.3 将dump 下来的文件导入到MAT上<br>1.1.4 查看堆上的内存占用<br>1.1.5 发现有个对象占用特别高, 但是该对象也是需要常驻内存的, 该内存具体使用的是哪些客户端正在监听该配置文件, 每次配置推送的时候需要通过该对内存找到有哪些客户端正在使用该配置文件,从而将最新的版本好内容推送给客户端。<br>具体流程如下:</p><ol><li>根据变更配置文件去找到对应的监听机器, 其中数据结构如下</li><li>行是ip, 列是ConfigMeta, value 是Cache&lt;Listener, Listener&gt;&gt;,<br>3.1 出发点是有哪些IP 用了这个配置文件, 因此key 是IP, value 是configMeta, 然后每个缓存用的是Listener<br>3.2 从机器出发, 机器的Ip 是固定,  当机器重启后, IP 出现了漂移, ip1在应用A 读取的配置是a,b,c 经过漂移后, ip1在应用B 下面读取的配置是e，f,g. 其中a,b,c 的数据不会被删除掉, 从而导致内存越用越多<br>3.3 更改数据结构, 将监听列表从table 换成了一个map, 换成从配置文件的角度出发, k 是configMeta, value 是cache<Listener>。 每个配置文件有哪些客户端正在使用,</li></ol><h2 id="2-如果解决yong-gc-比较耗时比较高的问题"><a href="#2-如果解决yong-gc-比较耗时比较高的问题" class="headerlink" title="2. 如果解决yong gc 比较耗时比较高的问题"></a>2. 如果解决yong gc 比较耗时比较高的问题</h2><p>2.1 其中yong 区的比例是5<br>2.1.1  设置 MaxGCPauseMillis 到300ms, 默认是200,改成了250ms, 发现整体耗时下降了一些<br>2.1.2 jdk1.8 默认的是新生代比列是5%, 调整G1NewSizePercent 的比列到30,<br>2.1.3 结果: 对上面设置了以后yong gc 时间还是在1秒左右<br>yong gc 的频率从原来的7几次降低到了3次, 然后此时yong gc 的频率下来了, 但是每次的时间从原来的 300 ms 变成了450ms左右<br>3. 其中总的耗时仍然为1分钟1.5 秒左右<br>4. 最后将g1 替换成了zgc<br>根据g1 的算法<br>G1 里面的yong gc采用标记-复制的算法<br>复制的时候用户线程和GC线程无法并行处理</p><ol><li><p>并发标记:在用户线程运行的同时, GC 线程 从root 对象出发, 标记会并发的标记存活对象, 这个过程是和用户同时进行的</p></li><li><p>初始标记:<br>2.1 初始标记: 从root 对象出发, 标记所有root 对象(需要STW), 时间比较短, 由于root 对象比较少<br>2.2 并发标记: 再从root 对象到可直接到达的对象 有哪些对象可达, 其中应用线程和GC线程可以同时去处理<br>2.3 再标记: 在并发2.2 中过程中发生变化的对象, 需要STW</p></li><li><p>确定回收集<br>进行最后的一次标记, 标记哪些对象需要回收, 需要STW</p></li><li><p>删选回收<br>采用复制算法, 会进行存活对象的移动<br>在次过程是需要STW的, 这个过程中为什么耗时比较高?????? 复制过程的耗时与对象的存活数量以及对象的复杂度成正比, 并且是没办法和用户线程去并行处理的，这个过程如果进行和用户线程进行并行处理, 会导致指针无法确认对象的问题<br>1.1 并发标记在初始标记之前的目的: 并发标记是用户线程和GC线程可以同时进行的, 但是在并发标记的时候可能会有新的对象被分配和标记, 因此在并发标记完成后, 再进行准确的初始标记, 用来获得准确的对象, 目的是可以准确的利用并发标记的优势, 将第GC 对程序的影响, 提高回收的准确率<br>G1 是将整个堆的空间分成多个大小的内存区域, 每个内存区域即可以是yong 区的一部分, 也有可能是old 区的一部分,其中我们指定的是4M<br>2.5 最终考虑升级到 zgc<br> zgc 相比较于g1 的gc 方式, 有了完全的提升<br>2.6 带来影响CPU 负载会有上升<br>GC 算法</p></li><li><p>不过 G1 为了解决 CMS 并发清理导致内存碎片化的问题，使用了复制算法转移对象，这样如果在转移过程中 GC 线程和用户线程并行，会导致指针无法准确定位对象的问题</p></li><li><p>zgc: 采用内存分区，使用染色指针和读屏障解决了复制算法并发转移对象导致的指针无法准确定位对象的问题<br>染色指针: 每个对象的指针在存储时都包含了附加的信息，用于表示对象的状态，比如是否是可达对象、是否需要被回收等<br>读屏障: 在 ZGC 中，读屏障用于捕获并记录正在被并发标记的对象引用，以便在后续的并发标记阶段中正确地标记这些对象。读屏障能够保证并发标记的准确性，防止对象在标记过程中被移动或修改引用关系导致的错误标记。</p></li></ol><p>原来是把GC 的标记放在了对象头上去, zgc 是将GC 的标记放在了指针中<br>M0,M1, Remapped<br>mmap 地址映射<br>读屏障<br>对象引用指针<br>  : 之前: GC 的标记信息放在对象头上去<br>  : 之后: GC 的标记信息直接放在引用指针上去<br>ZGC 过程:<br>  标记 -&gt; 转移<br>  完全做到了和用户进程的并发去处理<br>    并发标记: 使用读屏障的并发标记, 访问对象时插入特殊的屏障来跟踪对象的引用关系<br>    并发整理:<br>    并发引用重定位: 使用并发引用重定位去更新引用对象, 对象移动的时候, 可以正确更新对象的引用</p><p>  具体实现: 通过着色指针和读屏障技术<br>    读屏障技术: 解决对象发生转移, 对象地址未及时更新的情况, 读屏障在对象发生转移后, 会将读出来的指针更新到对象地址上去<br>      怎么判断是否发生移动, 通过着色指针<br>    空间换时间<br>      M0 , M1, Remapped</p><ol start="3"><li>升级了zgc, 大概每次过1 个月左右, 应用发生了OOM, 在内部的监控上面发现应用机器的RSS内存从12G 慢慢上涨到15G, 导致应用被操作系统kill了, 这个是在使用g1 的时候没有发生过的<br>3.1 如何解决zgc 导致应用发生了OOM<br>通过pmap 去查看堆外内存的占用<br>gdb –batch –pid 36563 –ex ‘call malloc_trim()’ 强行释放内存回收</li></ol>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>技术总结</title>
    <link href="/2024/08/17/interview/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    <url>/2024/08/17/interview/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="epool-介绍"><a href="#epool-介绍" class="headerlink" title="epool 介绍"></a>epool 介绍</h2><ol><li>select: 允许程序监听一组文件描述符, 检查这些文件描述符是否可读、可写、是否发生异常<br> 优点: 简单<br> 缺点: 单进程有监听上限, 每次调用的时候需要遍历fd_set, 即使大部分文件描述符没有事件发生, 但是仍然需要去进行扫描</li><li>pool: 使用动态数组来存储文件描述符及其感兴趣的事件, 而不是固定的大小fd_set<br> 优点: 可以解决select 中对于文件描述符上限的限制<br> 缺点: 每次调用的时候需要遍历文件描述符</li><li>epool: 基于事件的通知机制, 只会通知应用程序哪些文件描述符发生了变化, 而不是遍历所有的文件描述符<br> 过程:<br>     1. epool_create: 创建一个epool 实例<br>     2. epool_ctl: 使用epool_ctl 进行注册, 修改 或者删除要监控的文件描述符, 文件描述符及其感兴趣的事件会放到红黑树中去进行管理<br>         epool 使用红黑树的目的:<br>             高效的插入和删除, 对于频繁的注册和注销 操作复杂度为logn<br>             有序性:<br>             支持快速查找: 在支持大量的文件描述符时, 可以快速的查找,红黑树可以以logn 的时间去进行查找<br>             避免退化: 最坏情况下可以避免退化<br>     3. epool_wait: 等待事件发生, 当有事件发生的时候, epool 会将发生事件的文件描述符放入到一个链表中, 并通过epool_wait 返回<br> 两种工作模式:<br>     1. 水平触发: 默认模式, 只要文件描述符上有事件未处理, epool_wait 会持续返回<br>         特性: 只要文件描述符状态为可读或者可写, epool wait 每次调用都会返回该文件描述符, 意味着如果有数据可读, 会进行持续通知<br>         优点: 简单易用, 不容易丢失事件,适合处理高并发 和 不确定性高的场景, 尤其是应用程序可能未及时处理所有可读数据<br>     2. 边缘触发: 只在事件发生瞬间通知一次, 之后不会再次通知<br>         特性: 只有在状态发生变化的时候才进行通知, 例如从不可读变为可读, 要求应用程序尽快接受到事件后处理所有数据<br>         优点: 提高性能, 减少系统的调用次数, 适合处理大量并发连接的场景, 因为减少了不必要的通知<br> 事件复杂度为O(1)<br>     netty 中可以通过设置EpollChannelOption 来进行设置</li></ol><h2 id="进程间调度算法"><a href="#进程间调度算法" class="headerlink" title="进程间调度算法"></a>进程间调度算法</h2><pre><code class="hljs">1. 先来先服务    原理: 按照进程到达就绪队列的顺序分配CPU时间, 最早到的进程先运行    优点: 简单, 进程不需要设置优先级或者是复杂处理    缺点: 平均等待时间长, 不可抢占2. 短作业优先    原理: 优先调度运行时间最短的进程, 以减少系统的平均等待时间    优点: 在理想情况下, 可以最大化吞吐量,以最小化平均等待时间    缺点: 不可预测性, 无法提前知道进程运行的时间, 可能导致某个进程长时间无法得到运行3. 优先调度    为每个进程设置一个优先级, 优先级高的优先获得CPU的分配, 优先级可以调整    优点: 可以根据进程的优先级按照重要的进程先运行    缺点: 饥饿问题, 低优先级的可能永远无法运行4. 轮训    每个进程按照时间片的顺序进行执行, 每个进程执行一小段时间后就让出CPU, 如果时间片用完了, 进程放回到就绪队列的末尾    优点: 适用于时间共享的系统, 保证所有进程公平的得到CPU 时间    缺点: 时间片大小对系统的性能影响比较大5. 公平调度</code></pre><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><pre><code class="hljs">管道: 父子进程之间使用较为简单, 不适合跨多个无关的进程消息队列: 支持异步通信, 可以在不同进程之间传递数据共享内存: 但是需要同步机制避免多个进程之间访问产生的竞争条件信号: 信号是异步的, 可以用于进程的中断, 但是不可以传递大量数据socket: 适合在不同机器或者是跨网络的进程之间通信</code></pre><h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><pre><code class="hljs">共享变量wait / notify信号量锁</code></pre><h2 id="发送整个请求的流程"><a href="#发送整个请求的流程" class="headerlink" title="发送整个请求的流程"></a>发送整个请求的流程</h2><pre><code class="hljs">1. 客户端生成请求    1.1 用户对请求进行触发    1.2 DNS 解析, 将域名转换成服务器的IP 地址    1.3 生成HTTP 请求2. TCP 建立连接    2.1 三次握手    2.2 如果是HTTPS 的话, 客户端和服务端还需要进行TLS 握手, 协商加密算法, 交换密钥, 确保通信的安全3. HTTP 请求发送    3.1 请求发送, 客户端通过已建立的TCP 连接向服务端发送HTTP 请求, 包括请求的URL, 请求方法, HTTP 版本, 请求头, 请求体等信息    3.2 如果请求比较大, 会进行份块发送4. 服务端接受请求并进行处理    4.1 解析HTTP 请求, 服务端收到TCP 数据包后, 解析出HTTP 请求内容, 包括请求行, 请求头和请求体    4.2 路由和控制器处理    4.3 后端处理    4.4 生成HTTP 响应5. HTTP 响应发送    响应封装: 服务端将处理好后的数据打包生成HTTP 响应报文    数据发送: 响应报文可能被拆分为多个TCP 包, 通过网络发送到客户端6. 客户端接受响应    解析HTTP 响应: 客户端收到响应的数据并进行解析, 获取状态吗, 响应头和响应体    现实结果7. TCP 关闭连接如何优化:    减少DNS解析的时间    优化TCP 握手: 使用keepa-live 使用长连接    优化TLS: 使用http2    压缩和优化数据: gzip 压缩    使用缓存    负载均衡和CDN    优化数据库访问</code></pre><h2 id="stackoverflow-通常是怎么引起的"><a href="#stackoverflow-通常是怎么引起的" class="headerlink" title="stackoverflow 通常是怎么引起的"></a>stackoverflow 通常是怎么引起的</h2><pre><code class="hljs">1. 递归深度过深2. 虚拟机栈 -xss 设置太小了</code></pre><h2 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h2><ol><li>步骤:<br>1.1 哈希环构建: 将哈希空间看成一个环, 哈希值的范围是0 到 2^32 -1, 第一个哈希值和最后一个哈希值连成一个环<br>     每个节点: 通过哈希函数的到哈希值, 将这个节点映射到环上的一个点<br>     每个数据: 通过相同的哈希计算哈希值, 并将数据映射到环上<br>1.2 数据映射到节点: 数据存储的节点通过顺时针查找的方式确定, 顺时针找到的第一个节点就是存储该数据的节点<br>1.3 节点增加或删除的数据移动<br>     增加节点: 将新节点负载的哈希区间数据移动到该点<br>     删除节点: 将该节点负责的数据移动到下一个节点</li><li>防止数据分配不均匀<br> 虚拟节点: 增加虚拟节点, 让在哈希环上的分布变得均匀</li></ol><h1 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h1><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="TCP-粘包"><a href="#TCP-粘包" class="headerlink" title="TCP 粘包"></a>TCP 粘包</h3><p>TCP 面向连接的流式传输, 他将应用层的数据看成是一个连续的数据流, 不关心数据的边界, 因此在发送数据的时候, 可能将多个小的数据块合并成一个大的数据块, 从而导致发生了粘包</p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。<br>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。<br>进行三次握手：</p><ol><li>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 SYN_SEND 状态。<br>其中SYN&#x3D;1，初始序号seq&#x3D;x，SYN&#x3D;1的报文段不能携带数据，但要消耗掉一个序号。</li><li>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_RCVD 的状态。<br>在确认报文段中SYN&#x3D;1，ACK&#x3D;1，确认号ack&#x3D;x+1，初始序号seq&#x3D;y。</li><li>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。<br>确认报文段ACK&#x3D;1，确认号ack&#x3D;y+1，序号seq&#x3D;x+1（初始为seq&#x3D;x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。<br>发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并发回下一个SYN的另一端执行被动打开（passive open）。<br>在socket编程中，客户端执行connect()时，将触发三次握手。<br><img src="/../img/tcp/tcp_start_connection.png" alt="三次握手"></li></ol><h3 id="为什么需要三次握手"><a href="#为什么需要三次握手" class="headerlink" title="为什么需要三次握手"></a>为什么需要三次握手</h3><ol><li>可以阻止重复历史连接的初始化: 客户端先发送了一个SYN 报文, 然后客户端宕机了, 同时这个SYN 报文被网络阻塞了, 服务端没有收到, 接着客户端重启, 又向服务端发起了建立连接, 发送了SYN 报文. 三次握手可以进行阻止, 如果旧的报文先到, 那服务端响应的ACK的给客户端的时候, 客户端会响应一个RST, 如果是两次握手的话, 服务端在第一次握手后就进入了ESTABLISHED 状态, 但是服务端无法识别是否为历史连接, 此时服务端由于是established, 那可以进行数据的传输, 但是由于客户端是知道的, 再客户端响应RST 之前, 数据传输是浪费的</li><li>同步双方的初始化序列号</li><li>避免资源的浪费: 假设只有两次握手, 第一个发过去的包, 由于网络等原因, 滞后了,然后又重新发送了一个数据包给服务端,此时服务端收到了第二次发过来的数据包, 并进行了建立链接,进行了响应, 后面发送过去的第一个数据包也到了服务端,服务端进行了建立链接, 等到客户端数据传输,此时客户端由于没有数据需要传输会忽略这个请求, 而服务端一直等着数据的传输,造成资源的浪费。</li></ol><h3 id="三次握手中传输数据可以不"><a href="#三次握手中传输数据可以不" class="headerlink" title="三次握手中传输数据可以不"></a>三次握手中传输数据可以不</h3><p>  在第三位次握手的时候可以进行发送数据, 在第一次握手的时候是不行的, 防止被恶意攻击,如果第一次就可以进行数据传输的话, 攻击者可以发送大量的SYN 包, 其中携带了大量的数据,由于服务端收到数据后要对数据进行解析处理, 造成服务端资源的浪费</p><h3 id="三次握手的目的"><a href="#三次握手的目的" class="headerlink" title="三次握手的目的"></a>三次握手的目的</h3><p>  交换初始化序列号和确认号, 为后面的可靠性传输做保证, 阻止历史连接的初始化</p><h4 id="第二次握手的报文丢失了"><a href="#第二次握手的报文丢失了" class="headerlink" title="第二次握手的报文丢失了"></a>第二次握手的报文丢失了</h4><ol><li>客户端会重传SYN 报文</li><li>服务端会重传SYN+ACK 报文</li></ol><h4 id="第三次握手的报文丢失了"><a href="#第三次握手的报文丢失了" class="headerlink" title="第三次握手的报文丢失了"></a>第三次握手的报文丢失了</h4><ol><li>ACK 报文不会重传, 因此服务端会重发</li></ol><h4 id="半连接和全连接"><a href="#半连接和全连接" class="headerlink" title="半连接和全连接"></a>半连接和全连接</h4><pre><code class="hljs">半连接队列: SYN 队列    定义: 用来存储尚未完成三次握手的 TCP 连接的请求队列, 当服务端收到来自客户端的 SYN  包时, 会将该请求队列放到 SYN 队列中, 并响应一个 SYN-ACK    状态: 此时连接处于 SYNC_RECEIVE 状态, 表示服务端收到了连接的请求, 但是尚未完成连接的建立    容量: 当 SYN 队列满了后, 新的请求连接将会被拒绝或者丢弃, 可能导致客户端的连接超时或者重试全连接队列: ACCEPT 队列    定义: 用于存储完成三次握手的TCP 请求连接队列, 当服务端发送一个 SYN_ACK 后, 客户端会响应一个ACK 报文, 连接建立完成, 服务端将该连接放入到 ACCEPT 队列中    状态: 在此阶段, 连接处于 established 状态, 表示建立连接完成, 可以用来对数据进行传输    处理: 应用程序调用 accept 函数, 从accept 队列中获取一个可用的连接, 每次调用的accept, 都会将accept 队列中的一个连接转移到用户空间</code></pre><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。<br>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。<br>刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p><p>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。<br>即发出连接释放报文段（FIN&#x3D;1，序号seq&#x3D;u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。<br>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。<br>即服务端收到连接释放报文段后即发出确认报文段（ACK&#x3D;1，确认号ack&#x3D;u+1，序号seq&#x3D;v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。<br>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。<br>即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN&#x3D;1，ACK&#x3D;1，序号seq&#x3D;w，确认号ack&#x3D;u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。<br>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过2MSL(2个报文最大生存周期)以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。其中MSL 的默认值60 秒<br>即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK&#x3D;1，seq&#x3D;u+1，ack&#x3D;w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。<br>其中重传的超时事件和MSL 没关联<br>重传超时时间为1s + 2s + 4s + 8s 在120以内即可</p><p>收到一个FIN只意味着在这一方向上没有数据流动。客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。<br><img src="/../img/tcp/tcp_finish_connection.png" alt="四次挥手"></p><h3 id="假设中间有丢失的"><a href="#假设中间有丢失的" class="headerlink" title="假设中间有丢失的"></a>假设中间有丢失的</h3><ol><li>第一次挥手丢失<br> 客户端会进行重传, 如果重传到一定次数后, 会进入到closed 状态</li><li>第二次挥手丢失<br> 由于ACK 是不会进行重传的, 因此客户端会进行重传FIN</li><li>第三次挥手丢失<br> 服务端会进行重传, 到达最大次数后, 服务端会断开链接</li><li>第四次挥手丢失<br> 服务端会重发FIN,</li></ol><h3 id="为什么是四次挥手-三次可以不"><a href="#为什么是四次挥手-三次可以不" class="headerlink" title="为什么是四次挥手, 三次可以不"></a>为什么是四次挥手, 三次可以不</h3><p>  四次挥手是由于TCP 链接中, 发送方在结束他的发送后, 还能继续接受另外一端的数据, 在关闭连接的时候, 服务端收到了客户端发过来的FIN报文, 此时数据传输不一定完成了, 因此不可以直接对客户端响应一个ACK+FIN, 先对客户端进行响应一个ACK, 等需要发送的数据全都发完后, 再去发送一个FIN报文给发送方</p><h3 id="2MSL-作用是什么"><a href="#2MSL-作用是什么" class="headerlink" title="2MSL 作用是什么"></a>2MSL 作用是什么</h3><ol><li>保证客户端发送的最后一个ACK报文段能够到达服务端。<br>  假设客户端发送完ACK后不去等待直接进行关闭,如果客户端在发送完ACK后不等待直接进行关闭，那么在网络原因等情况下，最后一个ACK报文段可能会丢失，导致服务器无法收到客户端发送的FIN-ACK的确认报文，从而无法正常进入关闭连接状态。此时，服务器会超时重传FIN-ACK报文，而客户端却已经关闭了连接。此时，服务器会收到客户端发送的RST报文，导致连接异常关闭。另外，如果客户端在2MSL时间内重新发送了一个新的连接请求，而这个连接请求的端口与之前的连接相同，服务器可能会收到之前连接的滞留报文，从而导致混淆。因此，2MSL的等待时间可以避免这种混淆的发生，保证连接的正常关闭。</li><li>防止“已失效的连接请求报文段”出现在本连接中。<br>  客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</li></ol><h3 id="TIME-WAIT-过多的危害"><a href="#TIME-WAIT-过多的危害" class="headerlink" title="TIME_WAIT 过多的危害"></a>TIME_WAIT 过多的危害</h3><ol><li>占用系统的资源</li><li>占用端口多<br> 怎么优化:<br> net.ipv4.tcp_tw_reuse 和 tcp_timestamps: 可以复用TIME_WAIT 的socket 为新的连接, 会选择time_wait 超过1秒的连接给新的连接复用<br> 程序中使用 SO_LINGER 程序中跳过TIME_WAIT 返回RST关闭<br>到达上限的原因: 使用短链接, 长连接超时, 请求过多</li></ol><h3 id="TCP-保活机制"><a href="#TCP-保活机制" class="headerlink" title="TCP 保活机制"></a>TCP 保活机制</h3><p>发生宕机后, 服务端可以感知客户端的宕机事件<br>    1. 对端正常, 则等待下一个保活事件<br>    2. 对端重启, 对方相应一个RST, 说明连接被重置<br>    3. 对端死亡, 到达一定次数后, TCP 连接死亡</p><h3 id="四次挥手的目的"><a href="#四次挥手的目的" class="headerlink" title="四次挥手的目的:"></a>四次挥手的目的:</h3><p>通信双方可以正确的关闭并释放连接资源</p><h2 id="dubbo、http-各个版本协议对比"><a href="#dubbo、http-各个版本协议对比" class="headerlink" title="dubbo、http 各个版本协议对比"></a>dubbo、http 各个版本协议对比</h2><h3 id="dubbo-失败重试的策略"><a href="#dubbo-失败重试的策略" class="headerlink" title="dubbo 失败重试的策略"></a>dubbo 失败重试的策略</h3><p>失败重试的策略<br>    1.1 快速失败策略: 请求失败, 直接把异常跑出去<br>    1.2 失败安全策略:<br>    1.3 失败自动恢复策略: 后台记录失败请求, 通过定时任务对失败请求进行充实<br>    1.4 并行调用多个服务: 把消息广播给服务提供者集群, 只需要一个返回成功即可<br>    1.5 广播调用策略: 逐个调用服务提供者的集群, 只要集群中任何一个节点返回异常, 表示本次请求失败</p><h3 id="dubbo-核心组建"><a href="#dubbo-核心组建" class="headerlink" title="dubbo 核心组建"></a>dubbo 核心组建</h3><ol><li>服务的提供方</li><li>服务的消费者</li><li>注册中心</li></ol><h3 id="dubbo-请求过程"><a href="#dubbo-请求过程" class="headerlink" title="dubbo 请求过程"></a>dubbo 请求过程</h3><pre><code class="hljs">服务注册:    服务的提供方在启动的时候将请求接口、方法、版本协议等信息注册到注册中心上    服务的消费者从注册中心订阅所依赖服务的信息, 注册中心会返回服务提供者地址的列表服务发现    服务发现的过程, 服务的消费者会从注册中心拉取到服务提供者的列表并保存到本地缓存中, 当有新的服务的提供方或者老的服务提供方需要下线的时候, 注册中心会通知消费者, 消费者动态更新服务的提供者列表服务准备调用    proxy 生成: 服务的消费者使用动态代理机制, 生成服务接口的代理对象, 当消费者调用接口方法时, 实际上是调用这个接口对象的方法    Cluster &amp; LoadBalance网络通信准备    编码和序列化: 代理对象将方法调用, 参数信息封装成一个RPC请求, 通过编解码器对请求进行序列化和反序列化    Netty 通道管理: 使用Netty 作为底层通信框架, 消费者和提供方之间的通信依赖Netty 去进行传输数据发送请求    consumer: 消费者通过Netty 客户端将序列化后的RPC 请求发送到指定的服务提供方    provider: 提供方的Netty server 会去接收请求, 并将其传递给指定的服务处理线程池去进行处理请求处理    服务的提供方接收到请求并对接收到的数据进行反序列化, 恢复出原始请求对象    调用服务: 服务的提供方根据请求对象的服务名、方法名、通过反射的方式执行实际的业务逻辑    返回结果: 提供方将执行结果返回给响应对象, 并序列化后, 返回给发送方接收响应    consumer: 消费者的Netty 客户端接收到响应后, 并将其反序列化成对象    结果处理: 将拿到的结果反序列化成对象返回给上层调用者服务调用完成    上层的程序获得结果, 整个RPC 请求结束</code></pre><h3 id="grpc-和-dubbo-的对比"><a href="#grpc-和-dubbo-的对比" class="headerlink" title="grpc 和 dubbo 的对比"></a>grpc 和 dubbo 的对比</h3><pre><code class="hljs">grpc 直接基于http2.0 的, 默认使用 protobuf 来进行序列化和反序列化dubbo 可以使用 Hessian、Kryo、Java 序列化 等dubbo 反序列化    Protobuf：适合需要高效、跨语言通信和数据存储的场景，特别是在需要数据结构化的分布式系统和微服务架构中非常有用。    Kryo：专注于Java生态系统，提供高效的二进制序列化，适用于高性能计算和需要优化网络传输的应用。    FastJson：适合Web开发，特别是需要与前端进行数据交换的场景，尽管在性能上不如二进制序列化框架，但其易用性和广泛的语言支持使其非常流行。    Hessian2：用于分布式系统中的跨语言通信，适合需要轻量级二进制传输协议的场景，但在Java内部应用中，Kryo可能会有更好的性能表现。   </code></pre><h3 id="http1-1-2-0-QUIC-协议对比"><a href="#http1-1-2-0-QUIC-协议对比" class="headerlink" title="http1.1 2.0 QUIC 协议对比"></a>http1.1 2.0 QUIC 协议对比</h3><pre><code class="hljs">HTTP 1.X 存在的问题      单向请求: 只能单向请求, 不可以服务端主动给客户端发送响应    协议开销大: header里携带的内容过大，且不能压缩，增加了传输的成本。    队头阻塞: 下个请求必须要等待前面请求返回后, 才可以发出。导致带宽无法被利用HTTP2.0 怎么针对上述问题解决的    多路复用:  通过使用二进制帧来对数据进行传输, 不再是Http 1.x 的纯文本协议, 所有的请求都被分割成了更小的数据帧, 这些帧可以在网络中按照任意顺序发送, 接收方再根据帧的标识符进行重组, 提高了带宽的利用率    消除对头阻塞: 通过多路复用来允许多个请求和响应再同一个TCP 连接上进行传输, 从而消除了对头阻塞问题    减少了延迟: 多路复用可以使得数据流并行传输, 每个数据流有唯一的标示, 并且可以是无序的, 降低了延迟    减少连接开销: 可以共用链接http1.1 升级到2.0    服务端和客户端需要升级改动    其中https 加密不是必须的HTTP2.0的问题    TCP 层面的队头堵塞问题:         TCP的顺序性:  发送方的某个数据包在传输过程中丢失了, 接收段需要等待重传的丢失包才可以处理后续的数据包, 导致了TCP 的队头堵塞        TCP 传输时某个数据流的数据包丢失了, 会导致后续的数据流堵塞, 因为TCP 需要等待丢失的数据包和重传    对比Http1.x 的话: 使得TCP的队头堵塞影响整个链接上的请求和响应, HTTP1.x 的话只影响对应链接的请求和响应可以通过QUIC 和 http3.0 去进行解决    基于UDP 去实现的    QUIC 实现了TCP + HTTPS + HTTP/2的功能，目的是保证可靠性的同时降低网络延迟    安全性:         1. 对于首次建立链接的: 需要交换密钥 消耗一次RTT, 再发送业务数据        2. 对于非首次的, 通过diff-Hellman 来进行密钥交换,     链接的唯一性基于64位的connection id    如何解决队头堵塞问题:        1. 基于UDP        2. 数据包级别的确认, 如何确定数据包是否一致 : 通过Stream ID 来标识当前数据流属于哪个资源请求, 同时增加stream offset 确认在数据流中的位置, 两个确定数据包重传 </code></pre><h3 id="HTTPS-的过程"><a href="#HTTPS-的过程" class="headerlink" title="HTTPS 的过程"></a>HTTPS 的过程</h3><pre><code class="hljs">1. 客户端发起请求2. 服务器收到请求后, 向客户端发送数字证书(SSL/TLS 证书), 证书包含服务器的公钥和CA 签名的信息3. 客户端验证证书3.1 客户端检验证书、查看证书的有效期、证书链接、证书的域名是否和服务器匹配       防止中间人攻击3.2 如果证书不可信, 客户端会警告用户并提示4. 客户端使用生成会话密钥, 信息通过公钥进行加密, 服务器使用私钥进行解密。        确保只有对应私钥的才可以进行揭秘5. 客户端和服务端双方拥有会话密钥后, 通过会话密钥进行对数据传输6. 数据传输</code></pre><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><h3 id="char-和-varchar的区别"><a href="#char-和-varchar的区别" class="headerlink" title="char 和 varchar的区别"></a>char 和 varchar的区别</h3><pre><code class="hljs">char: 固定长度的字符类型, 定义时需要指定字符长度, 不够的时候会在末尾补足空格, 适合存储固定长度的varchar:可变长度的字符串类型, 存储时需要指定最大长度,存储的时候根据实际长度占用存储空间</code></pre><h3 id="in-和-exist-的区别"><a href="#in-和-exist-的区别" class="headerlink" title="in 和 exist 的区别"></a>in 和 exist 的区别</h3><pre><code class="hljs">in 表示左边表达式是否存在于右边, 返回true or falseexist 可以返回一行数据性能上的差异:    exists 的性能要比in 好, 尤其是在表比较大的情况下, 因为exist 找到一条后就立刻返回停止查询, in 需要遍历整个子查询使用场景:    查询子集合较小并且变动属于低频的, in 更加直观,  当子查询涉及到外部查询的每一行判断的时候,  并且子查询效率较高, exist 更为合适null 值的处理:    in 可以正确处理子查询中包含null 的情况, 而exist 不受子查询结果中null  值的影响</code></pre><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h4><ol><li>逻辑功能分类:<br>1.1 普通索引:没有任何约束条件, 用户提高查询的效率<br>1.2 唯一索引: 在普通索引的基础上增加了唯一性约束的条件, 一张表里面可以有多个唯一索引<br>1.3 主键索引: 在唯一索引的基础上增加了不为空的约束条件, 一张表里面最多有一个主键索引</li><li>物理实现分类<br>2.1 聚集索引: 基于表的主键列的索引, 索引的叶子节点存储了实际的数据行, 一张表只能有一个聚集索引, 通常为主键索引<br>2.2 非聚集索引: 叶子节点存储了索引的值和一个指向数据实际存储位置的指针, 一个表可以有多个非聚集索引</li><li>字段个数<br>3.1 单一索引: 索引列为一个的索引<br>3.2 联合索引: 多个列组合在一起的索引</li></ol><h4 id="什么时候需要创建索引"><a href="#什么时候需要创建索引" class="headerlink" title="什么时候需要创建索引:"></a>什么时候需要创建索引:</h4><ol><li>字段的数值有唯一性的限制，比如用户名</li><li>频繁作为 WHERE 查询条件的字段</li><li>需要经常 GROUP BY 和 ORDER BY 的列</li><li>UPDATE、DELETE 的 WHERE 条件列</li></ol><h4 id="无需创建索引"><a href="#无需创建索引" class="headerlink" title="无需创建索引:"></a>无需创建索引:</h4><ol><li>如果表记录太少</li><li>where 条件中用不到的列</li><li>字段中如果有大量重复数据，也不用创建索引，比如性别字段</li></ol><h4 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h4><ol><li>如果索引进行了表达式计算、使用函数</li><li>在 WHERE 子句中，如果在 OR 前的条件列进行了索引，而在 OR 后的条件列没有进行索引</li><li>当我们使用 LIKE 进行模糊查询的时候，前面不能是 %</li><li>我们在使用联合索引的时候要注意最左原则</li></ol><h4 id="最左前缀匹配"><a href="#最左前缀匹配" class="headerlink" title="最左前缀匹配"></a>最左前缀匹配</h4><p>索引的最左前缀原则，可以是联合索引的最左N个字段。比如你建立一个组合索引（a,b,c），其实可以相当于建了（a），（a,b）,(a,b,c)三个索引，大大提高了索引复用能力。</p><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>传统查询过程: MySQL 服务器先从存储引擎层获取满足条件的所有数据, 然后再根据条件在MySQL服务层去进行过滤, 这可能导致存储引擎层返回大量的不必要的数据到MySQL 的服务层, 增加了网络传输和数据的处理<br>索引下推通过将查询条件推送至存储引擎层进行过滤，可以在存储引擎层尽可能地提前过滤掉不符合条件的数据，从而减少从存储引擎返回到MySQL服务器层的数据量</p><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>适用于某些查询条件在索引上进行处理的情况</p><h3 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a>索引数据结构</h3><h4 id="hash表"><a href="#hash表" class="headerlink" title="hash表"></a>hash表</h4><p>不支持范围查询</p><h4 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h4><p>当数据量增多的情况下, 索引层数也会变高</p><h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><h5 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h5><p>在极端情况下，如果每次插入的数据都是最小或者都是最大的元素，那么树结构会退化成一条链表。查询数据是的时间复杂度就会是O(n)</p><h5 id="平衡二叉查找树（AVL树"><a href="#平衡二叉查找树（AVL树" class="headerlink" title="平衡二叉查找树（AVL树"></a>平衡二叉查找树（AVL树</h5><p>让每个节点的左右子树高度差不能超过 1。： 随着数据量的变多, 导致树的高度变高, 意味着磁盘的IO变化, 影响整体的查询销量</p><h5 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h5><p>叶子节点没有形成链表, 范围查询的时候需要多次随机IO, 性能较低</p><h5 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h5><p>B+树中的非叶子节点都不存储数据，而是只作为索引。由叶子节点存放整棵树的所有数据。而叶子节点之间构成一个从小到大有序的链表互相指向相邻的叶子节点，也就是叶子节点之间形成了有序的双向链表</p><h5 id="B树和-B-树对比"><a href="#B树和-B-树对比" class="headerlink" title="B树和 B+树对比"></a>B树和 B+树对比</h5><ol><li>更好的磁盘IO性能：B+树相较于B树，更适合在磁盘上进行存储和访问。B+树的内部节点（非叶子节点）只包含索引键值，而不存储实际数据，使得每个节点可以容纳更多的索引项。这意味着在同样的索引大小下，B+树的高度更低，减少了磁盘IO的次数，提高了数据访问的效率。</li><li>有序性和范围查询：B+树的叶子节点使用链表连接，使得B+树的叶子节点在磁盘上是有序的。这使得B+树在范围查询时更加高效，因为可以利用顺序访问特性，避免随机磁盘IO。而B树的叶子节点并没有进行链表连接，导致范围查询需要进行多次随机IO，性能较低。</li><li>更适合顺序访问：由于B+树的叶子节点形成了一个有序链表，对于顺序访问（如范围扫描、顺序遍历）的查询操作更加高效。相比之下，B树需要在内部节点和叶子节点之间进行来回跳跃，不利于顺序访问。</li><li>更适合大规模数据存储：B+树适用于大规模数据存储，因为它具有更高的数据密度和更好的IO性能。B+树的内部节点只存储索引键值，相较于B树，可以容纳更多的索引项，减少了树的高度，降低了存储开销。</li></ol><h4 id="使用B-树的原因"><a href="#使用B-树的原因" class="headerlink" title="使用B+树的原因"></a>使用B+树的原因</h4><ol><li>高效的查找性能：B+树是一种高效的平衡树结构，具有非常高效的查找性能。它的平均查找时间复杂度为O(logN)，能够快速地定位到目标数据的位置</li><li>高效的范围查询：B+树是一种有序树结构，能够非常高效地支持范围查询操作。它可以快速地找到满足条件的起始位置和结束位置，从而快速地定位到需要查询的数据。</li><li>内存友好：B+树的内部节点只存储索引信息，而不存储具体的数据，因此它的内存占用比较小。此外，B+树的叶子节点是顺序存储的，能够利用操作系统的预读特性，从而更加高效地利用内存。</li><li>支持高效的插入和删除：B+树的平衡特性使得它支持高效的插入和删除操作。对于插入操作，B+树只需要在叶子节点上插入新的数据即可。对于删除操作，B+树只需要删除叶子节点上的数据即可。</li></ol><h3 id="数据库回表"><a href="#数据库回表" class="headerlink" title="数据库回表"></a>数据库回表</h3><h4 id="回表定义-如果返回的列不在索引列中-就需要到主键索引或者数据页当中读取对应的数据行"><a href="#回表定义-如果返回的列不在索引列中-就需要到主键索引或者数据页当中读取对应的数据行" class="headerlink" title="回表定义: 如果返回的列不在索引列中,就需要到主键索引或者数据页当中读取对应的数据行"></a>回表定义: 如果返回的列不在索引列中,就需要到主键索引或者数据页当中读取对应的数据行</h4><p>回表会增加I&#x2F;O 开销和数据库的负载, 对数据库性能有负面影响</p><h4 id="如何降低回表"><a href="#如何降低回表" class="headerlink" title="如何降低回表"></a>如何降低回表</h4><ol><li>使用覆盖索引: 指的是索引查询返回了所有的列, 不需要回表既可以返回查询结果, 从而避免回表操作, 提高性能</li><li>合理设计索引: 查询所需的列尽可能包含在索引中, 从而减少回表的次数; 但是索引本身也是需要消耗存储空间和进行维护</li><li>使用查询缓存: 查询缓存指的是查询结果被写入磁盘前, 将查询结果缓存到内存当中, 下一次查询直接从内存当中去进行获取,避免回表的操作</li><li>优化查询语句: 尽可能将查询条件放在索引列上, 从而减少回表的次数</li></ol><h4 id="Mysql索引底层数据结构-为什么用B-树"><a href="#Mysql索引底层数据结构-为什么用B-树" class="headerlink" title="Mysql索引底层数据结构, 为什么用B+树"></a>Mysql索引底层数据结构, 为什么用B+树</h4><pre><code class="hljs">B+树支持高效的搜索、稳定的搜索效率,支持范围查找、内存占用比较低        ## 索引各个场景        有5个字段 a,b,c,d,e,f,g,h         (a,b,c) 是一个联合索引, (d,e)是一个联合索引        1. 创建联合索引(a,b,c)        符合最左匹配原则 走索引        explain select * from not_dice.testPerson where a = &quot;1&quot;;                                       索引        explain select * from not_dice.testPerson where b = &quot;1&quot;;        全表        explain select * from not_dice.testPerson where c = &quot;1&quot;;        全表        explain select * from not_dice.testPerson where a = &quot;1&quot; and b = &quot;1&quot;;        索引        explain select * from not_dice.testPerson where b = &quot;1&quot; and a = &quot;1&quot;;        索引        explain select * from not_dice.testPerson where a = &quot;1&quot; and c = &quot;1&quot;;        索引下推        explain select * from not_dice.testPerson where c = &quot;1&quot; and a = &quot;1&quot;;        索引        explain SELECT * FROM not_dice.testPerson where  c  = &quot;1&quot; and b = &quot;1&quot;;        进行全表扫描了        explain select * from not_dice.testPerson where a = &quot;1&quot; and b = &quot;1&quot; and c = &quot;1&quot;;        索引        explain select * from not_dice.testPerson where b = &quot;1&quot; and a = &quot;1&quot; and c = &quot;1&quot;;        索引        explain select * from not_dice.testPerson where c = &quot;1&quot; and b = &quot;1&quot; and a = &quot;1&quot;;        索引        explain select * from not_dice.testPerson where a = &quot;1&quot; and c = &quot;1&quot; and b = &quot;1&quot;;        索引        explain select * from not_dice.testPerson where a = &quot;1&quot; and c = &quot;1&quot; and b = &quot;1&quot; and d = &quot;1&quot;;        索引        explain select * from not_dice.testPerson where c = &quot;1&quot; and b = &quot;1&quot; and d = &quot;1&quot;;        走d_f的索引        explain select * from not_dice.testPerson where c = &quot;1&quot; and b = &quot;1&quot; and f = &quot;1&quot;;        全表</code></pre><h3 id="索引下推应用范围"><a href="#索引下推应用范围" class="headerlink" title="索引下推应用范围"></a>索引下推应用范围</h3><pre><code class="hljs">1. 适用于执行计划是range, ref, eq_ref等2. 对于Innodb 表, 非聚集索引, 索引下推可以减少全行读取次数, 从而减少IO3. 子查询不能使用索引下推4. 存储过程不能使用索引下推</code></pre><h3 id="索引下推使用场景"><a href="#索引下推使用场景" class="headerlink" title="索引下推使用场景"></a>索引下推使用场景</h3><pre><code class="hljs">1. 联合索引2. 部分索引列的过滤</code></pre><h4 id="explain-中各个参数的作用"><a href="#explain-中各个参数的作用" class="headerlink" title="explain 中各个参数的作用"></a>explain 中各个参数的作用</h4><pre><code class="hljs">type: 连接类型从高效到低效依次为 system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALLkey: 查询使用到的索引, 如果为null 则说明没有用到索引rows: 扫描需要的行数, 越大 说明执行时间越长filtered: where 条件过滤的百分比, 百分比越小 性能越高possible_keys: 可能的索引key: 索引Extra: 查询的额外信息</code></pre><h4 id="慢sql"><a href="#慢sql" class="headerlink" title="慢sql"></a>慢sql</h4><pre><code class="hljs">慢sql 怎么定位  怎么优化sql     查看数据库的慢sql日志    explain 去进行查询优化sql:    1. 优化数据库 和 数据表        如果单表数据量超过了千万, 考虑将大表拆分成小表        引入redis 等缓存    2. 查询优化, 每次查询的时候只需要返回需要的列, 或者是进行分页优化    3. 使用 explain 查看执行计划    4. 使用索引    5. select 的时候只选择需要的列    6. 优化where 条件, 如避免使用子函数    7. 优化join、group by 和 order by        join 的时候确保on 条件上有索引, 减少表的连接        order by 和 group by 上有索引        order by 和 group by 先用where 条件对数据去进行过滤, 减少数据集的大小</code></pre><h3 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h3><h4 id="事物的四大特性"><a href="#事物的四大特性" class="headerlink" title="事物的四大特性"></a>事物的四大特性</h4><pre><code class="hljs">A 原子性: 事物时最小的执行单位, 不允许分割, 事物的原子性动作要么都执行成功, 要么都执行失败    通过undo log 来保证 回滚日志   C 一致性: 事物之行前后, 数据保持一致    持久性+原子性+隔离性I 隔离性: 并发访问数据库, 一个事物的执行不被其他事物所干扰    通过 MVCC（多版本并发控制） 或锁机制D 持久性: 一个事物提交以后, 他对数据库中的数据改变是持久的    redo log （重做日志）可以实现事物的持久性</code></pre><h5 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h5><pre><code class="hljs">redo log: 事物的持久性undo log: 实现了事物的原子性, 用于事物的回滚bin log: server 生成的日志, 用于数据备份和主从复制relay log 用于主从的数据同步undolog 记录旧版本数据, redolog 记录新数据, 事物提交时, redo log会先标记事物为prepare状态, 再写入binlog, 最后将事物标记为commit 再进行提交</code></pre><h4 id="redo-log-和-bin-log"><a href="#redo-log-和-bin-log" class="headerlink" title="redo log 和 bin log"></a>redo log 和 bin log</h4><pre><code class="hljs">redo log 中WAL 技术(先写日志, 再去更新内存, 最后更新磁盘的技术)1. 为什么redo log 写数据而不是buffer pool 或者binlog 数据库做持久化, 要快, 损失性能要小1.1 buffer pool 落数据是随机的, 每次修改数据的位置是随机的, redo log 是属于追加的, 是顺序IO1.2 刷脏是需要等待数据收集到一定的数据量后, 例如默认是16KB, redo log 中只包含小量数据, 无效IO比较少binlog 数据库的逻辑日志需要通过redo log 来进行crash safe 的功能两阶段提交:    redo log 的prepare 和 commit 阶段    保证redo log 和 bin log 的数据一致性bin log 日志格式1. row: 数据量大而全: 记录了每一行数据的变化, 变化之前是是什么样子的, 变化之后是什么样子2. statement: 选择默认的语句模式:记录了每一句的sql, 对于非确定性的now()、复杂的sql 语句不进行记录.3. mixedbin log 和redo log 区别:1. 存储内容上    1. bin log 修改的数据逻辑变化    2. redo log 修改的是物理变化2. 功能上    1. redo log 是为了做持久化。        redo log     2. bin log 是为了做复制和数据恢复需要bin log 和 redo log 数据一致才可以保证事物的成功</code></pre><h4 id="buffer-pool-和-redis-对比"><a href="#buffer-pool-和-redis-对比" class="headerlink" title="buffer pool 和 redis 对比"></a>buffer pool 和 redis 对比</h4><pre><code class="hljs">1. buffer Pool 通常为16KB, 意味着查询一行数据, 也是需要加载整页, redis 是基于健值的存储, 颗粒度更细. 他的目的是为了优化磁盘的IO</code></pre><h4 id="relay-log"><a href="#relay-log" class="headerlink" title="relay log"></a>relay log</h4><pre><code class="hljs">relay log: 用于slave 进行数据同步的undo log: 回滚和多版本mvcc事物commit 后清除undo log 信息mvcc 读的时候只需要返回前面一个版本的数据即可</code></pre><h4 id="mvcc-原理"><a href="#mvcc-原理" class="headerlink" title="mvcc 原理"></a>mvcc 原理</h4><pre><code class="hljs">mvcc 原理隐藏列:trx_id通过readView 去解决读已提交和可重复读两个隔离级别中的问题    readView 包含内容:        1. m_ids: 在生成read view 时当前系统中活跃的读写事物的事物id 列表        2. min_trx_id:  生成read view 时当前系统中活跃读写事物中最小的事物id        3. max_trx_id: 生成read view 时系统中应该分配给下一个事物的id        4. create_trx_id: 生成该readView 的事物id    如何判断该版本是否可见        1. 对比需要访问trx_id 和create_trx_id, 如果是一样的, 说明是在访问自己修改过的事物, 则该版本可见        2. 如果访问的trx_id 小于 min_trx_id, 说明访问的版本是在当前事物生成之前提交的, 可以被访问        3. 如果访问的trx_id 大于 max_trx_id, 说明访问的版本是在当前事物后开启的, 则不可以被访问        4. 如果访问的trx_id 在 min_trx_id 和 max_trx_id 之间的, 则需要判断trx_id 是否属于 m_ids , 如果属于的话说明还是活跃的, 不可以被访问, 否则可以访问    读已提交和 可重复读就是在生成read view 的时间点不一样        读已提交每次执行的时候都会会生成一个read view        可重复度是在事物的第一次查询的时候创建一个, 并在整个事物期间不变    MVCC 多版本体现        1. 每行数据有多个版本, 每个版本关联一个事物ID,            1.1 当某事物读取一行数据的时候, 会读取一个快照, 快照是这行数据最开始的版本, 即使是这行数据在此期间被修改过, 当前事物看到的也是最初的版本            1.2 某个事物修改一行数据的时候, 不会直接去修改数据, 而是创建这行数据的新版本, 旧版本仍然保留        2. 版本直接和事物隔离级别挂钩            2.1 读已提交: 在每次执行的时候读取数据的read view            2.2 可重复读: 在同一个事物内, 读取的是同一个read view        3. 版本回收机制            3.1 当没有任何一个事物会依赖这个旧版本的数据, 可以进行清理            3.2 数据库删除旧版本时, 不会影响正在运行的事物        4. MVCC 和 undo log 关系                4.1 undo log 作用                    4.1.1 数据的版本管理, 由于在MVCC 中 读事物是读取某一行数据的历史版本, 这些版本就是存放在undo log中                    4.1.2 快照隔离: 每个事物在读取数据的时候, 会获取事物的read view, 其他事物进行了修改, 还是可以通过undo log获取到旧版本的数据                    4.1.3 并发控制: 在高并发下可以读取旧版本数据                4.2 MVCC 和 undolog 关系                    MVCC 的多版本记录是通过undo log 来实现的, 事物每次对数据的修改, 都是生成一条undo log 记录</code></pre><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><pre><code class="hljs">mysql 并行复制writesetGTID: 全局事物id主从复制的时候发生了延迟    1. 硬件层面怎么处理        1.1 网络带宽是不是被打满了        1.2 CPU load        1.3 磁盘层面是不是可以升级    2. 软件        2.1 IO线程        2.2 SQL 线程    3. 监控 告警部分写失效了怎么处理    场景: 发起一个update 的过程, 更改的数据落了redo log, 在需要刷盘的时候, 写了4K数据, 写了一部分数据, 但是没有写完, 不完整的数据页无法通过redo log 恢复    解决办法: 通过double write 的方式: 给这个page 做一个备份, 重启的时候先恢复对应的页, 再去恢复数据    将数据同步到double writer buffer 上去, 如果double write buffer 不完整则直接丢弃</code></pre><h4 id="update-x-set-a-x3D-1-where-b-x3D-2"><a href="#update-x-set-a-x3D-1-where-b-x3D-2" class="headerlink" title="update x set a &#x3D; 1 where b &#x3D; 2;"></a>update x set a &#x3D; 1 where b &#x3D; 2;</h4><pre><code class="hljs">1. 客户端发起操作2. 将b 为2 的这一行的数据中的a 列的值改为13. 将修改数据更新到内存中4. 记录a 在数据页x 的地方进行了y 操作, 并将记录设置为prepare的状态5. 修改好redo log 后, 可以对事物进行提交6. 写入bin log7. commit 提交事物8. 将redo log 这个事物相关的状态设置为commit</code></pre><h4 id="sql-执行过程"><a href="#sql-执行过程" class="headerlink" title="sql 执行过程"></a>sql 执行过程</h4><pre><code class="hljs">1. 客户端发送请求    客户端通过网络连接向数据库发送一条sql 语句, 2. 连接管理    连接处理: 数据库服务器收到客户端的请求后, 检查是否有可用的连接池, 如果有的话 则用现有的处理连接, 没有的话创建一个新的连接    权限验证: 服务器会去验证客户端的身份, 检查客户端是否有执行这条sql 命令的权限, 如果校验失败, 则返回错误3. SQL 解析    词法分析    语法分析    语义检查4. 查询优化    生成查询计划: 数据库会根据语法树生成多个可能的查询计划, 查询计划是SQL 执行的方案, 描述了如何访问和处理    选择最优计划: 数据库会根据执行的代价选择一个最优的方案, 代价评估包含有IO成本, CPU 资源消耗 内存使用等5. 查询计划    执行计划: 根据选定的查询计划, 逐步执行sql 语句    中间结果处理: 执行过程中, 可能会有一些中间结果, 中间结果会在最终结果生成前被处理6. 返回结果    结果集生成: 将最终的结果集返回给客户端, 可能是查询的结果, 可能是更新的影响数等等    资源释放: 清理执行过程中使用的临时资源, 并对资源进行释放7. 事物处理    如果SQL 是在事物中执行的, 数据库还需要执行事物的提交或回滚8. 日志记录</code></pre><h4 id="索引的开销"><a href="#索引的开销" class="headerlink" title="索引的开销"></a>索引的开销</h4><pre><code class="hljs">1. 空间上的开销: 建立索引需要创建一颗B+树, 每棵B+树都是一个数据页, 一个页会默认占用16KB的空间2. 时间上的开销: 每次数据的增加、删除、修改, 需要对索引进行维护修改</code></pre><h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><pre><code class="hljs">对数据表中的行记录进行加锁, 比如事物A更新了一行, 事物B也要更新一行数据, 则必须要等事物A操作完成后才可以去进行更新间隙锁可以用来解决幻读:    幻读的原因: 行锁只能锁住行, 但是新插入记录这个动作, 是要更新的记录之间的 间隙 , 因此通过间隙锁去解决幻读这个问题间隙锁, 导致锁的影响范围变大    对update 的语句进行范围上锁行锁命令分析show status like &#39;innodb_row_lock%&#39;; </code></pre><h4 id="存储引擎为什么默认选择innodb"><a href="#存储引擎为什么默认选择innodb" class="headerlink" title="存储引擎为什么默认选择innodb"></a>存储引擎为什么默认选择innodb</h4><pre><code class="hljs">1. 支持事物2. innodb 是聚集索引, MyISAM 是非聚集索引3. 锁力度: innodb 最小是行锁，myIsam 是表锁</code></pre><h4 id="一条事物update-的时候各个日志在什么时候会用到"><a href="#一条事物update-的时候各个日志在什么时候会用到" class="headerlink" title="一条事物update 的时候各个日志在什么时候会用到"></a>一条事物update 的时候各个日志在什么时候会用到</h4><pre><code class="hljs">1. 开启事物, 先将记录记录到undo log 中, 将更新的旧数据记录到undo log中2. innodb 开始更新记录, 先更新内存, 同时标记为脏页, 将记录写入redolog 中, 为了减少磁盘的IO, 由后台线程将脏页数据写入到磁盘中3. 更新完成后, 记录该语句对应的binlog, 此时binlog 会保存到binlog cache 中, 在事物提交的时候统一将所有binlog刷新的磁盘上4. 事物提交    prepare 阶段 redolog 设置事物状态为prepare, 将redolog 刷盘    commit 阶段 binlog刷盘, 将redolog设置为commit</code></pre><h4 id="为什么需要两阶段提交"><a href="#为什么需要两阶段提交" class="headerlink" title="为什么需要两阶段提交"></a>为什么需要两阶段提交</h4><pre><code class="hljs">binlog 的两阶段提交    目的:         防止数据丢失和保证数据的一致性        保持binlog 和 redo log 的一致性: 确保数据库崩溃后, 保证事物提交的原子性和一致性        防止数据丢失: 如果事物已经提交到了redo log，但是没有写入到binlog 中, 在系统奔溃后恢复, 由于binlog 没有该事物的记录, 从而影响主从复制.  如果数据只是存在redo log 中, 不存在 binlog 中, 则对数据页不进行同步        防止数据不一致: 如果事物已经写入到binlog 但是没有写入到redolog， 奔溃后恢复的时候会导致binlog 中有记录, 但是实际数据库没有应用, 导致数据不一致    过程        1. prepare 阶段            事物执行, innondb 会将事物的更改记录写入到redo log 中, 并将这些日志标记为 prepare 状态, 这意味着这些事物已经在操作了, 但是还未提交, 数据的修改刷新了内存中, 但是还没有刷新到磁盘        2. commit 阶段            写入binlog， 在事物提交之前, 将事物的更改写入到binlog 中, 此时binlog 记录的是最终持久化的数据, 此时redolog 中数据还是处于prepare 状态            提交事物, 将redolog 中的事物标记为commit 状态, 一旦事物标记为commit, 数据页的修改会被刷新到磁盘上    关键:        顺序性和原子性:            先记录redolog 的prepare 状态, 再写入binlog, 最后提交redo log， 防止奔溃恢复时出现数据的不一致        奔溃恢复            如果在写入binlog 后, 但是在提交redolog 之前的 发生了奔溃, mysql 在恢复时根据redolog 的prepare状态 和binlog 的记录继续完成提交, 确保事物的一致性</code></pre><h4 id="事物隔离级别-什么是脏读、幻读"><a href="#事物隔离级别-什么是脏读、幻读" class="headerlink" title="事物隔离级别, 什么是脏读、幻读"></a>事物隔离级别, 什么是脏读、幻读</h4><pre><code class="hljs">读未提交 允许读取到未提交的事物, 可能导致脏读、不可重复读、幻读读已提交 允许读取到事物已经提交的数据, 可以防止脏读, 可能导致不可重复读、幻读可重复读 对于多次读取的数据是一致的, 可以防止脏读、不可以重复读, 可能导致幻读串行化   事物的最高级别, 所有事物都是要串行的去执行, 可以防止脏读、幻读、不可重复读脏读: 读区到其他未提交事物的数据不可重复读:  对于同一条数据, 在同一个事物中前后读区结果不一致幻读: 在同一个事物中, 对于一个范围内的数据进行多次多去, 发现返回的数据结果行数不一致</code></pre><h4 id="可重复读为什么不能解决幻读"><a href="#可重复读为什么不能解决幻读" class="headerlink" title="可重复读为什么不能解决幻读"></a>可重复读为什么不能解决幻读</h4><pre><code class="hljs">读已提交: 事物中只能读取到其他已提交的数据    通过在语句执行之前生成一个read view, 因此可以保证每次读取的时候可以读取到其他事物提交后的数据可重复读 是通过在启动事物时生成一个read view, 整个事物期间都在用这个read view, 因此没办法防止幻读, 因为整个事物期间基于的视图时一样的</code></pre><!-- #### 存储引擎为什么默认选择innodb    1. 支持事物    2. innodb 是聚集索引, MyISAM 是非聚集索引    3. 锁力度: innodb 最小是行锁，myIsam 是表锁 --><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><h3 id="支持的数据结构"><a href="#支持的数据结构" class="headerlink" title="支持的数据结构:"></a>支持的数据结构:</h3><pre><code class="hljs">    String、Hash、List、Set、ZSet可以持久化保存在磁盘中</code></pre><h3 id="redis-单线程"><a href="#redis-单线程" class="headerlink" title="redis 单线程"></a>redis 单线程</h3><pre><code class="hljs">接收客户端请求-&gt;解析请求 -&gt;进行数据读写等操作-&gt;发送数据给客户端 整个过程是单线程的单线程为什么那么快:    1. 大部分操作都是在内存当中操作的, 采用了高效的数据结构,      2. I/O 多路复用去处理大量客户端的Socket 请求,     使用单线程的原因:        CPU 不是Redis 性能的瓶颈, 更多的是在内存上和网络I/O的限制, 同时单线程可维护性高, 多线程的话增加系统复杂度, 存在线程切换等问题6.0 后用多线程去做    为什么要在6.0 后用多线程去做: 提升网络I/O, 命令的执行仍然是单线程的</code></pre><h3 id="Redis-如何实现数据不丢失"><a href="#Redis-如何实现数据不丢失" class="headerlink" title="Redis 如何实现数据不丢失"></a>Redis 如何实现数据不丢失</h3><pre><code class="hljs">1. 读写操作在内存中, 同时有做持久化2. 持久化日志:     AOF 日志、每一个写的命令, 将对应的命令写入到该文件中        先执行命令操作, 再记录到AOF 文件日志中        写回的策略        alwaysEverySyc No        同步写回每秒回写由操作系统控制        可靠性高,性能适中, 性能好        但是开销大宕机丢失一秒数据宕机丢失的数据多            RDB 日志: 将某一时刻的内存数据, 以二进制的方式写入磁盘        生成rdb 文件: save(会阻塞主线程) 和 bgsave(后台线程操作)        使用bgsave 的时候可以继续处理命令    混合持久化方式</code></pre><h3 id="Redis-如何实现集群的高可用"><a href="#Redis-如何实现集群的高可用" class="headerlink" title="Redis 如何实现集群的高可用"></a>Redis 如何实现集群的高可用</h3><pre><code class="hljs">1. 主从复制    主从复制采用读写分离的方式, 写数据的时候写到主节点, 主节点收到写的命令后会更新给从节点,  客户端无须等到从节点都更新完再拿到响应的结果2. 哨兵模式    可以对主从进行监控, 同时进行主从切换3. 切片集群    数据量很大的时候, 可以用redis clusterredis cluster 或者主从的时候出现脑裂怎么办    当主节点发现从节点下线, 或者通信的数量少于阈值时, 那么禁止主节点进行写数据, 直接把错误返回给客户端    min-slave-to-write x 主节点至少要和 x 个节点进行连接, 如果小于这个数量, 主节点会禁止写数据    min-slave-to-lag x   主从复制的延迟同步不可以超过 x 秒,  如果超过的话, 会禁止 主节点写数据    上述的配置可以防止主节点故障的时候进行写数据, 只有新的主库才可以写数据</code></pre><p>哨兵模式和主从模式</p><h4 id="哨兵负责三个事情"><a href="#哨兵负责三个事情" class="headerlink" title="哨兵负责三个事情:"></a>哨兵负责三个事情:</h4><pre><code class="hljs">监控:     主观下线        发送Ping 命令给主节点, 如果主节点在一定时间内没有相应的话, 会被标记为SDOWN, 主观下线,    客观下线        多个哨兵节点通信认为某个节点不可用, 则认为改节点为客观下线, ODOWN哨兵节点的选主:    在主节点被标记为ODOWN 后, 哨兵节点会通过RAFT进行一次投票选举, 确定哪个哨兵节点作为领导者, 负责执行故障转移, 每个哨兵节点可以发起投票,并且每个哨兵节点只能投票给一个哨兵节点    获得多数票的哨兵节点被选为领导者, 负责后续的主从切换选择主节点    哨兵的leader 从可用的从节点中选主一个新的主节点, 主节点标准:        1. 从节点的优先级高的更可能被选中        2. 复制偏移量, (代表和主节点是否更接近的,) 更有可能选中        3. 链接状态好的    哨兵的leader 会向其他哨兵节点通知选主的主节点主从切换    选中的从节点会倍提升为主节点, 新的主节点会停止从旧的主节点同步数据, 并且开始接受写入操作    重新配置集群,  其他从节点开始从新的主节点上去同步数据, 包含和旧的主节点连接的断开. 从新的主节点获取数据    通知客户端, 客户端根据配置更新配置恢复正常运行</code></pre><h3 id="删除策略"><a href="#删除策略" class="headerlink" title="删除策略"></a>删除策略</h3><pre><code class="hljs">1. 主库通过lazy 的方式进行删除2. 主库会发送一个del 事件给从库, 从库收到后对数据进行删除</code></pre><h3 id="内存满了后怎么处理"><a href="#内存满了后怎么处理" class="headerlink" title="内存满了后怎么处理"></a>内存满了后怎么处理</h3><pre><code class="hljs">1. 进行淘汰</code></pre><h3 id="Redis-缓存设计"><a href="#Redis-缓存设计" class="headerlink" title="Redis 缓存设计"></a>Redis 缓存设计</h3><pre><code class="hljs">如何避免缓存失效    1. 不给热点key 设置过期时间    2. 将缓存失效的事件随机打散, 防止集体失效如何避免缓存击穿    1. 热点key 要过期的时候, 通知后台线程进行更新如何避免缓存穿透 数据不存在数据库中, 要不存在redis 中    1. 对恶意请求进行限制拦截    2. 设置默认值    3. 通过布隆过滤器 去设置值是否存在, 不是直接通过数据库进行查询</code></pre><h3 id="更新缓存策略"><a href="#更新缓存策略" class="headerlink" title="更新缓存策略"></a>更新缓存策略</h3><pre><code class="hljs">1. cache aside: 读多写少的场景    针对读多写少的场景: 先更新数据库, 再去删除缓存    如果是更新缓存的话        性能上: 缓存的更新可能是多张表聚合之后的结果得到的, 写操作中更新性能开销比较大        安全上: 写请求中更新 容易引发不一致问题:  T1 和 T2. T1 更新数据库, T2 更新数据库, 同时更新缓存, 此时T1 可能更新缓存的话 可能比T2 要晚. 导致数据不一致    为什么是先更新数据库, 在删除缓存, 而不是先删除缓存, 再更新        T1 和 T2, T1 写删除了缓存, T2 查询拿到老数据进行了更新. 导致缓存数据是老的        同时先删除缓存的话, 会导致DB 压力大写多读少的场景    Write Through 策略    数据更新的时候, 如果数据库中有数据, 则先更新缓存中的数据,通过缓存组建同步更新到数据库中, 缓存组建告知应用程序更新完成    如果没有数据的话 则直接进行更新即可Write back    更新数据库的时候, 只更新缓存, 将缓存数据设置为脏数据, 然后立马返回, 数据库的更新 再通过批量更新</code></pre><h3 id="大key-的影响"><a href="#大key-的影响" class="headerlink" title="大key 的影响"></a>大key 的影响</h3><pre><code class="hljs">1. 客户端阻塞超时2. 引发网络阻塞3. 内存分布不均匀4. 阻塞工作线程</code></pre><h3 id="如果找到大key"><a href="#如果找到大key" class="headerlink" title="如果找到大key"></a>如果找到大key</h3><pre><code class="hljs">1. redis-cli --bigkeys2. scan 找大key</code></pre><h1 id="java-基础"><a href="#java-基础" class="headerlink" title="java 基础"></a>java 基础</h1><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h3 id="拆装箱"><a href="#拆装箱" class="headerlink" title="拆装箱"></a>拆装箱</h3><pre><code class="hljs">什么是自动拆装箱？java 中将基本数据类型和对象之间转换的过程, 目的是将基本类型和对象的转换更加方便. 装箱：将基本类型用它们对应的引用类型包装起来；拆箱：将包装类型转换为基本数据类型int short byte long double float boolean char</code></pre><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><pre><code class="hljs">成员变量与局部变量的区别？    语法形式: 从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数    存储方式: 如果成员变量是使用 static 修饰的，那么这个成员变量是属于类的，如果没有使用 static 修饰，这个成员变量是属于实例的; 而对象存在于堆内存，局部变量则存在于栈内存。    生存时间：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</code></pre><h3 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3><pre><code class="hljs">1. 共同点    1.1 都不能被实例化, 接口只能被实现或者是抽象来被继承才可以实例话    1.2 都可以包含抽象方法, 抽象方法没有方法体, 必须在子类或者实现类中实现2. 不同点    2.1 设计目的: 接口主要用于对行为进行约束, 抽象类用于代码的复用, 强调所属关系    2.2 继承和实现: 一个类只能继承一个类, 一个类可以实现多个接口</code></pre><h3 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h3><pre><code class="hljs">浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。深拷贝：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</code></pre><h3 id="x3D-x3D-和-equals-的区别"><a href="#x3D-x3D-和-equals-的区别" class="headerlink" title="&#x3D;&#x3D; 和 equals() 的区别"></a>&#x3D;&#x3D; 和 equals() 的区别</h3><pre><code class="hljs">1. 对于基本数据类型来说，== 比较的是值。2. 对于引用数据类型来说，== 比较的是对象的内存地址。</code></pre><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><h3 id="为什么是不可变的"><a href="#为什么是不可变的" class="headerlink" title="为什么是不可变的"></a>为什么是不可变的</h3><pre><code class="hljs">1. 保存字符串的数组是被final 修饰, 并且是私有的, 并且string  没有提供修改这个字符串的方法2. String 类被final 修饰 导致不能被继承</code></pre><h3 id="stringBuilder-和-stringBuffer"><a href="#stringBuilder-和-stringBuffer" class="headerlink" title="stringBuilder 和 stringBuffer"></a>stringBuilder 和 stringBuffer</h3><pre><code class="hljs">stringBuffer: 适用于多线程操作字符串缓冲区下操作大量数据strinbgBuilder: 适用于单线程操作字符串缓冲区下操作大量数据</code></pre><h2 id="范型"><a href="#范型" class="headerlink" title="范型"></a>范型</h2><pre><code class="hljs">作用: 增强代码的可读性和稳定性</code></pre><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><pre><code class="hljs">1. 范型类2. 范型接口3. 范型方法</code></pre><h3 id="范型擦除"><a href="#范型擦除" class="headerlink" title="范型擦除"></a>范型擦除</h3><pre><code class="hljs">编译器会移除所有的范型类型信息, 从而确保与java 的原始类型兼容. 目的是为了和jdk1.5之前的版本向前兼容, 使得范型在运行的时候类型信息被擦除, 无法获得实际的类型信息影响:    1. 运行时类型检查的限制, 不允许对范型类型进行某些运行时检查        obj instanceof List&lt;String&gt;    2. 类型安全问题: 擦出后默认都是object    3. 无法获得范型参数类型</code></pre><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><pre><code class="hljs">1. 强引用    定义: 最常见的引用类型, 代码中 new 创建对象后, 赋值给一个变量    特性: 只要强引用类型存在, JVM 就不会回收, 使用方式就是 Object obj = new Object()2. 软引用    定义: 描述还可以保留的, 但是当内存不足的情况下, GC  可以对这部分对象进行回收    特性: 当JVM 内存不足的时候, 软引用对象会被回收    用途: 缓存, 实现内存敏感的缓存    SoftReference&lt;Object&gt; softRef = new SoftReference&lt;&gt;(new Object());3. 弱引用    定义: 描述一些不需要强引用, 只要对象被弱引用引用, 就会被GC回收    特性: 无论内存是否充足, 只要进行GC, 弱引用对象就会被回收    用途: ThreadLocal    WeakReference&lt;Object&gt; weakRef = new WeakReference&lt;&gt;(new Object());4. 虚引用    定义: 用于跟踪对象的生命周期, 不影响对象的生存状态,     特性: 一旦对象被回收, 虚引用会被加入到指定的引用队列中, 虚引用的存在对象没有实际的影响    用途: 用于对象被GC回收时的一些清理动作, 如释放非内存资源</code></pre><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><pre><code class="hljs">获取class 对象的方式:    1. Class alunbarClass = TargetObject.class;    2. Class alunbarClass1 = Class.forName(&quot;cn.javaguide.TargetObject&quot;);    3. TargetObject o = new TargetObject();            Class alunbarClass2 = o.getClass();    4. ClassLoader.getSystemClassLoader().loadClass(&quot;cn.javaguide.TargetObject&quot;);</code></pre><h3 id="反射的操作"><a href="#反射的操作" class="headerlink" title="反射的操作"></a>反射的操作</h3><pre><code class="hljs">创建一个我们要使用反射操作的类 TargetObject使用反射操作这个类的方法以及参数    获取方法:Method[] methods = targetClass.getDeclaredMethods();    获取方法并调用: Method publicMethod = targetClass.getDeclaredMethod(&quot;publicMethod&quot;,String.class);    publicMethod.invoke(targetObject, &quot;JavaGuide&quot;);    获取指定参数:Field field = targetClass.getDeclaredField(&quot;value&quot;);    对指定参数进行修改        field.setAccessible(true);        field.set(targetObject, &quot;JavaGuide&quot;);</code></pre><h2 id="动态代理的过程"><a href="#动态代理的过程" class="headerlink" title="动态代理的过程"></a>动态代理的过程</h2><pre><code class="hljs">jdk 动态代理通过 Proxy 类生成一个代理对象, 这个代理对象实现了目标类的接口, 并将方法调用委托给 InvocationHandler 来进行处理1. 接口定义    1.1 创建一个自定义的接口2. 实现 InvocationHandler 接口    2.1 这个类的invoke 方法 会处理所有代理类上的方法调用            proxy :动态生成的代理类            method : 与代理类对象调用的方法相对应            args : 当前 method 方法的参数3. 创建代理类    MyInterface target = new MyInterfaceImpl();    // 创建InvocationHandler    MyInvocationHandler handler = new MyInvocationHandler(target);        loader :类加载器，用于加载代理对象。            interfaces : 被代理类实现的一些接口；            h : 实现了 InvocationHandler 接口的对象；    // 创建代理实例    MyInterface proxyInstance = (MyInterface) Proxy.newProxyInstance(        target.getClass().getClassLoader(),        target.getClass().getInterfaces(),        handler    );4. 调用代理类的方法</code></pre><h3 id="操作字节码的过程"><a href="#操作字节码的过程" class="headerlink" title="操作字节码的过程"></a>操作字节码的过程</h3><pre><code class="hljs">1. asm: 允许直接生成、分析、修改java 字节码2. cgLib: 通过生成目标类的子类并覆盖父类的方法来创建代理对象, 因此可以代理普通类, 不仅仅是接口, CGLib 使用asm 来生成字节码spring 在目标类实现任何的实现接口的时候, 默认使用cgLib 来处理, 如果类实现了一个或者多个接口的时候, 采用JDK 动态代理</code></pre><h3 id="字节码增强"><a href="#字节码增强" class="headerlink" title="字节码增强:"></a>字节码增强:</h3><pre><code class="hljs">cglib 通过生成目标类的子类的方法来创建代理对象            定义一个类；            自定义 MethodInterceptor 并重写 intercept 方法，intercept 用于拦截增强被代理类的方法，和 JDK 动态代理中的 invoke 方法类似；            通过 Enhancer 类的 create()创建代理类；        cglib 不可以代理声明为final 类型的类和方法    asm 是可以直接修改字节码的其中spring 默认是使用clglib</code></pre><h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h2><pre><code class="hljs">专门给服务提供者或者扩展框架功能开发者去使用的一个接口缺点:    1. 无法指定默认的实现类    2. 加载实现类的过程无法定制, 例如无法通过以来注入的方式管理实例    3. 无法对不同的类做自动注入或者AOP 扩展</code></pre><h3 id="spring-SPI"><a href="#spring-SPI" class="headerlink" title="spring SPI"></a>spring SPI</h3><pre><code class="hljs">主要是通过 SpringFactoriesLoader 实现的1. 读取spring.factories 文件: 文件中包含了接口到实现类的映射列表, spring 根据接口找到对应的实现类2. 通过映射关系, 通过反射去实例化类, 并注册到spring 的上下文中3. spring 根据上下文将这些实现类注册为spring bean, 4. 执行扩展逻辑: 如果某些接口实现类ApllicationContextInitalization 接口, spring 会在初始化的时候调用init() 方法</code></pre><h3 id="dubbo-SPI"><a href="#dubbo-SPI" class="headerlink" title="dubbo SPI"></a>dubbo SPI</h3><pre><code class="hljs">支持自动注入、支持wrapper 类、支持Adapative 扩展、支持通过配置文件的方式指定默认实现dubbo SPI 通过 ExtensionLoader 进行加载, 工作机制如下:    1. 通过@SPI 表示某个接口为扩展点, 该接口可以有多个实现类    2. 通过 ExtensionLoader 扫描META-INF/dubbo 或 META-INF/services 目录下的配置文件, 找到接口的扩展实现, 并将实现动态加载进来    3. Wrapper 包装类扩展, 通过构造函数接受扩展实例, 对其功能进行扩展包装ExtensionLoader 原理    1. 缓存扩展类定义: ExtensionLoader 会先从缓存中扩展类实例, 如果没有的话, 则从配置文件中加载扩展类, 并进行实例化    2. 实例化和依赖注入: 通过反射创建扩展类的实例, 并自动注入依赖    3. wrapper 装饰: 如果存在wrapper, 会将扩展类包括在wrapper 中    4. 返回扩展类实例: 返回最终构造的扩展类实例</code></pre><h3 id="和API-的区别"><a href="#和API-的区别" class="headerlink" title="和API 的区别"></a>和API 的区别</h3><pre><code class="hljs">1. API: 实现方提供了接口和实现, 我们可以通过实现方的接口从而实现实现方提供给我们的能力.2. SPI: 接口方确定接口规则, 不同的实现方根据这个规则去进行实现如 slf4j</code></pre><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><pre><code class="hljs">1. 本质上通过反射实现的, 将要暴露对外使用的具体实现类放在META-INF/services/ 文件下声明2. 可以提升灵活性3. 缺点是效率低, 在遍历加载所有的实现类的时候</code></pre><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><pre><code class="hljs">序列化: 将数据结构或对象转换成可以存储或者是传输的形式, 通常为二进制的字节流反序列化: 将在序列化过程中所生成的数据转换为原始数据结构或者对象的过程</code></pre><h3 id="java-自身序列化问题"><a href="#java-自身序列化问题" class="headerlink" title="java 自身序列化问题"></a>java 自身序列化问题</h3><pre><code class="hljs">1. 不支持跨语言调用2. 性能差</code></pre><h2 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h2><pre><code class="hljs">1. equals    比较两个对象是否相等2. hashCode    返回对象的哈希码, 用于在哈希表等集合中可以进行快速查找3. notify    1. 唤醒该对象在监视器上的等待， 如果有多个线程在等待, 只有一个线程会被唤醒4. notifyAll    唤醒该对象上监视器上所有的线程， 会通知所有的等待线程, 可以让他们早日获得锁5. wait    使得当前线程在该对象的监视器上等待, 当其他线程调用notify 或 notifyAll 方法时, 调用wait 方法后, 线程可以获得锁6. wait(long timeout)     是的当前线程在该对象的监视器上等待， 最多等到指定的毫秒数, 如果超时之前调用notify 或者是 notifyAll，线程会被唤醒， 如果超时未到， 线程继续等待7. finalize    用于对象被GC之前进行一些清理的动作    7.1 清理资源: 对象生命周期结束时, 确保资源可以正确被释放    7.2. 默认实现</code></pre><h2 id="final-static-volatile"><a href="#final-static-volatile" class="headerlink" title="final static volatile"></a>final static volatile</h2><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><pre><code class="hljs">1. 修饰的类不能被继承, 类中的所有成员方法都会被隐式的制定为final 方法2. 修饰的方法不能被重写3. 修饰的变量是常量</code></pre><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><pre><code class="hljs">1. 修饰成员变量和成员方法, 被static 修饰的成员变量 属于类, 不属于单个方法, 被类中所有对象共享. 2. 修饰静态代码块. 静态代码块在非静态代码块之前执行3. 静态内部类.</code></pre><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><pre><code class="hljs">1. 保证可见性2. 保证有序性3. i++ 是分为3部来走的    3.1 读取原始变量 i 的值    3.2 将 i 的进行加1, 结果变为 n + 1;    3.3 将增加后的 n+1 存回变量 i 中</code></pre><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><pre><code class="hljs">1. 修饰实例方法。当前对象锁2. 修饰静态方法。当前类锁3. 修饰代码块。  当前类 或者 是对象锁基于 对象头中的 monitorEnter 和 monitorExist </code></pre><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><pre><code class="hljs">1. JVM 中线程共享的区域: 堆 metaspace2. JVM 中线程私有的: 虚拟机栈、本地方法栈、程序计数器。 通过-xss 可以设置    为什么虚拟机栈和 程序计数器是私有的        1. 程序计数器是为了线程切换后可以回到正确的位置        2. 虚拟机栈的作用是每个方法在执行的时候会创建对应的桢栈, 用于存储局部变量表、操作数、常量等信息, 它私有为了保证局部变量不被其他线程访问    每个线程映射到操作系统线程, 线程的创建、调度运行依赖于原生的线程调度, 操作系统提供实际调度, jvm 提供管理</code></pre><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><h4 id="线程的状态-1"><a href="#线程的状态-1" class="headerlink" title="线程的状态"></a>线程的状态</h4><pre><code class="hljs">1. NEW: 初始状态，线程被创建出来但没有被调用 start() 。2. RUNNABLE: 运行状态，线程被调用了 start()等待运行的状态。3. BLOCKED：阻塞状态，需要等待锁释放。4. WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。5. TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。6. TERMINATED：终止状态，表示该线程已经运行完毕。</code></pre><p><img src="/../img/jdk/threadState.png" alt="线程状态"></p><h5 id="start-和-run-的区别"><a href="#start-和-run-的区别" class="headerlink" title="start 和 run 的区别"></a>start 和 run 的区别</h5><pre><code class="hljs">start 方法是Thread 中的一个方法, JVM 会创建一个新的线程, 并调用该线程的 run 方法, 一旦调用 strat 方法, 线程的状态将变为 new, 然后转换成 RUNNABLE, 等待CPU的调度run 是 runnable 接口中的一个方法, 包含了线程中要执行的代码, 直接调用run 方法不会去启动一个新的线程, 而是以当前线程的上下文 执行 run() 方法中的代码线程状态的变化:    strat: 线程状态从 new 变为 runnable, 然后等待CPU的调度, 执行run 方法    run: 线程状态保持为 new , 不会启动新的线程, 而是在当前线程中进行执行</code></pre><h5 id="WAITING-和-TIME-WAITING-区分的原因"><a href="#WAITING-和-TIME-WAITING-区分的原因" class="headerlink" title="WAITING 和 TIME_WAITING 区分的原因"></a>WAITING 和 TIME_WAITING 区分的原因</h5><pre><code class="hljs">1. 一个是有超时状态的, 到时后将自动恢复执行.  一个是会无限制等待的2. 通过对线程更加精细化的区分, JVM 需要做不同的处理. 3. 开发者也更加明确</code></pre><h5 id="什么是线程上下文切换"><a href="#什么是线程上下文切换" class="headerlink" title="什么是线程上下文切换"></a>什么是线程上下文切换</h5><pre><code class="hljs">线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。    主动让出 CPU，比如调用了 sleep(), wait() 等。    时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。    调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。    被终止或结束运行</code></pre><h5 id="SLEEP-和-WAIT-的区别"><a href="#SLEEP-和-WAIT-的区别" class="headerlink" title="SLEEP  和 WAIT  的区别"></a>SLEEP  和 WAIT  的区别</h5><pre><code class="hljs">1. sleep 没有释放锁, wait 释放锁2. wait 用于线程交互, sleep 用于暂停3. wait() 方法被调用后, 线程不会自动苏醒, 需要用其他线程调用notify() 或者是 notifyAll() 方法, sleep 执行完成后, 线程会自动苏醒, 或者可以使用wait(timeOut) 可以让线程苏醒4. sleep 时 Thread  类中的静态方法, wait 是object 本地方法    4.1 wait 是让对象锁线程实现等待, 会自动释放当前线程占有的对象, 每个对象拥有对象锁, 既然要释放当前线程占有的对象锁进入waitting 状态, 因此需要操作的是Object 对象    4.2 sleep 是让当前线程暂停, 而不是对象, 不涉及到对象类上</code></pre><h5 id="可以直接调用-Thread-类的-run-方法吗"><a href="#可以直接调用-Thread-类的-run-方法吗" class="headerlink" title="可以直接调用 Thread 类的 run 方法吗"></a>可以直接调用 Thread 类的 run 方法吗</h5><pre><code class="hljs">new 一个thread, 线程进入了new 状态, 调用start()方法, 会启动一个线程并让线程进入就绪状态, 等待获取到时间片就可以开始运行了. start() 会执行线程的响应准备逻辑, 然后自动执行run() 方法的内容. 如果直接是执行run(), 那么只是main 线程下的一个普通方法去运行</code></pre><h3 id="java-创建线程的方式"><a href="#java-创建线程的方式" class="headerlink" title="java 创建线程的方式"></a>java 创建线程的方式</h3><pre><code class="hljs">Thread    继承 Thread 实现run方法, 并且通过 start() 来开始执行Runnable    实现runnable 接口, Callable 和 Future使用 Executor 线程池来管理线程runnable 和 callable:    Runnable 和 callable 都是定义任务的接口,     但是runnable 是没有返回值, 也不能抛出异常,     callable 有返回值, 允许抛出异常Thread 和 Runnable    Thread 类是线程的一个抽象表示, 他实现了 runnable 的接口,    可以通过继承Thread 或者实现runnable 的接口来创建和启动一个线程    推荐的做法是使用runnable 接口去创建任务, 并通过Thread 去进行执行, 这样可以将任务的逻辑和管理进行分开当不需要返回的时候可以用runnable, 有返回结果的时候用callable, Thread 主要用于启动并管理线程</code></pre><h3 id="为什么要用线程池"><a href="#为什么要用线程池" class="headerlink" title="为什么要用线程池"></a>为什么要用线程池</h3><pre><code class="hljs">    有大量异步任务的时候提升性能    通过一系列参数对线程资源进行管理线程正在做一个耗时高的任务, 做到一半怎么进行停止 ===========常用线程池</code></pre><h3 id="线程数的配置方式"><a href="#线程数的配置方式" class="headerlink" title="线程数的配置方式"></a>线程数的配置方式</h3><pre><code class="hljs">1. 计算密集型    一般设置为接近于或等于CPU核心数。        计算密集型任务主要依赖于CPU执行计算。过多的线程会导致线程上下文切换增加，反而可能降低性能。因此，线程数与核心数保持一致或略多于核心数即可充分利用CPU。2. IO 密集型    通常是CPU核心数的多倍。        IO密集型任务通常会有大量时间在等待IO操作完成，如网络或磁盘操作。在等待期间，CPU会空闲，因此可以通过增加线程数来提高并发量，减少CPU空闲时间。</code></pre><h3 id="线程池核心参数介绍-有哪些"><a href="#线程池核心参数介绍-有哪些" class="headerlink" title="线程池核心参数介绍 有哪些"></a>线程池核心参数介绍 有哪些</h3><pre><code class="hljs">核心线程数、最大线程数、超时时间、空闲线程存活的时间单位、用于保存等待执行任务的队列、用于创建线程的工厂、当任务队列满了以后, 用于何种策略去最大线程数包含了核心线程数</code></pre><h3 id="线程池为啥先放阻塞队列-再创建非核心线程"><a href="#线程池为啥先放阻塞队列-再创建非核心线程" class="headerlink" title="线程池为啥先放阻塞队列, 再创建非核心线程"></a>线程池为啥先放阻塞队列, 再创建非核心线程</h3><pre><code class="hljs">1. 提高线程利用率    核心线程数较少的情况下可以处理所有任务, 而无需频繁的创建和销毁线程, 当只有核心线程数都在忙碌, 并且队列中的任务到达一定的数量的时候, 才会去创建非核心线程数, 可以减少频繁的创建和销毁, 提升线程的利用率2. 减少系统资源开销    在高并发的场景下线程的创建和销毁会带来较大的开销, 因此优先使用核心线程数, 再将任务加入到阻塞队列中, 尽可能少的创建非核心线程数, 从而减少系统的资源开销3. 防止过度创建线程    如果在任务到达的时候, 直接创建线程, 可能导致线程快速增长, 最终耗尽资源, 通过将任务加入到阻塞队列中, 可以平衡任务的负载, 只有当队列满了, 并且核心线程数无法处理所有的任务的时候, 才创建额外的非核心线程, 防止系统过载4. 保证任务的有序    可以确保任务按照一定的顺序执行, 在任务过多时才启用, 确保线程池在高负载的时候可以处理任务</code></pre><h3 id="线程池执行异常了-该线程会怎能样-怎么在主线程中捕获该异常"><a href="#线程池执行异常了-该线程会怎能样-怎么在主线程中捕获该异常" class="headerlink" title="线程池执行异常了, 该线程会怎能样, 怎么在主线程中捕获该异常"></a>线程池执行异常了, 该线程会怎能样, 怎么在主线程中捕获该异常</h3><pre><code class="hljs">execute()    如果执行线程没有进行catch 捕获, 会导致worker 线程被终止, 同时默认情况下没有配置afterExecute 方法的, 如果当前worker 小于核心线程数, 则会创建一个新的 worker 线程去进行替换, 新创建的worker 是非核心的submit()    异常会被封装在返回的future 中, 当对象调用future.get 的时候获取到对应的异常</code></pre><h3 id="什么是线程不安全"><a href="#什么是线程不安全" class="headerlink" title="什么是线程不安全"></a>什么是线程不安全</h3><pre><code class="hljs">1. 多线程下面对同一份数据获取, 获取到的数据混乱, 错误或者是丢失</code></pre><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="乐观锁、悲观锁"><a href="#乐观锁、悲观锁" class="headerlink" title="乐观锁、悲观锁"></a>乐观锁、悲观锁</h3><pre><code class="hljs">1. 悲观锁: 假设并发访问冲突会导致数据不一致, 在使用悲观锁的情况下, 线程访问共享资源会事先获得锁, 确保可以独占的进行, 而其他线程则会被阻塞, 悲观锁适用于数据修改比较频繁, 并发冲突比较高的场景下,2. 乐观锁: 假设并发冲突较少发生, 多个线程可以同时进行读写操作而不去加锁, 乐观锁的实现是通过版本号或者时间戳来判断数据是否被进行了修改, 如果一个线程要更新数据, 会先获取当前版本号, 如果当前版本号发生了变化, 则说明其他线程进行了修改, 如果当前版本号没有发生变化, 说明可以进行修改,适用于读多写少的情况, 冲突比较少的情况悲观锁通常多用于写比较多的情况（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如LongAdder），也是可以考虑使用乐观锁的，要视实际情况而定。乐观锁通常多用于写比较少的情况（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考java.util.concurrent.atomic包下面的原子变量类</code></pre><h3 id="锁的使用场景"><a href="#锁的使用场景" class="headerlink" title="锁的使用场景:"></a>锁的使用场景:</h3><pre><code class="hljs">读写锁:    读多写少的, 高并发的情况下可以提高读取的效率乐观锁:    通过版本号机制, 适用于冲突较少, 并发较低的情况下, 适用于读操作比较多,悲观锁:        适用于写操作比较多, 并发冲突比较多的场景        synchronized:            简单的并发控制, 例如在方法上或者对象上控制并发        ReentrantLock:            可以手动的管理锁的粒度, 可中断锁, 可对锁进行超时处理</code></pre><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><pre><code class="hljs">读多, 写少的情况下读操作的并发性:    只有没有写操作, 多个线程同时进行读取数据, 在读多写少的场景下面可以显著提高读取的性能写操作的独占性:    写操作是独占的, 当一个线程在运行的时候, 其他所有的读取和写都会被阻塞, 直到写操作完成。这样可以保证数据的一致性, 防止读线程读取到错误不完整的数据。使用场景:    读多写少的场景, 例如: 缓存, 配置读取读锁为共享锁，写锁为排他锁如何保证安全性:    读锁: 在进行更新数据的时候, 只有所有读锁都释放了以后, 写锁才可以被获取到    写锁: 写锁获取时, 会检查是否有读锁的存在, 如果有读锁的存在, 写锁会被阻塞, 直到所有的读锁都被释放, 一旦有线程拿到写锁, 会阻止任何新的读锁和其他写锁的获取    </code></pre><!-- #### 使用场景##### 乐观锁    适用于读操作比较多, 并发冲突比较少的场景##### 悲观锁    适用于写操作操作比较多, 并发冲突比较多的场景 --><h3 id="synchronized、Lock"><a href="#synchronized、Lock" class="headerlink" title="synchronized、Lock"></a>synchronized、Lock</h3><h4 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h4><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><h4 id="ReadLock、writeLock"><a href="#ReadLock、writeLock" class="headerlink" title="ReadLock、writeLock"></a>ReadLock、writeLock</h4><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><h6 id="ReadLock"><a href="#ReadLock" class="headerlink" title="ReadLock:"></a>ReadLock:</h6><pre><code class="hljs">1. 并发读取, 当多个线程需要读取共享资源的时候, 多个线程可以同时获取锁资源2. 读多写少, 当共享资源的读取次数远远超过写操作的时候, 允许多个读可以提高并发性能</code></pre><h6 id="WriteLock"><a href="#WriteLock" class="headerlink" title="WriteLock:"></a>WriteLock:</h6><pre><code class="hljs">1. 数据修改, 当一个线程要对共享资源去进行修改的时候, 需要获取WriteLock, 写锁会阻塞其他的读锁和写锁, 确保只有一个线程独占获取锁资源2. 数据一致性保护, 当涉及到多个步骤的写锁时, 可以通过WriteLock来保证多个步骤的原子性</code></pre><h3 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁 悲观锁"></a>乐观锁 悲观锁</h3><pre><code class="hljs">并发冲突低的情况下 使用乐观锁    并发冲突高的时候使用乐观锁, 会导致重试的频率增加, 增加系统的响应时间和资源消耗, 给数据库增加压力, 导致系统的复杂性变高并发冲突高的情况下是用悲观锁,    并发冲突低的时候使用悲观锁导致资源的浪费.</code></pre><h3 id="synchronized-cas-lock"><a href="#synchronized-cas-lock" class="headerlink" title="synchronized cas lock"></a>synchronized cas lock</h3><pre><code class="hljs">jdk1.6之前的, 将锁信息放在对象头的Monitor 中, 通过操作系统的Mutex Lock 来实现, 1.7 1.8 以后通过锁升级、锁优化来解决这个问题, 锁升级有无锁, 偏向锁, 轻量级锁, 重量级锁lock 是基于aqs 来进行实现的</code></pre><h4 id="cas"><a href="#cas" class="headerlink" title="cas"></a>cas</h4><pre><code class="hljs">CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。</code></pre><h4 id="synchronized-1"><a href="#synchronized-1" class="headerlink" title="synchronized"></a>synchronized</h4><pre><code class="hljs">1. 修饰实例方法  锁当前对象2. 修饰静态方法锁当前类3. 修饰代码块。   锁执行对象或者是类</code></pre><h4 id="reentrantLocak"><a href="#reentrantLocak" class="headerlink" title="reentrantLocak"></a>reentrantLocak</h4><h3 id="synchronized-和-reentrantLocak-区别"><a href="#synchronized-和-reentrantLocak-区别" class="headerlink" title="synchronized 和 reentrantLocak 区别"></a>synchronized 和 reentrantLocak 区别</h3><pre><code class="hljs">相同点:    可重入锁, 都是悲观锁    性能差不多不同点:    synchronized 是java 中的关键字, 是语言级别的 reentrantLocak 依赖于AQS 实现,是java 中的一个类    reentrantLocak 可实现等待中断    reentrantLocak 可实现公平和非公平锁公平锁和非公平锁场景    默认是非公平锁, 非公平锁降低了线程的上下文切换, 具有更高的吞吐量, 降低了锁竞争导致的延迟, 适用于短暂的任务,并发高的情况下    公平锁场景: 对资源的执行顺序具有严格要求的, 业务逻辑处理要求具有公平性的</code></pre><h3 id="死锁判定"><a href="#死锁判定" class="headerlink" title="死锁判定"></a>死锁判定</h3><pre><code class="hljs">1. 互斥条件: 资源在某个时刻只能由一个线程占用, 如果一个线程占用了一个资源, 其他线程不能访问该资源2. 持有并等待: 线程已经持有了一个资源, 但又请求新的资源, 并且由于新资源被其他线程占用而陷入等待, 同时不会释放自己所占用的资源3. 不剥夺条件: 资源不能强制从持有他的线程中剥夺, 只有持有该资源的线程在完成任务后主动释放4. 循环等待条件: 存在一个线程, 链中的每个线程都在等待下一个线程持有的资源, 从而形成一个循环等待的局面</code></pre><h2 id="ThreadLocal-原理"><a href="#ThreadLocal-原理" class="headerlink" title="ThreadLocal 原理"></a>ThreadLocal 原理</h2><pre><code class="hljs">每个线程维护一个叫threadLocals 的 ThreadLocalMap,每个线程维护自己的ThreadLocalMap, threadLocalMap 中其中key 是ThreadLocal 对象, value 是要保存的值, 多个threadLocal 通过ThreadLocal 对象的hash值 来定位到table 中的位置,ThreadLocal 实例被创建的对象持有, ThreadLocal 值也是被线程实例持有, 都是位于堆上的由于ThreadLocal 保存的时候把自己当作key 防盗了ThreadLocalMap 中, 同时是弱引用的, 由于发生了GC的时候, 会被回收, 但是由于线程一直运行, value 是无法得到回收的,  在线程池中, 容易造成内存泄漏, 容易导致ThreadLocalMap 中的key 变为了null, 但是由于threadLocal线程还是一直在运行的, 这个value 一直得不到回收, 导致内存泄漏, 需要在最后使用的地方加上remove, 如果Entry 中的key 是强引用的, 容易导致key 也内存泄漏如果k v 都是弱引用的话, 会导致获取值的不确定性fastThreadLocal 通过InternaleThreadLocal 来避免了内存泄漏, 通过数组的索引可以直接访问数据, 线程退出的时候, 会自动进行清理与该线程相关的FastThreadLocal 信息</code></pre><h2 id="AQS-原理-线程入队列-出队列-唤醒机制-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D"><a href="#AQS-原理-线程入队列-出队列-唤醒机制-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D" class="headerlink" title="AQS 原理, 线程入队列 出队列 唤醒机制&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;"></a>AQS 原理, 线程入队列 出队列 唤醒机制&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</h2><pre><code class="hljs">查看 int 的 volatile state 属性入队列    CAS 尝试获取锁, 获取锁成功则将当前线程为占用了锁资源 CAS(0, 1)                       非公平抢占获取锁    获取锁资源    2.1 尝试获取锁资源    2.1.1 查看当前锁是否被占据    2.1.2 如果没有的话则通过CAS 尝试获取锁, CAS 成功则将当前线程占用了锁资源 非公平抢占获取锁    2.1.3 如果本来就是当前线程拿到了锁的资源, 则进行可重入计数+1, 更新当前锁的重入个数    2.2 获取当前锁资源失败, 则进行入队列等待    2.2.1 创建一个等待的 Node 节点, 如果队列中有节点存在了, 通过 CAS 的方式加入到队尾节点    2.2.1.1 如果上一步CAS 入队尾失败了, 则进行自旋的方式加入到队尾    2.3 尝试入队列    2.3.1 如果前驱节点为头节点, 则尝试获取锁    2.3.2 获取锁成功则将当前节点设置为头节点    2.3.3 如果当前节点不是头节点，或者是获取锁失败    2.3.4 获取前驱节点的状态, 如果状态为SIGINAL(-1) 则挂起    2.3.5 当前前驱节点状态大于0, 说明前驱节点取消了排队, 从后向前去找一个新的前驱节点    2.3.6 当前前驱节点状态为0, 通过 CAS 将当前状态设置为-1出队列    完全释放了锁, 对后续节点进行唤醒        2.1 如果头节点不为空，或者是头节点的状态不是初始状态, 则解除线程挂起        2.1.1 头节点为空, 说明是第一个节点入队列,        2.2 对线程解除挂起        2.2.1 获取头节点的状态值        2.2.2 如果当前头节点状态值小于0, 则将状态值CAS设置为0        2.2.3 获取头节点的下一个节点, 如果下一个节点为空, 或者下个节点状态是被cancel 的, 选择从后向前找到第一个waitStatus&lt; 0的        2.2.3.1 选择从后向前找, 而不是从前向后找, 是因为可能有节点是无效的或者是cancelled的状态        2.2.4 找到节点后, 进行唤醒</code></pre><h3 id="volatile-关键字原理"><a href="#volatile-关键字原理" class="headerlink" title="volatile 关键字原理"></a>volatile 关键字原理</h3><pre><code class="hljs">保证可见性防止重排序happens before 规则    对于一个volatile 变量写的操作happens-before 任意线程对该变量的读操作, 确保了volatile的可见性</code></pre><h2 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h2><h3 id="hashMap"><a href="#hashMap" class="headerlink" title="hashMap"></a>hashMap</h3><h4 id="hashMap-默认是0-75"><a href="#hashMap-默认是0-75" class="headerlink" title="hashMap 默认是0.75"></a>hashMap 默认是0.75</h4><pre><code class="hljs">扩容因子:     更小的话 是更容易创建数组, 占用更大的空间, 会频繁的发生扩缩容    更大的话降低了内存的浪费, 增加查找的插入、删除的复杂度0.75 是一个平衡的结果</code></pre><h4 id="hashMap-中扩容因子是2倍"><a href="#hashMap-中扩容因子是2倍" class="headerlink" title="hashMap 中扩容因子是2倍"></a>hashMap 中扩容因子是2倍</h4><pre><code class="hljs">扩大两倍是为了保证hash 函数的分布均匀, 扩大的三倍后, 可能会导致很多hash 值在同一个buckt 中, 从而降低了查询的效率, 扩大两倍是为了保证hash 分布均匀, 从而提高查询效率扩容到3倍不行 会导致hash 冲突增加, 查询效率变低,</code></pre><h4 id="list-为1-5倍-hashMap-扩容为2倍的原因"><a href="#list-为1-5倍-hashMap-扩容为2倍的原因" class="headerlink" title="list 为1.5倍, hashMap 扩容为2倍的原因"></a>list 为1.5倍, hashMap 扩容为2倍的原因</h4><pre><code class="hljs">1. arrayList 是基于动态数组的 扩容是为了平衡内存利用率和性能, 扩小了可能导致频繁的扩容, 扩大的可能导致内存空间的浪费2. hashMap是基于散列表, 扩容需要确保hash 散列的均衡性, 在计算hash 的时候只需要取模操作就可以了, 扩容为2倍可以减少冲突, 重新计算的时候可以直接利用位运算进行分布</code></pre><h4 id="hashMap-中链表插入数据的过程"><a href="#hashMap-中链表插入数据的过程" class="headerlink" title="hashMap 中链表插入数据的过程"></a>hashMap 中链表插入数据的过程</h4><pre><code class="hljs">1. 1.8 之前头插法2. 1.8 以后尾插法    hashMap 采用尾插法的目的是可以减少多线程下的竞争,减少链表结果的变动</code></pre><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>大体上, HashMap 是一个数组, 数组每一个元素是个单向链表, 数组是HashMap 的主体， 链表是为了解决hash碰撞存在的， 其中解决hash碰撞是通过拉链法去解决冲突, 在jdk1.8后在解决冲突的时候引入了红黑树，其中当链表中的长度大于8的时候，将链表转换成红黑树</p><h5 id="解决hash-冲突方法"><a href="#解决hash-冲突方法" class="headerlink" title="解决hash 冲突方法"></a>解决hash 冲突方法</h5><p>开放地址法<br>拉链法</p><h5 id="put"><a href="#put" class="headerlink" title="put"></a>put</h5><p><strong>对putVal方法添加元素的分析如下：</strong></p><ul><li>①如果定位到的数组位置没有元素 就直接插入。</li><li>②如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果key不相同，就判断p是否是一个树节点，如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)。</li></ul><p>ps:下图有一个小问题，来自 <a href="https://github.com/Snailclimb/JavaGuide/issues/608">issue#608</a>指出：直接覆盖之后应该就会 return，不会有后续操作。参考 JDK8 HashMap.java 658 行。</p><p><img src="/img/jdk/hashMap_put.png" alt="put方法"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">                   <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;<br>    <span class="hljs-comment">// table未初始化或者长度为0，进行扩容</span><br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        n = (tab = resize()).length;<br>    <span class="hljs-comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>        tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>    <span class="hljs-comment">// 桶中已经存在元素</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                <span class="hljs-comment">// 将第一个元素赋值给e，用e来记录</span><br>                e = p;<br>        <span class="hljs-comment">// hash值不相等，即key不相等；为红黑树结点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>            <span class="hljs-comment">// 放入树中</span><br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br>        <span class="hljs-comment">// 为链表结点</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 在链表最末插入结点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-comment">// 到达链表的尾部</span><br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// 在尾部插入新结点</span><br>                    p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">// 结点数量达到阈值，转化为红黑树</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-comment">// 跳出循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span><br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-comment">// 相等，跳出循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span><br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 记录e的value</span><br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>            <span class="hljs-comment">// onlyIfAbsent为false或者旧值为null</span><br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                <span class="hljs-comment">//用新值替换旧值</span><br>                e.value = value;<br>            <span class="hljs-comment">// 访问后回调</span><br>            afterNodeAccess(e);<br>            <span class="hljs-comment">// 返回旧值</span><br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 结构性修改</span><br>    ++modCount;<br>    <span class="hljs-comment">// 实际大小大于阈值则扩容</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    <span class="hljs-comment">// 插入后回调</span><br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="get"><a href="#get" class="headerlink" title="get"></a>get</h5><h4 id="非线程安全"><a href="#非线程安全" class="headerlink" title="非线程安全"></a>非线程安全</h4><p>原子性: 一个操作是否属于不可分割的<br>可见性:一个线程对变量的操作对于另外一个线程是可见的<br>线程A 去进行判断数组中是否存在元素的时候, 线程B 去对值进行修改, 以及两个线程在往链表中插入的时候<br>有序性:代码的执行顺序和语句顺序是一致的</p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p><a href="https://blog.csdn.net/qq_31709249/article/details/106952137">参照链接1</a><br><a href="https://developer.aliyun.com/article/984814">参照链接2</a><br>通过synchronzed, Node 变量value的volatile 以及CAS 去保证安全性<br>其中synchronize锁的粒度为桶中头结点（包括链表Node结点，包装红黑树的TreeBin结),transient volatile Node&lt;K,V&gt;[] table;<br>① 如果数组未没初始化，则先去初始化<br>② 如果对应的桶中的元素为空，那就新建一个链表节点，然后利用CAS操作将其放到桶中的位置。这个过程是在③前面的，我们知道，扩容过程中，每个桶位置迁移节点结束后，会将这个节点设置为ForwardingNode，所以这种情况下，你尽管放，放了以后，扩容的线程总会遍历到这个节点，然后将这个节点迁移到新数组中<br>③ 如果有线程在扩容，那就先去帮助扩容，扩容结束后，再重新put。<br>④ 最后，如果当前桶中已经有元素了，那就用synchronized锁住当前桶中的节点，然后在桶中插入元素，插入的时候，要么插入到链表中，要么插入到红黑树中。我们发现，这里的锁粒度是很小的，就锁住一个桶，不像JDK1.7中的ConcurrentHashMap，是分段锁，锁住很多的桶，所以并发效率更高。<br>⑤ 插入结束后，如果是插入到链表中，那去看看链表的长度有没有超过长度阈值8，如果超过了，就要将链表转换成红黑树。<br>⑥ 最后，让size加一（这里其实是用baseCount来记录长度的，而且处理的时候很复杂，继续看下面）。</p><h4 id="更新size中的addCount"><a href="#更新size中的addCount" class="headerlink" title="更新size中的addCount"></a>更新size中的addCount</h4><p>建立一个CounterCell类型的数组counterCells,每个线程生成一个随机数,用随机数去当线程的hash码, 用来对应到counterCells数组中的位置, 把要更新的值放在CounterCell的value上, 最后同步到baseCount, 获取到一个总的个数</p><h5 id="高并发下如何保证addCount的值的正确性"><a href="#高并发下如何保证addCount的值的正确性" class="headerlink" title="高并发下如何保证addCount的值的正确性"></a>高并发下如何保证addCount的值的正确性</h5><h4 id="扩容过程"><a href="#扩容过程" class="headerlink" title="扩容过程"></a>扩容过程</h4><p>实现了并发迁移的过程<br>每个线程承担不小于 16 个桶中的元素的扩容，然后从右向左划分 16 个桶给当前线程去迁移，每当开始迁移一个桶中的元素的时候，线程会锁住当前槽中列表的头元素，扩容完成后会将这个桶中的节点设置为ForwardingNode。假设这时候正好有 get请求过来会仍旧在旧的列表中访问，如果是插入、修改、删除、合并、compute 等操作时遇到 ForwardingNode，就表示正在扩容，那当前线程会一起扩容，扩容结束后再做元素的更新操作</p><h4 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h4><p>get 的时候普通链表是不需要去进行加锁, value 是通过volatile去进行修饰的, 保证可见性</p><h4 id="hashMap-在1-8-后使用红黑树的的目的"><a href="#hashMap-在1-8-后使用红黑树的的目的" class="headerlink" title="hashMap 在1.8 后使用红黑树的的目的"></a>hashMap 在1.8 后使用红黑树的的目的</h4><pre><code class="hljs">1. 解决链表性能问题, 在发生严重冲突的时候, 健值会以链表的形式保存, 链表的查找删除复杂度位O(n), 当链表很长的时候, 性能会显著下降2. 提高查找效率, 红黑树的增加、查找、删除的复杂度位O(logn)</code></pre><h4 id="hashTable-和-concurrentHashMap"><a href="#hashTable-和-concurrentHashMap" class="headerlink" title="hashTable 和 concurrentHashMap"></a>hashTable 和 concurrentHashMap</h4><pre><code class="hljs">1. 都是并发安全的, hashTable 的所有方法都是通过synchronized 来进行实现的,concurrentHashMap 通过分段锁来实现的2. concurrentHashMap 读的时候 通过volatile 来保证安全性3. concurrentHashMap put    3.1 通过cas 和 synchronized 来保证安全性    3.1.1 计算hash 值    3.1.2 如果要插入的位置是个null 节点, 则直接在该位置插入, 如果不是空节点, 则进行链表采用尾插法, 或者是红黑树插入</code></pre><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><pre><code class="hljs">    Arraylist 与 LinkedList 区别?是否保证线程安全： ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；底层数据结构： ArrayList 底层使用的是 Object 数组；LinkedList 底层使用的是 双向链表 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）插入和删除是否受元素位置的影响：ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add(E e)方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)），时间复杂度就为 O(n)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。LinkedList 采用链表存储，所以在头尾插入或者删除元素不受元素位置的影响（add(E e)、addFirst(E e)、addLast(E e)、removeFirst()、 removeLast()），时间复杂度为 O(1)，如果是要在指定位置 i 插入和删除元素的话（add(int index, E element)，remove(Object o),remove(int index)）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入和删除。是否支持快速随机访问： LinkedList 不支持高效的随机元素访问，而 ArrayList（实现了 RandomAccess 接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。内存空间占用： ArrayList 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</code></pre><h1 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h1><h3 id="new-一个对象-过程是什么样子的"><a href="#new-一个对象-过程是什么样子的" class="headerlink" title="new 一个对象, 过程是什么样子的"></a>new 一个对象, 过程是什么样子的</h3><pre><code class="hljs">创建对象的过程和类加载的过程是Java程序执行的两个不同阶段。创建对象的过程：创建对象是指在程序中通过关键字&quot;new&quot;来实例化一个类，从而在内存中分配一块空间用于存储对象的实例。创建对象的过程包括以下几个步骤：a. 类加载：如果该类还没有被加载，首先需要进行类加载，即将类的字节码加载到内存中。b. 分配内存：在堆内存中分配一块空间，用于存储对象的实例。c. 初始化：对对象的实例进行初始化，设置成员变量的默认值。d. 调用构造方法：执行类的构造方法，对对象进行初始化。类加载的过程：类加载是指将类的字节码文件加载到JVM中，并在内存中生成对应的Class对象，从而可以通过这个Class对象获取类的信息和创建类的实例。类加载过程包括以下几个阶段：a. 加载：查找并加载类的字节码文件。b. 验证：验证字节码文件的格式是否正确，是否有安全性问题。c. 准备：为类的静态变量分配内存，并设置默认值。d. 解析：将类的符号引用转换为直接引用。e. 初始化：执行类的静态初始化代码块，对静态变量进行赋值。锁优化    锁升级    锁消除        检查到共享数据不可能存在竞争的, 执行锁消除</code></pre><h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><ol><li>共享的:堆、方法区(metaspace)、直接内存</li><li>私有的: 程序技术器, 虚拟机栈、本地方法栈</li></ol><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器是当前线程所执行的字节码的行号指示器。他通过通过改变计数器的值来选取下一条需要执行的字节码指令，其中分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。<br>其中每个线程都是有一个程序计数器的，<br>另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器, 因此这部分空间占用的每个线程私有的，也是唯一不会发生OOM的</p><h4 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h4><p>（除去native 方法）java 方法的调用都是通过虚拟机栈来实现的，每次方法的调用时数据的传递都是通过栈进行传递，每个方法开始调用对应入栈，接受后都是对应到出栈。其中每个帧栈上拥有的数据有局部便量表、操作数栈、动态连接等<br><strong>局部变量表</strong> 主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。<br><strong>操作数栈</strong> 主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。<br>栈空间虽然不是无限的，但一般正常调用的情况下是不会出现问题的。不过，如果函数调用陷入无限循环的话，就会导致栈中被压入太多栈帧而占用太多空间，导致栈空间过深。那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 <code>StackOverFlowError</code> 错误。<br>栈中国可能会出现两种错误：</p><ul><li><strong><code>StackOverFlowError</code>：</strong> 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 <code>StackOverFlowError</code> 错误。</li><li><strong><code>OutOfMemoryError</code>：</strong> 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常。</li></ul><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法被执行的时候，本地方法创建的帧栈，用于本地方法存的局部便量表、操作数栈、等信息<br>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 <code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code> 两种错误。</p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域。<strong>几乎所有的对象实例以及数组都在这里分配内存。</strong><br>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。<br>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p><ol><li>新生代内存(Young Generation) 又可以分为Eden区和Survivor 区</li><li>老生代(Old Generation)</li><li>metaspace 区<br>堆这里最容易出现的就是 <code>OutOfMemoryError</code> 错误，并且出现这种错误之后的表现形式还会有几种，比如：</li><li><strong><code>java.lang.OutOfMemoryError: GC Overhead Limit Exceeded</code></strong> ： 当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</li><li><strong><code>java.lang.OutOfMemoryError: Java heap space</code></strong> :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。</li></ol><h4 id="方法区（MetaSpace-永久代）"><a href="#方法区（MetaSpace-永久代）" class="headerlink" title="方法区（MetaSpace 永久代）"></a>方法区（MetaSpace 永久代）</h4><p>方法区是各个线程共享的区域，其中存放的数据有类的信息、方法信息、常量、静态变量等等。</p><blockquote><p>当元空间溢出时会得到如下错误： <code>java.lang.OutOfMemoryError: MetaSpace</code></p></blockquote><p>可以通过 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小</p><h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p>Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 <strong>常量池表(Constant Pool Table)</strong> 。<br>字面量是源代码中的固定值的表示法，即通过字面我们就能知道其值的含义。字面量包括整数、浮点数和字符串字面量，符号引用包括类符号引用、字段符号引用、方法符号引用和接口方法符号引用。<br>常量池表会在类加载后存放到方法区的运行时常量池中。<br>运行时常量池的功能类似于传统编程语言的符号表，尽管它包含了比典型符号表更广泛的数据。<br>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 错误。</p><h5 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h5><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在堆中创建字符串对象”ab“</span><br><span class="hljs-comment">// 将字符串对象”ab“的引用保存在字符串常量池中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">aa</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br><span class="hljs-comment">// 直接返回字符串常量池中字符串对象”ab“的引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>System.out.println(aa==bb);<span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>HotSpot 虚拟机中字符串常量池的实现是 <code>src/hotspot/share/classfile/stringTable.cpp</code> ,<code>StringTable</code> 本质上就是一个<code>HashSet&lt;String&gt;</code> ,容量为 <code>StringTableSize</code>（可以通过 <code>-XX:StringTableSize</code> 参数来设置）。<br><strong><code>StringTable</code> 中保存的是字符串对象的引用，字符串对象的引用指向堆中的字符串对象。</strong><br>JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。<br><strong>JDK 1.7 为什么要将字符串常量池移动到堆中？</strong><br>主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。</p><h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p><h3 id="创建对象的过程"><a href="#创建对象的过程" class="headerlink" title="创建对象的过程"></a>创建对象的过程</h3><h4 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h4><pre><code class="hljs">创建对象的过程和类加载的过程是Java程序执行的两个不同阶段。创建对象的过程：创建对象是指在程序中通过关键字&quot;new&quot;来实例化一个类，从而在内存中分配一块空间用于存储对象的实例。创建对象的过程包括以下几个步骤：a. 类加载：如果该类还没有被加载，首先需要进行类加载，即将类的字节码加载到内存中。b. 分配内存：在堆内存中分配一块空间，用于存储对象的实例。c. 初始化：对对象的实例进行初始化，设置成员变量的默认值。d. 调用构造方法：执行类的构造方法，对对象进行初始化。类加载的过程：类加载是指将类的字节码文件加载到JVM中，并在内存中生成对应的Class对象，从而可以通过这个Class对象获取类的信息和创建类的实例。类加载过程包括以下几个阶段：a. 加载：查找并加载类的字节码文件。b. 验证：验证字节码文件的格式是否正确，是否有安全性问题。c. 准备：为类的静态变量分配内存，并设置默认值。d. 解析：将类的符号引用转换为直接引用。e. 初始化：执行类的静态初始化代码块，对静态变量进行赋值。</code></pre><h3 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h3><pre><code class="hljs">如，当一个类需要被加载时，首先会由最顶层的启动类加载器（Bootstrap ClassLoader）尝试加载，如果找不到则会依次由扩展类加载器（Extension ClassLoader）和应用程序类加载器（Application ClassLoader）尝试加载。只有当三者都无法加载时，才会由用户自定义的类加载器尝试加载1. 双亲委派好处:1. 安全: 防止恶意代码去篡改核心库；2. 类的一致性: 保证层次结构, 相同的类只加载一次1.1 什么情况下要打破双亲委派: 热更新tomcat 要打破的原因是Tomcat打破双亲委派模式是因为在Web应用中，每个Web应用都是一个独立的Java应用，拥有自己的类加载器，且需要加载各自的类和依赖库。tomcat 的父类加载器是StandardClassLoader 会导致类冲突、破坏应用的隔离</code></pre><h3 id="oom-怎么排查"><a href="#oom-怎么排查" class="headerlink" title="oom 怎么排查"></a>oom 怎么排查</h3><pre><code class="hljs">1. 使用jmap 去对内存进行dump2. 启动的时候增加gc 日志查看    2.1 如果是full GC 很频繁, 说明老年代空间不足, 或者是老年代内存被填满了    2.2 如果是full GC 很长, 说明GC 无法及时的释放内存    2.3 查看每次GC 后堆内的使用情况, 判断是否有内存持续增长无法回收, 3. 查看dump 下来的内存文件    3.1 通过 MAT 查看 大对象、对象的引用链路、4. 如果是堆内存不足    4.1 尝试增加堆内存    4.2 针对频繁的 full gc, 或者是yong gc 对内存占用分析, 调整比例    4.3 对频繁创建和销毁的对象可以通过 polling, 减少不必要的重复创建    4.2 更换GC 算法</code></pre><h3 id="堆外内存排查"><a href="#堆外内存排查" class="headerlink" title="堆外内存排查"></a>堆外内存排查</h3><pre><code class="hljs">1. 判断是否限制堆外内存的大小: MaxDirectMemorySize限制堆外的大小2. NMT(native memory Tracking)    -XX:NativeMemoryTracking=detail    jcmd &lt;pid&gt; VM.native_memory summary 查看当前JVM 内存的占用情况    查看各个内存区域的占用情况:        java heap: 堆上的        class: 和类加载相关的, 包括metaspace        Thread: 线程相关的        GC: 垃圾回收器占用的内存        Direct: 直接内存的占用        Native Memory: 通过JNI 或其他本机分配的内存3. pmap 查看虚拟内存和本机内存的分配4. netty 的话 有Dio.netty.leakDetection.level 检测, 是否发生泄漏</code></pre><h3 id="CPU-负载过高"><a href="#CPU-负载过高" class="headerlink" title="CPU 负载过高"></a>CPU 负载过高</h3><pre><code class="hljs">1. 查看是否有死循环2. GC 频繁3. IO 操作过多(入频繁的磁盘IO)4. 上下文切换过多, 请求量大工具使用:1. top + jstack 查看 什么线程在处理2. jstat 查看GC 行为. 释放有频繁的full GC 3. perf 生成采样文件    perf record -F 99 -a -g -- sleep 60    FlameGraph 工具生成svg 火焰图</code></pre><h3 id="yong-GC-频率高"><a href="#yong-GC-频率高" class="headerlink" title="yong GC 频率高"></a>yong GC 频率高</h3><pre><code class="hljs">原因: 程序在 eden 区的对象分配和晋升速率过高, 导致频繁的进行GC1. 打开GC 日志2. 调整堆内存大小    初始堆大小:Xms 最大堆大小: Xmx, 策略上尽量设置一样大.  避免堆内存动态扩展带来的开销    调大新生代的比例: -XX:NewRatio3. 排查代码是否会产生大量临时对象, 这些临时对象是否可以复用4. 调整晋升到老年代的阈值    -XX:MaxTenuringThreshold5. 使用zgc</code></pre><h3 id="yong-GC-耗时长"><a href="#yong-GC-耗时长" class="headerlink" title="yong GC 耗时长"></a>yong GC 耗时长</h3><pre><code class="hljs">原因: 新生代GC 的时候发生了较大的停顿, 可能导致性能下降    1. 打开GC日志    2. 调整新生代的比例: 比例越大, 单次GC 扫描的时间也就是越长, 比例越小, 可能会导致频繁GC    3. 调整晋升的阈值: 过大的阈值可能导致新生代空间不足, 增加GC的停顿时间    4. 对象是否可以polling 处理</code></pre><h3 id="full-GC-频率高"><a href="#full-GC-频率高" class="headerlink" title="full GC 频率高"></a>full GC 频率高</h3><pre><code class="hljs">原因: 老年代空间不足, 导致频繁的full GC    1. 打开GC日志, 查看GC 频率和停顿时间    2. 可能原因:         2.1 老年代空间不足, 新生代晋升到老年代后占用了过多的老年代        2.2 metaspace 空间不足, 类加载过多, 导致metaspace 被用完了    3. MAT 查看内存占用情况    4. 增大堆内存</code></pre><h3 id="java-内存区域有哪些"><a href="#java-内存区域有哪些" class="headerlink" title="java 内存区域有哪些"></a>java 内存区域有哪些</h3><pre><code class="hljs">程序计数器    线程私有的, 当前线程正在执行的行号指示器虚拟机栈    线程私有的, 随着线程的创建而创建, 每个方法的调用都将对应的操作进行入栈和出栈本地方法栈    线程私有的, 执行native 方法用到的堆    线程共享的 metaspace 方法区    存放类的加载信息, 运行时常量池, 类加载器、静态变量等    线程共享的创建线程很多导致异常的    1. 虚拟机栈    抛出OOM 异常, unable to create new native thread    2. 堆上的      OOM, java heap space</code></pre><h3 id="yong-区比"><a href="#yong-区比" class="headerlink" title="yong 区比"></a>yong 区比</h3><pre><code class="hljs">新生代 Eden + S0 +  S1  对应的比列是多少 8:1:1老年代G1 默认是5%</code></pre><h3 id="如何判断死亡对象-GC-Roots-有哪些，空间分配担保是什么。"><a href="#如何判断死亡对象-GC-Roots-有哪些，空间分配担保是什么。" class="headerlink" title="如何判断死亡对象, GC Roots 有哪些，空间分配担保是什么。"></a>如何判断死亡对象, GC Roots 有哪些，空间分配担保是什么。</h3><pre><code class="hljs">虚拟机栈中引用对象本地方法栈中引用对象方法区中静态属性引用的对象方法区中常量引用的对象所有被同步持有的锁空间分配担保: Minor GC 之前, 老年代本身还有空间容纳新生代所有剩余对象</code></pre><h3 id="为什么要用分代收集"><a href="#为什么要用分代收集" class="headerlink" title="为什么要用分代收集"></a>为什么要用分代收集</h3><pre><code class="hljs">1. 大多数对象的存活时间比较短, 少数对象存活时间比较长, 可以减少GC 扫描的范围, 提升GC 的效率2. 不同年代的GC 算法采取不一样的, 年轻代 标记复制算法, 老年代, 标记清除 或者是标记整理</code></pre><h3 id="如果GC的时候内存不够分配怎么办"><a href="#如果GC的时候内存不够分配怎么办" class="headerlink" title="如果GC的时候内存不够分配怎么办"></a>如果GC的时候内存不够分配怎么办</h3><pre><code class="hljs">1. 如果年轻代和老年代都无法找到足够的空间, JVM 会触发一次full GC, 在full GC的过程中, JVM 会清理整个堆2. 如果在full GC 后仍然无法满足内存分配的请求, JVM 会抛出OOM 的异常, 表示堆内存已经耗尽, 无法分配新的对象-xms 设置初始堆的大小,-xmx 设置最大堆的大小-xx:newRation 设置年轻代和老年代的比例</code></pre><h3 id="GC-算法"><a href="#GC-算法" class="headerlink" title="GC 算法"></a>GC 算法</h3><pre><code class="hljs">1. 标记清除 老年代  1.1 从根对象出发, 遍历所有的可达对象  1.2 对可达对象进行标记  1.3 未被标记的对象属于不可达对象, 等待清除的对象  1.4 对不可达对象进行清除优点: 实现简单, 不需要移动对象缺点: 容易造成内存的碎片, 处理达对象困难    解决方式: 增加压缩, 称之为标记整理算法2. 标记复制新生代    将内存分为两部分, 每次使用其中的一部分, 当内存使用完后, 将存活的对象复制到另外一部分去    1. 将内存区域划分为From 区 和 To 区        1.1 From 区: 当前正在使用的区域, 存放正在使用的存活对象        1.2 To 区: 空闲的列表, 用于存放GC 存活时的对象    2. 从GCRoots 对象出发, 遍历所有的可达对象        2.1 标记From 区的存活对象, 确定在To 区的位置    3. 将From 区的对象复制到To 区, 在复制期间, 对象的地址会重新发生变化    4. 更新对象地址的引用    5. 清空From 区, 将From 区和To 区进行互换角色优点: 所有对象都整齐的放到新的区域上去, 不会产生内存碎片      新生代中对象生存时期比较短, 复制对象比较少, 效率高缺点: 对象内存浪费, 需要使用两个大小相同的内存区域, 实际每次只使用一半      每次收集的时候需要从一边复制到另外一边去, 会产生一定的开销3. 标记整理算法 老年代    标记过程和标记清除一样, 只是在回收对象的时候, 将对象移动到一侧, 然后直接去清理 </code></pre><h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><pre><code class="hljs">1. 初始标记    从 GCRoots 出发的直接可达性对象, 需要进行 STW, 2. 并发标记    在初始标记的基础上, 标记处内存中所有的可达性对象, 此时没有进行STW, 用户线程和GC 线程同时在运行.3. 重新标记    需要进行STW, 对并发标记遗漏的对象进行修正, 在并发标记起期间产生的不可达对象需要在下一次GC 周期才能被回收4. 并发清除    清除所有未被标记的对象, 进行对象回收, GC 线程和 用户线程同时在运行缺点:     1. 碎片化验证, 清除过程中不对内存进行压缩整理, 导致内存碎片话严重    1.1 影响: 碎片化严重, 可能会导致老年代无法分配达对象, 触发full GC    2. 浮动垃圾: 在并发标记期间产生的垃圾, 无法在当前GC周期被清除, 只能等到下一次GC    2.1 影响: GC 效果不如预期, 需要预留更多的内存空间    3. 某些情况下会退化成单线程回收    3.1 如果堆内存不足以支撑程序的内存分配, 进而出发一次Full GC    3.2 年轻代向老年代晋升, 如果老年代没有足够的空间去容纳这些对象的时候, 也会导致CMS 失败, 从而退化成单线程的Serial Old 收集器    3.3 空间碎片化, 由于 CMS 回收产生的碎片化, 导致大对象无法找到连续的内存进行分配, 最终触发full GC</code></pre><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><pre><code class="hljs">    其中-XX:G1NewSizePercent  新生代比列默认时5%    使用标记-整理算法1. 标记阶段    1. 初始标记    从GC Roots 出发, 标记直接可达的对象, 需要进行STW    2. 并发标记        从GCRoots 出发, 找出存活对象, 应用线程和GC线程是可以同时活动的,     3. 再标记        标记在并发标记时转移的对象2. 清理阶段        清点出有存活的对象和没有存活的对象3. 复制阶段    重新分配对象内存和复制成员变量, 转移的时候需要进行STW, 复制的耗时和存活对象的数量以及对象的复杂程度成正比   **初始标记**    标记从GC Roots 出发的可达对象 需要进行STW- **并发标记**    标记整个堆中的存活对象, 不会进行STW- **最终标记**    完成并发标记, 并且处理在并发标记期间导致应用对象的变化, 需要进行STW- **筛选回收**    确定进行回收, 并根据收集的数据区域进行回收- **拷贝回收**    将存活的对象从回收区拷贝到新的区块, 方便进行回收    特点:        region 管理, 每个区域可能是Eden 区, 也可能是Survivor区, 也可能是old区        并发标记和整理, 支持并发标记, 降低了STW         可预测的停顿时间        优先回收: 维护一个优先队列, 根据各个区域回收的价值(回收成本和收益) 决定哪些要优先回收    G1 怎么解决浮动垃圾:        将对分割成多个region, 更加灵活的去管理和回收内存, 降低浮动垃圾的影响        垃圾回收的时候, 可以进行并发标记和整理, 最大限度的降低程序的停顿</code></pre><h3 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h3><pre><code class="hljs">通过染色指针和读屏障技术解决了对象转移的问题, 从而降低了耗时    染色指针: 指针中存放了对象的一些信息, 例如对象是否被标记, 是否移动了, 相当于用空间换时间</code></pre><h3 id="什么时候触发yong-GC"><a href="#什么时候触发yong-GC" class="headerlink" title="什么时候触发yong GC"></a>什么时候触发yong GC</h3><pre><code class="hljs">1. 新对象申请内存的时候, eden区发现内存不足, 则触发yong gc, 如果yong gc 后还是不足, 则直接进入老年代分配, 老年代分配也不足, 触发full gc</code></pre><h1 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h1><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><pre><code class="hljs">本质上是一个继承了annotation 的特殊接口</code></pre><h2 id="IOC-和-AOP"><a href="#IOC-和-AOP" class="headerlink" title="IOC 和 AOP"></a>IOC 和 AOP</h2><pre><code class="hljs">1. IOC:  核心是将对象的创建和依赖关系的管理交给 Spring 容器来处理, 开发者无需手动去创建或者管理对象, spring 的IOC 通过DI (依赖注入) 来实现  DI: Spring 容器会自动将对象的依赖注入给他们, 依赖注入可以通过 构造起注入, setter 方法注入, 或者字段注入2. AOP:    面向切面编程, 在允许不修改业务逻辑情况下, 通过定义好的切面, 将一些通用的功能模块化并动态的应用到业务逻辑中    AOP 概念:        Aspect: 代表了通用逻辑的模块化单位        Join point: 指程序执行的过程中, 某个可插入切面的执行点, 通常是方法或者是对象的创建        Advice: 通知            Before: 在目标方法执行之前            After: 在目标方法执行之后            Around: 包裹目标方法执行            AfterReturning: 目标方法成功执行后执行            AfterThrowing: 目标方法异常执行后执行    IOC 指的是控制反转, 将对象的创建和管理委托给spring容器, 而不是直接有应用程序代码直接控制    AOP 指的是允许不修改代码的情况下, 方便的添加或者修改横切关注点    AOP 一般通过动态代理来进行实现        jdk 自身的动态代理: 基于java 的反射来进行实现的        cglib </code></pre><h2 id="springBoot-的自动装配"><a href="#springBoot-的自动装配" class="headerlink" title="springBoot 的自动装配"></a>springBoot 的自动装配</h2><pre><code class="hljs">1. 通过注解或者是一些简单的配置就能在spring boot 的帮助下实现某块功能, 2. @EnableAutoConfiguration: 启用springBoot的自动配置机制, 通过AutoConfigurationImportSelector 来实现的     @Configuration     @ComponentScan</code></pre><h2 id="spring-注解的依赖"><a href="#spring-注解的依赖" class="headerlink" title="spring 注解的依赖"></a>spring 注解的依赖</h2><pre><code class="hljs">需要实现的bean 接口如下: BeanPostProcessor, ApplicationContextAware, BeanClassLoaderAware    BeanPostProcessor 允许实例化之后以及bean 初始化方法之前调用    ApplicationContextAware  在初始化的时候获取到Spring 上下文的引用, 从而可以访问容器中其他的bean或者执行的相关操作,    BeanClassLoaderAware 提供classLoader的访问能力, 使得bean 可以动态加载资源    BeanClassLoaderAware -&gt; ApplicationContextAware -&gt; PropertyPlaceholderConfigurer -&gt; BeanPostProcessor</code></pre><h2 id="bean-生命周期"><a href="#bean-生命周期" class="headerlink" title="bean 生命周期"></a>bean 生命周期</h2><pre><code class="hljs">实例化: 根据@Configuration 或者是扫描到的@Component 等注解识别需要实例化的bean, 通过反射去调用无参构造函数去进行实例化依赖注入: 将属性设置到实例化对象中Aware 接口处理: 如果实现了beanNameAware 则调用setName 传递bean 名称, 实现BeanFactoryAware 则调用setBeanFactory, 实现ApplicationContextAware 则调用setApplicationContext 传递ApplicationContextBeanPostProcessor 中的 postProcessBeforeInitialization初始化: @PostConstruct 会调用初始化后的一些行为,  如果接口实现了 InitializingBean 的 afterPropertiesSet, 则会调用afterPropertiesSetBeanPostProcessor 中的 postProcessAfterInitialization准备就绪, 可以准备使用bean 的销毁</code></pre><h2 id="spring-如何解决循环以来的问题"><a href="#spring-如何解决循环以来的问题" class="headerlink" title="spring 如何解决循环以来的问题"></a>spring 如何解决循环以来的问题</h2><pre><code class="hljs">1. 通过三级缓存来处理    1.1 一级缓存: 存储已经完全出时候的单例bean    1.2 二级缓存: 用于存储正在创建的bean 的早期引用, 防止重复创建bean    1.3 三级缓存: 用于存储尚未完全创建的bean 的工厂对象, 通过这个工厂对象可以获取bean 的早期引用    具体创建过程        创建bean a: spring 创建 bean a, 先把他放到三级缓存中, 表示a 处理创建过程中, 但是还没有完全初始化        创建bean b: 创建a的时候发现依赖于b, 创建 bean b, 并放到三级缓存中        创建bean b 的时候发现依赖于a, 于是检查缓存中是否有a, 发现a 还没有完全初始化, 但是存在a 的早期引用, 将早期引用放到b 中, 继续创建b        bean b 创建完成, 将b 从三级缓存放到一级缓存, 表示完全初始化, 回到bean a, 完成a 的初始化, 放到一级缓存2. @lazy    表示bean 只需要在使用的时候才进行创建</code></pre><h2 id="spring-事物什么时候会失效"><a href="#spring-事物什么时候会失效" class="headerlink" title="spring 事物什么时候会失效"></a>spring 事物什么时候会失效</h2><pre><code class="hljs">1. 确保所有使用@Transaction 的是 public 方法, 改成public2. 一个类中的方法调用另外一个方法时会失效, 因为AOP 是通过代理类来的, 放到另外一个类中3. 没有通过代理类出来的, 手动创建一个对象的, 而不是通过spring 的bean调用的    // 错误的调用方式，事务不会生效    MyService service = new MyService();    service.method();</code></pre><h2 id="spring-事物的传播机制"><a href="#spring-事物的传播机制" class="headerlink" title="spring 事物的传播机制"></a>spring 事物的传播机制</h2><pre><code class="hljs">1. REQUIRED(默认的)    当前存在一个事物, 则加入该事物, 当前没有事物, 则创建一个新的事物, 如果一个方法回滚, 则整个事物会滚2. SUPPORTS    如果当前有事物, 则以事物的方式进行加入, 如果当前没有事物, 则以非事物的方式继续运行3. REQUIRES_NEW 表示新开一个事物, 将当前事物进行挂起4. NOT_SUPPORTED: 以非事物的方式运行, 将当前事物挂起REQUIRED（默认）：加入当前事务，如果没有则创建一个新的事务。REQUIRES_NEW：总是创建一个新的事务，暂停当前的事务。NESTED：创建一个嵌套事务，在当前事务的上下文中运行，但具有独立的提交点。SUPPORTS：支持当前事务，如果没有则不使用事务。NOT_SUPPORTED：不使用事务，挂起当前事务。NEVER：不允许当前存在事务，如果有事务则抛出异常。MANDATORY：必须在已有事务中运行，如果没有事务则抛出异常</code></pre><h2 id="FactoryBean-和-BeanFactory-区别"><a href="#FactoryBean-和-BeanFactory-区别" class="headerlink" title="FactoryBean 和 BeanFactory 区别"></a>FactoryBean 和 BeanFactory 区别</h2><pre><code class="hljs">1. BeanFactory    定义: 是Spring 容器最基础的接口， 负责创建、管理、获取 spring 的beans， 他是IOC 容器的核心接口, 提供getBean 来获取容器中的bean2. factoryBean    定义: 是一个接口, 允许用户自定义创建复杂的bean, 本质上是一个用于生产bean 的工厂类， FactoryBean 自身也是一个spring 容器管理的bean     工作原理:        当Spring 容器加载FactoryBean 时, 他会调用getObject 方法返回真正的bean, 而不是FactoryBean 本身,         如果要获得FactoryBean 则可以在getBean 的时候加上&amp; 符号        MyFactoryBean factoryBean = (MyFactoryBean) factory.getBean(&quot;&amp;myFactoryBean&quot;);</code></pre><table><thead><tr><th><strong>特性</strong></th><th><strong>BeanFactory</strong></th><th><strong>FactoryBean</strong></th></tr></thead><tbody><tr><td><strong>作用</strong></td><td>Spring IoC 容器的核心接口，用于管理和获取 beans</td><td>用于自定义复杂对象的创建逻辑</td></tr><tr><td><strong>职责</strong></td><td>提供依赖注入、bean 生命周期管理等核心功能</td><td>定制复杂 bean 的创建，返回自定义对象</td></tr><tr><td><strong>常见实现</strong></td><td>ApplicationContext、XmlBeanFactory（已过时）</td><td>需要用户实现 FactoryBean 接口</td></tr><tr><td><strong>获取 bean</strong></td><td>直接通过 getBean() 获取 Spring 管理的 bean</td><td>调用 getObject() 方法来返回具体的 bean</td></tr><tr><td><strong>获取本身</strong></td><td>无法获取自身，getBean() 返回的是 bean</td><td>可通过 &amp; 前缀获取 FactoryBean 本身</td></tr><tr><td><strong>使用场景</strong></td><td>Spring 容器的核心，适用于所有 bean 管理</td><td>适用于需要复杂创建逻辑的 bean，例如代理对象、连接池</td></tr></tbody></table><h2 id="事物是否回滚"><a href="#事物是否回滚" class="headerlink" title="事物是否回滚"></a>事物是否回滚</h2><pre><code class="hljs">1. 默认遇到RuntimeException 或者是Error 的时候进行回滚</code></pre><h2 id="springBoot-提供出来的扩展点有哪些"><a href="#springBoot-提供出来的扩展点有哪些" class="headerlink" title="springBoot 提供出来的扩展点有哪些"></a>springBoot 提供出来的扩展点有哪些</h2><pre><code class="hljs">1. ApplicationContextInitializer    可以在spring 应用程序上下文刷新之前进行配置, 可以获取到Environment的信息2. 从spring 容器中获取到bean 对象    2.1 FactoryBean: beanFactory 是bean 工厂, factoryBean 是一种bean 的类型, 当容器注入的class 类型是FactoryBean 类型的时候, 最终生成bean 是通过FactoryBean 的getObject 获取到的3. 实现自定义的HandlerInterceptor 拦截器4. ApplicationContextAware 获取bean 对象5. ApplicationListener 监听事件的6. BeanPostProcessor bean 初始化前后做一些事情    </code></pre><h2 id="Autowired和-Resource"><a href="#Autowired和-Resource" class="headerlink" title="@Autowired和@Resource"></a>@Autowired和@Resource</h2><pre><code class="hljs">相同点:     都可以作为属性注入修饰, 在接口只有单一实现类的时候, 两个注解的修饰情况相同不同点:     1. @Resource 是jdk 原生的, @Autowired 是spring 引入的注解    2. @Autowired 默认按照byType 自动配置,(优先根据接口类型去匹配并注入bean)         @Resource 是byName 进行配置的 (优先根据bean 的名字去进行匹配, 例如类名)        当一个接口有多个类的时候, @Autowired 和 @Resource 都是需要通过名称才可以正确匹配到对应的name, @Autowired 可以通过@Qualified 来进行显示制定, @Resource 可以通过name 进行显示制定    3. @Autowired 支持在构造函数、方法、字段、和参数上进行使用, @Resource 主要用于字段和方法上的注入, 不支持在构造函数或者是参数上进行使用</code></pre><h1 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h1><h2 id="ZK"><a href="#ZK" class="headerlink" title="ZK"></a>ZK</h2><h3 id="zk-投票过程"><a href="#zk-投票过程" class="headerlink" title="zk 投票过程"></a>zk 投票过程</h3><pre><code class="hljs">投票采用paxos 算法实现1. epoch 候选者的zxId(事物日志的id) 越大说明数据越新, 2. zxId 相同比较epoch, epoch 相同比较服务器id3. 服务器选票过半的成为leader1. 节点分类leader: 主节点，负责处理写请求，并将事务日志同步到从节点flower: 从节点，接收 Leader 的同步数据，并参与读请求。observer: 观察者节点，不参与选举和投票，但接收 Leader 的同步数据。2. 选举算法    Fast Leader Election 参考的点: zxid, myId, 当前数据的完整度和 机器的优先级</code></pre><h3 id="zk-选举过程"><a href="#zk-选举过程" class="headerlink" title="zk 选举过程"></a>zk 选举过程</h3><pre><code class="hljs">重新选举的算法:zk 集群进入不可用的时候, 会重新发起选举, 选举过程如下:1. 每个节点重新发起投票, 投票的信息包含有ZXID, 服务器的id, zxid 代表该节点处理最新事物的id, id 越大代表处理的数据越新,     1.1 节点优先选择最新的zxID 做为leader,    1.2 leader 相同的情况下选择 更大的服务器id2. 每个节点收到其他节点的投票后, 将其与当前的投票进行比较, 如果接受到的投票比自己当前的投票更好, 具体比较过程参照zxId和 服务器id, 则更新自己的投票并重新广播3. 每个节点投票获得超过半数后, 则该节点成为新的leader, 其他节点通过他进行同步数据4. 新的leader 确定后, 进行数据同步</code></pre><h3 id="zk-脑裂"><a href="#zk-脑裂" class="headerlink" title="zk 脑裂"></a>zk 脑裂</h3><pre><code class="hljs">如何解决ZK 脑裂问题    1. 确保奇数个节点    2. 网络分区的监控和恢复    3. 启用Observer 节点    4. 事物的日志和快照定期备份    5. Quorums: 当集群中存活节点少于法定人数的时候, 集群不可用    6. 冗余通信</code></pre><h3 id="zk-写数据的过程"><a href="#zk-写数据的过程" class="headerlink" title="zk 写数据的过程"></a>zk 写数据的过程</h3><pre><code class="hljs">1. 客户端发起写的操作, 这个操作只能到leader 节点上去2. leader 收到写请求后, 会生成一个zxId, 通知zxId 是递增的3. leader 会将zxId 封装成一个propersal 进行广播, 基于zab 协议,确保所有flower 接收到4. flower 接受propersal 并进行ACK 响应5. leader 接受ACK, 过半就可以持久化写入6. leader 进行commit, 并通知所有的flower7. flower 收到leader 的commit 后并对自己进行刷新8. leader 确认写完成后并通知客户端通过写请求只能leader 处理、zxId 是递增的、zab 协议来实现一致性P 的话通过法定人数, 过半节点</code></pre><h3 id="zk-如何保证数据一致性"><a href="#zk-如何保证数据一致性" class="headerlink" title="zk 如何保证数据一致性"></a>zk 如何保证数据一致性</h3><pre><code class="hljs">zk 写数据的时候通过zab 协议来保证的</code></pre><h3 id="zk-机器数量为啥是奇数"><a href="#zk-机器数量为啥是奇数" class="headerlink" title="zk 机器数量为啥是奇数"></a>zk 机器数量为啥是奇数</h3><pre><code class="hljs">因为奇数台机器和偶数台机器的容忍度是一样的. 为了防止增加不必要的机器. 因此最好是奇数台</code></pre><h3 id="zab-协议"><a href="#zab-协议" class="headerlink" title="zab 协议"></a>zab 协议</h3><pre><code class="hljs">全局顺序一致性、原子广播(事物要么在集群的所有副本上提交成功, 要么在所有副本上提交失败)、崩溃恢复(当主节点出现宕机事件, 可以快速选举出新的主节点, 并从奔溃点恢复数据)消息广播阶段:    leader 负责接收客户端的请求, 并将请求做为 Proposal 向所有的 flower 进行广播        1. leader 发送 proposal , leader 收到请求后, 会生成一个 proposal 并将其广播给所有的 flower         2. flower 收到 leader 发过来的 proposal 后, 先写入本地事物, 写入成功后向 leader 发送 ack 确认        3. leader 收到大多数flower 的ack 后, 向所有的 flower 发送 commit 消息        4. flower 收到 commit 消息后, flower 提交该事物并对外提供读物服务    保证事物提交顺序的一致性奔溃恢复阶段:    当leader 发生奔溃的时候, 重新选举        1. 根据数据的日志、myId 选出一个新的leader. 当新的leader 被选举出来以后, 其他flower 通过新leader 来同步数据</code></pre><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><h3 id="eureka-数据同步过程"><a href="#eureka-数据同步过程" class="headerlink" title="eureka 数据同步过程"></a>eureka 数据同步过程</h3><pre><code class="hljs">1. 多节点部署与复制eureka 集群中的各个节点会相互的同步注册信息和服务信息2. 服务注册和同步的流程1. 服务注册过程: 微服务向eureka 节点发送注册请求2. 增量同步    1. 服务注册的时候, 当一个服务实例向其中一个eureka 节点进行注册, 对应的eureka 节点会将该实例信息同步给其他的eureka 节点    2. 服务续约. 服务节点定时给eureka 进行心跳请求续约, 每次续约都会触发增量同步    3. 服务下线.     4. 服务状态变更    2.1 实现方式:        通过增量队列来实现的, 当有节点注册、续约、下线、状态变化的时候, 会放到增量队列中,eureka 会定时从增量队列中获取数据, 将需要同步的数据发送给其他节点, 其中防止很长时间都没有被同步, 增量队列中需要携带上时间戳, 可以用来进行触发全量同步    自我保护机制, 设置成一个阈值可以判断时因为节点异常了,    具体case        服务实例向节点 A 注册，A 将该变更添加到自己的增量队列中。        节点 A 定期检查增量队列，发现有新注册的服务实例。        节点 A 通过增量同步的 API /eureka/v2/apps/delta，将该变更同步给节点 B。        节点 B 接收到增量信息后，更新其本地的注册表，保持与节点 A 的数据一致性。3. 全量同步    3.1 节点重启: 当有一个节点重启了    3.2 增量同步失败: 由于增量同步出现异常, 节点之间注册信息不一致, 触发全量同步. 增量同步失败的原因可能因为网络故障、超时、抖动等    3.3 数据检测不一致: 节点会去定时检测其他节点信息和注册表中的数据是否一致, 发现有不一致的, 并且增量失败    3.4 全量同步过程:        3.4.1 节点向其他节点发送全量同步请求        3.4.2 接受其他节点的全量注册信息,         3.4.3 将全量节点更新到本地        3.4.4 恢复正常4. 新的节点起来以后怎么做的数据同步    全量同步5. 如何通知给服务的消费方    5.1 客户端通过定时拉的方式获取,初次时进行全量拉取, 后面是进行增量拉取    5.2 拉增量失败后, 会触发拉取全量的    5.3 当服务器进入到自我保护机制时, 拉取到的数据可能是旧的</code></pre><h3 id="如何解决eureka-问题-当客户端很多的时候怎么处理-hash-环-虚拟节点"><a href="#如何解决eureka-问题-当客户端很多的时候怎么处理-hash-环-虚拟节点" class="headerlink" title="如何解决eureka 问题: 当客户端很多的时候怎么处理, hash 环 + 虚拟节点"></a>如何解决eureka 问题: 当客户端很多的时候怎么处理, hash 环 + 虚拟节点</h3><pre><code class="hljs">如何做到注册方的上下线, 秒级别推送:  基于WS 或者是长轮训      WS:          1. 服务消费方在初始化过程中，会先经Session域名查询Session的IP地址列表并缓存到本地，然后再从列表中选择一台Session服务器与之建立 WebSocket长连接，并发送服务订阅请求。          2. Session在收到服务订阅请求后，先会将服务订阅信息和 WebSocket 连接的映射关系存储到本地。后续当Session收到Data推送的服务变更消息时，它会先从上述映射关系中查询该服务对应的变更订阅方（即对应的WebSocket 连接列表），然后将消息通过这些连接推送出去。          3. 在收到服务变更消息后，服务消费方会根据消息的内容更新本地缓存中的服务地址列表  上下线的时候, data 节点通知所有的session 节点</code></pre><h2 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h2><pre><code class="hljs">1. 通过WAN Gossip 协议 解决多数据中心的问题WAN Gossip 协议: 通过随机选择节点进行数据交换, 但是传播速度比较慢, 节点可能会有重复的数据通信,</code></pre><h2 id="注册中心发布怎么解决"><a href="#注册中心发布怎么解决" class="headerlink" title="注册中心发布怎么解决"></a>注册中心发布怎么解决</h2><pre><code class="hljs">一是关闭/启动应用程序前，先拉出服务实例，程序启动成功后，再拉入服务实例；二是客户端负载均衡自动拉出访问异常服务实例。</code></pre><h1 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h1><h2 id="Netty-的一次网络请求过程是什么"><a href="#Netty-的一次网络请求过程是什么" class="headerlink" title="Netty 的一次网络请求过程是什么"></a>Netty 的一次网络请求过程是什么</h2><pre><code class="hljs">服务端    初始化阶段        创建EventLoopGroup, bossGroup 和 workerGroup, bossGroup 负责接受请求, workerGroup 负责处理 BossGroup 分配过来的IO 操作        配置 serverBootstrap : 使用 ServerBootstrap 来配置 Netty 服务, 包括 channel 的类型, 指定 EventLoopGroup, 配置 channelPipeline , 以及设置服务器的监听端口    绑定端口        serverBootStrap.bind() 方法绑定服务器的监听端口, 会启动一个异步操作过程, bossGroup 中的线程会监听这个连接请求        bind() 返回一个future, 可以通过sync()  或者是addListener 来等待响应    接受客户端请求        bossGroup 中的线程会去监听端口的连接请求, 当有新的请求进来的时候, Netty会为这个连接创建一个channel, 并将其分配给worker 的EventLoop上,        注册channel: 新的channel 会被注册在worker Group 中的eventLoop 上, 接下来和这个连接的相关读写操作都是在这个EventLoop 上    处理客户端请求        每个channel 关联的channelpipeline, 包含了一系列的handler        当客户数据到达的时候, 数据会通过channelPipeline 中的inbounder 来进行处理, 负责数据的读取, 解码，业务逻辑处理等    响应客户端        当业务逻辑处理完后, 通过会通过ChannelHandlerContext.writeAndFlush() 将数据响应回给客户端        数据会通过channelpipeline 中的outbounder，然后通过底层的socket 发送给客户端    关闭连接        客户端关闭连接, 或者是服务端主动关闭连接的时候, Netty 会处发ChannelInbounderHandler 的channelInactive 或者是channelUnregistered, 可以进行资源清理        在关闭服务器的时候, 需要调用bossGroup 和worker Group 的shutdownGracefully 进行线程资源的释放客户端    初始化:        EventLoopGroup 的创建, 用于管理和服务之间网络链接和IO 操作, Bootstrap 配置客户端的各种参数, 包括线程模型, NioSocketChannel, 远端服务器的地址, 以及客户端的handler    建立链接        连接服务器: 通过Bootstrap.connect() 方法启动连接过程, 链接成功后会将channel 注册到event loop 上        等待建立连接完成:  connect() 返回一个ChannelFuture, 可以通过sync() 或者是addListener 进行完成    发送请求        构造数据进行请求, 连接成功后, 通过channel 向服务器发送数据, 通常是将请求封装成 ByteBuf         对数据进行writeAndFlush 写数据, 数据会通过ChannelPipeline 的outbounder 进行处理, 通过底层的socket 发送到服务器    接收响应        pipeline 处理, 当服务器响应数据到的时候, 数据会到channelHander 的inbounder,        处理响应数据: 业务逻辑进行处理, 处理完后返回给应用层    关闭连接        主动关闭连接: channel.close 关闭连接, 释放资源        监听关闭操作: close 返回的future 进行监听, 进行监听关闭是否成功。    资源清理        group.shutDownGracefully() 进行清理</code></pre><h2 id="Channel-的作用"><a href="#Channel-的作用" class="headerlink" title="Channel 的作用"></a>Channel 的作用</h2><pre><code class="hljs">负责网络IO操作相关的    1.1 管理IO 操作        对数据读取、发送、和连接的管理    1.2 处理事件        从网络传输到channelPipeline, 将channelPipeline 处理后的数据返回到网络中去    1.3 支持异步IO        即将数据异步写入到网络中,不会阻塞当前线程</code></pre><h2 id="EventLoop-作用"><a href="#EventLoop-作用" class="headerlink" title="EventLoop 作用"></a>EventLoop 作用</h2><pre><code class="hljs">1.每一个EventLoop 维护着一个 Selector 和 线程2.处理IO 事件和任务    监视和处理IO事件, 基于Java NIO 的selector 事件3. 任务的调度    还可以管理定时任务和普通任务, 可以提交任务到eventLoop上, 按照顺序和指定周期执行4. 线程管理    一个eventLoop通常和一个线程绑定, 每个eventLoop 可以维护多个channel, 但一个channel 始终绑定在一个eventLoop 上, 确保了同一个channel 上的事件处理是线程安全的5. 事件的派发与处理    负责从IO操作中获取事件, 将这些事件派发到对应的ChannelHandler中, 每个channel 代表一个连接或者IO操作, 在其pipeline中的一系列处理</code></pre><h3 id="EventLoop-执行的流程"><a href="#EventLoop-执行的流程" class="headerlink" title="EventLoop 执行的流程"></a>EventLoop 执行的流程</h3><pre><code class="hljs">1. eventLoop 的线程模型    由eventLoopGroup 管理,  他是一个单线程的执行器, 专门处理IO任务,     每个channel 都绑定了一个固定的eventLoop, 从创建到关闭期间一直由该eventLoop 负责处理    EventLoopGroup 有多个eventLoop 实例构成, 但是一个eventLoop 始终对应一个线程, 线程是复用的2. selector 机制    eventLoop 的核心任务是事件循环, 通过不断的轮训selector, 检查是否有IO 事件, 如果有事件发生, 则eventLoop 会将事件分发给channel 对应的pipeline 进行处理3. 任务队列    可以用于任务的提交与处理4. channelPipeline 和 channelHandler 处理    当eventLoop 轮训到IO事件的时候, 通过 channelPipeline 来传递这些事件, 其中channelPipeline 是一组 channelHandler 组成5. 任务调度机制    eventLoop 可以处理定时调度任务, 类似于schedule 的任务    任务在eventLoop 中的任务队列中管理, eventLoop 定期检查是否有任务6. eventLoop 的执行流程    1. 选择IO事件: 通过 Selecor.slect() 阻塞,  等待IO事件, 如果有事件触发, 进行下一步    2. 处理IO 事件: 将事件触发分发到对应的 channelPipeline , 交给注册的 channelHandler 来处理    3. 执行任务队列中的任务: 处理完IO 事件后, 从任务队列中获取任务并执行,     4. 继续轮训IO: 完成任务后继续进入selecot.select()轮训, 等待事件</code></pre><h3 id="Selecor-机制"><a href="#Selecor-机制" class="headerlink" title="Selecor 机制"></a>Selecor 机制</h3><pre><code class="hljs">Selecor: 可以用来检测 channel 是否准备好进行 IO 操作的对象, 通过 Selecor , 一个线程可以管理多个 Channel Channel: 代表一个 IO 连接SelectionKey: 记录 Channel 在  Selector 上的注册状态, 包含事件类型事件类型:     OP_ACCEPT: 接受连接就绪    OP_CONNECT: 连接完成    OP_READ: 读操作完成    OP_WRITE: 写操作就绪工作机制:    注册 Channel , 将channel 注册到 Selector 上, 告诉我们关联的事件类型,  每个注册的 channel 会关联一个 channelKey, 标识该channel 的状态    选择IO事件: 在调用Selector.select() 的时候, 同步等待 Selector 准备好的Channel， 进行响应的 IO  操作,     处理就绪的Channel:  当Selecotor 检测到某个 Channel 有事件准备好的时候, 返回关联的 selectionKey, 通过selectionKey 进行对应的IO 操作    清理处理过的事件优缺点:    优点: 一个线程可以管理多个Channel, 减少线程的上下文切换                Selector 可以避免 BIO , 提供性能                支持大规模并发连接    缺点:        空轮训问题netty 利用Selector 机制来监听网络IO 事件, eventLoop 负责调用 Selector.select() 方法获取注册的 Channel, 根据事件触发 netty 的channelHandler 来进行处理, eventLoopGroup 会处理大量的并发连接, 每个eventLoop 在一个线程中运行, 不同的channel 分配到不同的EventLoop 上netty 怎么解决空轮训问题    1. 监测selector 是否进入空轮训, 默认是512, 如果发现 selector 轮训多次没有返回任何事件, 任务可能出现空轮训, 销毁并创建新的Selector, 避免空轮训CPU 过高    2. 通过设置合理的超时时间</code></pre><h2 id="EventLoopGroup-作用"><a href="#EventLoopGroup-作用" class="headerlink" title="EventLoopGroup 作用"></a>EventLoopGroup 作用</h2><pre><code class="hljs">用于管理所有的EventLoop, 一个 EventLoopGroup 用于管理多个线程来并发去处理执行IO 事件</code></pre><p>Channel 是网络通信的管道, 负责实际数据的读写, EventLoop 是负载驱动Channel 的 执行, 通过循环监听IO 事件来处理这些事件, EventLoopGroup 是多个EventLoop 的管理着, 负责分配和管理多个EventLoop, 并支持多并发处理多个Channel</p><h2 id="常见参数"><a href="#常见参数" class="headerlink" title="常见参数"></a>常见参数</h2><pre><code class="hljs">.option(ChannelOption.SO_REUSEADDR, Boolean.TRUE)           - **用途**: 允许重用本地地址和端口。           - **适用场景**: 服务器端 `ServerSocketChannel`。           - **解释**:              - `SO_REUSEADDR` 允许多个 `Socket` 绑定到同一个地址和端口。通常用于服务器重启时避免“地址已占用”的错误。             - `SO_REUSEPORT`（在一些平台支持）允许多个进程绑定到同一个端口，帮助实现负载均衡。           - **默认值**: `false`。.option(ChannelOption.ALLOCATOR, ByteBufManager.byteBufAllocator)       - **用途**: 设置 ByteBuf 的分配器（`ByteBufAllocator`）。       - **适用场景**: 服务器端和客户端。       - **解释**:          - Netty 提供了 `PooledByteBufAllocator` 和 `UnpooledByteBufAllocator` 两种分配器。`PooledByteBufAllocator` 使用内存池，适合高性能场景；`UnpooledByteBufAllocator` 则每次分配新的缓冲区，适合短连接或对内存要求不高的场景。       - **默认值**: `PooledByteBufAllocator`。.childOption(ChannelOption.SO_KEEPALIVE, Boolean.TRUE)       - **用途**: 启用 TCP 保活机制。       - **适用场景**: 适用于客户端和服务器端的 `SocketChannel`。       - **解释**:          - 如果启用 `SO_KEEPALIVE`，TCP 会定期发送保活包，检查连接是否还保持有效。适用于长连接的应用程序，确保连接在无数据传输时不会无故断开。       - **默认值**: `false`（禁用保活）。.childOption(ChannelOption.TCP_NODELAY, Boolean.TRUE)       - **用途**: 启用或禁用 Nagle 算法。       - **适用场景**: 用于客户端和服务器端的 `SocketChannel`。       - **解释**:          - Nagle 算法通过合并小的数据包来减少网络拥塞。如果应用程序需要低延迟通信（如实时应用），可以将 `TCP_NODELAY` 设置为 `true`，禁用 Nagle 算法，使得数据尽快发送。       - **默认值**: `false`（启用 Nagle 算法）。.childOption(ChannelOption.ALLOCATOR, ByteBufManager.byteBufAllocator)       - **用途**: 设置 ByteBuf 的分配器（`ByteBufAllocator`）。       - **适用场景**: 服务器端和客户端。       - **解释**:          - Netty 提供了 `PooledByteBufAllocator` 和 `UnpooledByteBufAllocator` 两种分配器。`PooledByteBufAllocator` 使用内存池，适合高性能场景；`UnpooledByteBufAllocator` 则每次分配新的缓冲区，适合短连接或对内存要求不高的场景。       - **默认值**: `PooledByteBufAllocator`。</code></pre><h2 id="如何实现零拷贝"><a href="#如何实现零拷贝" class="headerlink" title="如何实现零拷贝"></a>如何实现零拷贝</h2><h3 id="什么是零拷贝"><a href="#什么是零拷贝" class="headerlink" title="什么是零拷贝"></a>什么是零拷贝</h3><pre><code class="hljs">零拷贝指的是全程不需要CPU 进行参与, 所有数据都是通过DMA来进行传输的    传统的:        4次上下文切换, 4 次 拷贝            用户态发起读文件, 一次是写文件. 每次读写都是用户态切换到内核态, 内核完成后, 再从内核台切换为用户态            2 次 CPU 拷贝, 2 次 DMA 拷贝            第一次拷贝: 把磁盘中的数据拷贝到操作系统的内核缓冲区中, 通过DMA来操作            第二次拷贝: 把内核缓冲区的数据拷贝到用户缓冲区中, 此时用户可以使用这部分数据, 通过CPU 拷贝来完成            第三次拷贝: 把刚刚拷贝过来的数据, 再拷贝到内核缓冲区, 通过CPU 拷贝来操作            第四次拷贝: 把内核缓冲区数据 拷贝到网卡的缓冲区中, 通过DMA 来操作的    mmap        4 次上下文切换, 2次拷贝        应用进程调用 mmap 的时候, DMA 会把磁盘中的数据拷贝到内核缓冲区中, 此时应用进程和操作系统进程共享这个缓冲区        应用进程调用write 的时候, 操作系统直接将内核缓冲区中的数据拷贝到socket 缓冲区中。        最后可以通过DMA 将内核缓冲区数据拷贝到网卡缓冲区中        4 次上下文切换, 3 次拷贝    sendFile        sendFile 可以直接代替read 和 write, 减少1次系统调用, 2次上下文切换        全程只需要2次上下文切换, 2次SG-DMA数据copy</code></pre><h3 id="netty-如何实现零拷贝"><a href="#netty-如何实现零拷贝" class="headerlink" title="netty 如何实现零拷贝"></a>netty 如何实现零拷贝</h3><pre><code class="hljs">1. Fileregion 的sendFile    sendFile 在内核中支持完成数据直接从硬盘中传输到网卡中, 不需要将数据拷贝到用户空间态。避免了数据的来回拷贝2. ByteBuf 的直接内存 DirectBuf     DirectBuf 是分配在堆外的, 数据可以直接在内核态和直接内存进行传输， 避免了堆上的拷贝, 堆外的DirectByteBuf 通过JNI访问, 数据不需要先拷贝到JVM 的堆内存上, 直接操作操作系统, 在进行IO的时候, 可以减少一次内存拷贝3. composite Buffer    通过CompositeByteBuf, 可以将多个不同的ByteBuf 组合成一个逻辑上的ByteBuf, 而不会进行数据拷贝, 每个子的ByteBuf 保持独立的内存空间。 4. Sokcet 缓冲    在网络IO的时候, 避免将数据直接从操作系统的socket 缓冲区拷贝到用户空间, 而是直接引用缓冲区数据操作5. mmap 内存映射    通过mmap 将文件映射到内存, 从而避免文件读写下的多次数据拷贝</code></pre><h2 id="为什么需要将网络容器从tomcat-换成Netty"><a href="#为什么需要将网络容器从tomcat-换成Netty" class="headerlink" title="为什么需要将网络容器从tomcat 换成Netty"></a>为什么需要将网络容器从tomcat 换成Netty</h2><pre><code class="hljs">1. 从业务角度去看: 请求流量高的时候, 2C 和 2B 的流量有影响2. 解决方案上怎么去排查vmstat 1/proc/stat top 等可以判断进程啥下文切换可以检测上下文切换是否很高,1. 实现机制上:     serverlet 通过 startAsync 本质上依赖线程池去进行处理, netty天生为异步非阻塞的, 使用事件驱动的方式, 每个EventLoop 可以处理多个IO操作事件,可以极大的降低了线程数和线程切换的开销2. 线程模型:    serverlet 3.0异步依赖容器的线程管理, 在并发增加的情况下可能会导致线程的耗尽; netty 中使用少量的worker 线程来处理事件, 减少了上下文的切换, 避免了传统线程池模型的问题.3. IO 模型    serverlet 3.0 虽然支持异步处理, 但是底层依赖于阻塞IO模型; netty 使用java NIO 的非阻塞式, 从底层上确保了高并发表现的性能4. 并发高的情况下 tomcat 由于采用的是BIO 加上异步线程的方式去处理的, 会有大量的线程产生, CPU 内存 文件描述符都会发生资源竞争，netty 是通过NIO 方式去做的，使用少量的worker 线程就可以去处理</code></pre><h2 id="tomcat-通过startAsync-来实现线程的切换"><a href="#tomcat-通过startAsync-来实现线程的切换" class="headerlink" title="tomcat 通过startAsync 来实现线程的切换"></a>tomcat 通过startAsync 来实现线程的切换</h2><pre><code class="hljs">1. 通过startAsync 开启异步, 并生成一个 AsyncContext 的对象2. 调用后, tomcat 会释放当前的线程资源, 将请求挂起, 此时客户端的连接仍然保持打开, 但是占用tomcat 的资源3. 等待后台任务完成或者超时后, 会通过线程池去进行处理</code></pre><h3 id="tomcat-通过startAsync-和-netty-的区别"><a href="#tomcat-通过startAsync-和-netty-的区别" class="headerlink" title="tomcat 通过startAsync 和 netty 的区别"></a>tomcat 通过startAsync 和 netty 的区别</h3><pre><code class="hljs">从架构和模型上    1. tomcat 是基于 servlet 规范来做的, 虽然是基于NIO去做了, 但是依赖于传统的阻塞IO     2. netty 支持异步非阻塞的处理请求从线程管理上    1. 使用固定的线程池来处理, startAsync 通过启动新的线程来处理异步任务, 但是还是依赖于 servlet 容器管理的线程    2. netty 通过使用 eventLoop 和 workGroup 的worker 线程进行管理, 可以处理大量的并发连接.异步处理方式上    1. tomcat 通过startAsync 时需要手动去管理异步的上下文, 适用于 servlet API 约定的方式    2. netty 是基于异步非阻塞的, 所有的 IO 都是异步的, 用户可以通过使用回掉或者是future 机制处理结果</code></pre><h3 id="serverlet-和-reactor-对比有什么缺点"><a href="#serverlet-和-reactor-对比有什么缺点" class="headerlink" title="serverlet 和 reactor 对比有什么缺点"></a>serverlet 和 reactor 对比有什么缺点</h3><pre><code class="hljs">1. servlet 是阻塞式IO, 线程管理和有限的扩展,在高并发下会导致大量的线程上下文切换, 增加了CPU 的开销2. reactor 使用少量的线程就可以处理大量的请求, 因为显著的减少了线程的上下文切换其中线程的上下文指的是线程在运行中所需要维护的各种信息    1. CPU 寄存器的信息    2. 栈信息: 保存局部变量表、方法调用链和返回地址等信息    3. 线程局部存储    4. 线程优先级    5. 程序计数器等信息</code></pre><h3 id="为什么netty-用少量的worker-线程就可以做到同样tomcat-的事情"><a href="#为什么netty-用少量的worker-线程就可以做到同样tomcat-的事情" class="headerlink" title="为什么netty 用少量的worker 线程就可以做到同样tomcat 的事情"></a>为什么netty 用少量的worker 线程就可以做到同样tomcat 的事情</h3><pre><code class="hljs">1. 事件驱动的设计    因为netty 是基于reactor 的事件驱动模型,worker 不处理整个请求的生命周期, 只响应或底层发出的网络事件, 使得只有事件触发的时候才去执行任务, 而不是阻塞等待2. 非阻塞 I/O    netty 使用的NIO 为非阻塞IO, selector 机制: 通过NIO的selector的机制, netty 可以让worker 线程管理多个channel, 当selector监听到某个channel 有IO 事件的时候, 该线程才会去处理这个channel, 在没有事件时, 线程会去监听而不被阻塞3. 任务划分与分离    bossGroup 和 workerGroup 的职责分离, bossGroup 专门处理连接的建立和关闭, 而worker Group 专注于处理已建立的连接的读写操作. 从而避免了线程资源的抢占4. 避免线程上下文的切换.     IO 的多路复用技术, 可以让一个线程监听多个channel 上的事件, 当channel 准备好读写的时候, 线程可以立即处理, 从而显著减少了线程数量</code></pre><h2 id="为什么要用netty"><a href="#为什么要用netty" class="headerlink" title="为什么要用netty"></a>为什么要用netty</h2><pre><code class="hljs">事件驱动模型:    基于reactor模式去做的, 通过EventLoop来管理IO 操作事件, 并将这些事件派发给相关的channelHandler, 实现高效的网络通信, 可以处理大量的并发连接    核心组建:        eventLoop:                1.每一个EventLoop 维护着一个 Selector 和 线程                2.处理IO 事件和任务                    监视和处理IO事件, 基于Java NIO 的selector 事件                3. 任务的调度                    还可以管理定时任务和普通任务, 可以提交任务到eventLoop上, 按照顺序和指定周期执行                4. 线程管理                    一个eventLoop通常和一个线程绑定, 每个eventLoop 可以维护多个channel, 但一个channel 始终绑定在一个eventLoop 上, 确保了同一个channel 上的事件处理是线程安全的                5. 事件的派发与处理                    负责从IO操作中获取事件, 将这些事件派发到对应的ChannelHandler中, 每个channel 代表一个连接或者IO操作, 在其pipeline中的一系列处理        channel:            负责网络IO操作相关的            1.1 管理IO 操作                对数据读取、发送、和连接的管理            1.2 处理事件                从网络传输到channelPipeline, 将channelPipeline 处理后的数据返回到网络中去            1.3 支持异步IO                即将数据异步写入到网络中,不会阻塞当前线程        channelPipeline:             是一个处理链, 每个IO 事件都会按照顺序通过channelPipeline, 将多个channelHandler连接起来, 形成一条链, 每个channelHandler只负责处理特定的事件        channelHandler:             用于处理特定类型事件的处理器, 不同的channelHandler 实现不同的功能, 有的可以用来编解码, 有的可以用来处理连接事件        Selector:             用于监听多个Channel 上的IO 事件, 当selector 发现某个Channel 上有事件发生的时候, 会通过EvenetLoop 来进行处理    工作流程:        boosGroup 和 workerGroup            bossGroup 负责监听客户端的连接请求事件, 将接收请求并将连接交给workerGroup进行处理            workerGroup负责处理具体的IO 操作        事件的监听与触发            当有IO发生的时候, EventLoop 会从selector 中获取到该事件, 并将其传递给绑定的channel            事件会按照事件类型依次在channelPipeline 上流过, 通过channelHandler 来具体处理        channelHandler 处理事件            入站事件有inbounder 处理, 出站事件由outbounder 处理            每个channelHandler 可以对事件进行处理, 处理完成后让下一个处理器进行处理    线程模型        EventLoop 绑定一个线程, 因此EventLoop管理的channel 也是在同一个线程上去运行的, 确保每个channel 上的事件处理是安全的, 从而减少了上下文切换的开销支持零拷贝    零拷贝指的是全程不需要CPU 进行参与, 所有数据都是通过DMA来进行传输的    全程只需要2次上下文切换, 2次DMA数据copyByteBuf 好处:    1. 容量可以动态的调整    2. 支持零拷贝, 减少数据在不同内存区域之间的复制,     3. polling 机制 从而进行重复利用</code></pre><h1 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h1><h2 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h2><pre><code class="hljs">高并发场景下, 怎么保证最可能的一致性    缓存扰动: 刚更新的缓存没有被读取到, 再次被更新的情况下    Cache-Aside        读请求中: 首先请求缓存, 如果命中缓存, 则直接返回缓存中的数据, 如果没有命中缓存, 则将查询出来的数据更新到缓存中, 然后返回查询出来的结果数据        写请求: 先更新数据库, 再删除缓存            为什么是删除缓存, 而不是更新                直接删除的时候性能高: 缓存中的数据可能是由多个条件下聚合出来的,                更加安全: 可能将旧的值放入到缓存中, 两个线程同时去更新数据的情况下            先更新数据库, 在删除缓存防止 缓存中的数据是老的            删除缓存, 更新缓存, 更新数据库    先更新数据库 -&gt; 删除缓存            优点: 删除缓存是因为性能更高, 写请求中更新可能导致数据的不一致性            缺点: 在读写下面也会有并发问题 T1 去读取数据, T2 去更新数据, T1 中更新晚于T2的缓存删除更新    删除缓存 -&gt; 更新数据库            读写并发的时候可能导致缓存脏数据, 可以通过延迟双删                1. 或者是在写请求的情况下加锁, 保证更新数据库和删除缓存串行处理            缓存删除失败的情况下 需要引入MQ 或者是 监听数据库消费来解决            优点            缺点    Write-Through    更新数据库 -&gt; 更新缓存        通过分布式锁 来解决更新数据库和更新缓存的一致性, 或者是将请求放到MQ中去处理            优点            缺点    Write-Through        或者是后续批量去进行写, 针对写特别多的情况下去做    更新缓存 -&gt; 更新数据库            优点            缺点        加上补偿机制        分布式锁    读多写少的情况下:        Cache-Aside 结合数据库日志做补偿    写多读少的情况下, 并且对于一致性要求比较高的情况下        Write-Through结合分布式锁:            写后去更新缓存        极端情况下:Write-Behind</code></pre><!-- ## 为什么需要将网络容器从tomcat 换成Netty    1. 实现机制上:         serverlet 通过 startAsync 本质上依赖线程池去进行处理, netty天生为异步非阻塞的, 使用事件驱动的方式, 每个EventLoop 可以处理多个IO操作事件,可以极大的降低了线程数和线程切换的开销    2. 线程模型:        serverlet 3.0异步依赖容器的线程管理, 在并发增加的情况下可能会导致线程的耗尽; netty 中使用少量的worker 线程来处理事件, 减少了上下文的切换, 避免了传统线程池模型的问题.    3. IO 模型        serverlet 3.0 虽然支持异步处理, 但是底层依赖于阻塞IO模型; netty 使用java NIO 的非阻塞式, 从底层上确保了高并发表现的性能    4. 并发高的情况下 tomcat 由于采用的是BIO 加上异步线程的方式去处理的, 会有大量的线程产生, CPU 内存 文件描述符都会发生资源竞争，netty 是通过NIO 方式去做的，使用少量的worker 线程就可以去处理 --><h1 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h1><h2 id="MESI-协议"><a href="#MESI-协议" class="headerlink" title="MESI 协议:"></a>MESI 协议:</h2><pre><code class="hljs">    多核处理器的缓存一致性协议, 用来保证多个处理器之间数据一致性</code></pre><h2 id="paxos-算法-zab-协议"><a href="#paxos-算法-zab-协议" class="headerlink" title="paxos 算法,zab 协议"></a>paxos 算法,zab 协议</h2><pre><code class="hljs">    zab 协议:         重新选举的算法:            zk 集群进入不可用的时候, 会重新发起选举, 选举过程如下:            1. 每个节点重新发起投票, 投票的信息包含有ZXID, 服务器的id, zxid 代表该节点处理最新事物的id, id 越大代表处理的数据越新,                 1.1 节点优先选择最新的zxID 做为leader,                1.2 leader 相同的情况下选择 更大的服务器id            2. 每个节点收到其他节点的投票后, 将其与当前的投票进行比较, 如果接受到的投票比自己当前的投票更好, 具体比较过程参照zxId和 服务器id, 则更新自己的投票并重新广播            3. 每个节点投票获得超过半数后, 则该节点成为新的leader, 其他节点通过他进行同步数据            4. 新的leader 确定后, 进行数据同步</code></pre><h2 id="zk-和其他注册中心对比-Eureka"><a href="#zk-和其他注册中心对比-Eureka" class="headerlink" title="zk 和其他注册中心对比 Eureka"></a>zk 和其他注册中心对比 Eureka</h2><pre><code class="hljs">  ZK CP Eureka 是AP </code></pre><h3 id="防止ZK-脑裂"><a href="#防止ZK-脑裂" class="headerlink" title="防止ZK 脑裂"></a>防止ZK 脑裂</h3><pre><code class="hljs">  如何解决ZK 脑裂问题  1. 确保奇数个节点  2. 网络分区的监控和恢复  4. 启用Observer 节点  5. 事物的日志和快照定期备份  6. Quorums: 当集群中存活节点少于法定人数的时候, 集群不可用  7. 冗余通信</code></pre><h2 id="系统变得很慢怎么处理"><a href="#系统变得很慢怎么处理" class="headerlink" title="系统变得很慢怎么处理"></a>系统变得很慢怎么处理</h2><pre><code class="hljs">    1. 确认问题,  通过系统监控、日志确认系统的实际情况和性能    2. 定位问题:  通过监控、    3. 分析问题:        1. CPU: top 查看CPU 负载 以及load 的情况, 查看占用CPU 资源高的原因        2. 磁盘IO: iostat 查看磁盘的情况        3. 网络情况: 查看网络是否正常        4. 数据库        5. 内存占用情况(机器的以及堆上的, jmap)        6. 线程是否有死锁, jstack        7. 查看外部请求是否有block, 是否有强依赖的情况    4. 解决问题    5. 验证是否解决了应用服务器监控内容    1. 资源监控    2. 日志监控    3. 健康监控    4. 实时监控</code></pre><h2 id="LB-算法"><a href="#LB-算法" class="headerlink" title="LB 算法"></a>LB 算法</h2><pre><code class="hljs">1. 随机2. 加权随机3. 轮训4. 最少连接5. 最短响应6. P2C    1. 当有请求到的时候, 从所有可用节点中随机选择两台    2. 比较当前两个节点当前负载    3. 将请求转发给负载比较轻的节点</code></pre><h2 id="zk-watch-机制"><a href="#zk-watch-机制" class="headerlink" title="zk watch 机制"></a>zk watch 机制</h2><pre><code class="hljs">ZooKeeper（ZK）中的 watch 机制 是一种轻量级的事件通知机制，允许客户端注册对某些节点状态变化的监听。当被监控的节点发生变化时，ZooKeeper 会通知相应的客户端。这种机制可以有效帮助客户端实时感知分布式系统中数据的变化，是 Zookeeper 作为分布式协调服务的重要特性。</code></pre><h2 id="服务治理是什么"><a href="#服务治理是什么" class="headerlink" title="服务治理是什么"></a>服务治理是什么</h2><pre><code class="hljs">业务在刚开始的时候往往都是单体应用, 随着用户量和访问量的增加, 架构上会从单体应用转换成分布式应用, 把单体应用中的每个模块按照特定的方法去进行拆分, 服务和服务之间通过HTTP 或者是 RPC 方式调用, 服务注册与发现、负载均衡、熔断限流、服务路由、监控、自动扩展与降级、服务的配置</code></pre><h2 id="分布式调用-如果对于下游不是强依赖的-下游服务挂掉-或者下游服务吞吐量不高怎么做"><a href="#分布式调用-如果对于下游不是强依赖的-下游服务挂掉-或者下游服务吞吐量不高怎么做" class="headerlink" title="分布式调用. 如果对于下游不是强依赖的, 下游服务挂掉, 或者下游服务吞吐量不高怎么做"></a>分布式调用. 如果对于下游不是强依赖的, 下游服务挂掉, 或者下游服务吞吐量不高怎么做</h2><pre><code class="hljs">1. 设置适当的超时时间2. 熔断3. 重试如果下游服务挂了, 如何做到最小资源浪费, 流量半开的机制是什么</code></pre><h2 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h2><pre><code class="hljs">1. 计数器实现方式: 在一个固定的时间内, 维护一个计数器, 记录当前请求的次数, 超过预定的值, 就进行限流优点: 简单缺点: 窗口边界有突发流量假设1min内服务器的负载能力为100，因此一个周期的访问量限制在100，然而在第一个周期的最后5秒和下一个周期的开始5秒时间段内，分别涌入100的访问量，虽然没有超过每个周期的限制量，但是整体上10秒内已达到200的访问量，已远远超过服务器的负载能力，由此可见，计数器算法方式限流对于周期比较长的限流，存在很大的弊端2. 滑动窗口实现方式: 将固定的窗口分割成细小的窗口, 通过不断的滑动来统计某段时间内的流量请求情况,优点: 减少临届问题, 限流更加平滑缺点: 实现复杂度高, 内存占用高3. 漏桶实现方式: 将请求流量看成是水流, 漏桶以固定的速率漏水, 如果漏桶满了, 超出的流量则被丢弃或者是排队处理优点: 可以平滑处理突发流量, 严格限制流量速度缺点: 容易导致短时间内的高峰流量被拒绝4. 令牌痛实现方式: 按照固定速率生成令牌, 每次请求需要拿一个令牌才可以被处理, 如果桶内没有令牌, 则进行拒绝优点: 相对灵活, 允许在时间范围内处理突发流量, 同时平滑处理长时间的流量缺点: 实现复杂</code></pre><h2 id="如何避免深度分页"><a href="#如何避免深度分页" class="headerlink" title="如何避免深度分页"></a>如何避免深度分页</h2><pre><code class="hljs">1. 确保排序的列上使用索引2. 基于游标的分页, where 条件中增加过滤3. 使用redis 等缓存机制</code></pre><h2 id="限流和熔断的区别"><a href="#限流和熔断的区别" class="headerlink" title="限流和熔断的区别"></a>限流和熔断的区别</h2><pre><code class="hljs">1. 熔断指的当服务端调用出现大量异常时,  组织进一步请求, 避免服务的异常    工作方式: 当请求成功数低于一定程度的时候, 熔断器 会进入打开状态, 或者是半打开状态, 只允许少量请求进行通过, 请求成功恢复正常    场景: 下游服务不稳定或者宕机情况下, 防止请求过多对系统进一步压力. 快速失败 2. 限流指的是控制单位时间内请求的速率, 避免过高的请求    工作方式: 设置阈值限制每个用户或者是整个系统的请求数量    场景: 控制用户访问速率, 保护API 接口不会被滥调, 避免过载</code></pre><h2 id="单元化理解"><a href="#单元化理解" class="headerlink" title="单元化理解"></a>单元化理解</h2><p>单元化定义: 一个能完成所有业务操作的自包含集合, 包含了这个业务所需要的所有服务和数据, 每一个单元部署了系统所需要的所有应用, 数据则是按照某种数据维度划分后的一部分<br>核心在于水平模式, 每个机房都有完成全站所有业务的能力<br>数据分区:</p><h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><h2 id="SHEIN"><a href="#SHEIN" class="headerlink" title="SHEIN"></a>SHEIN</h2><pre><code class="hljs">Netty事件驱动模型:    基于reactor模式去做的, 通过EventLoop来管理IO 操作事件, 并将这些事件派发给相关的channelHandler, 实现高效的网络通信, 可以处理大量的并发连接    核心组建:        eventLoop:                1.每一个EventLoop 维护着一个 Selector 和 线程                2.处理 IO 事件和任务                    监视和处理IO事件, 基于Java NIO 的selector 事件                3. 任务的调度                    还可以管理定时任务和普通任务, 可以提交任务到eventLoop上, 按照顺序和指定周期执行                4. 线程管理                    一个eventLoop通常和一个线程绑定, 每个eventLoop 可以维护多个channel, 但一个channel 始终绑定在一个eventLoop 上, 确保了同一个channel 上的事件处理是线程安全的                5. 事件的派发与处理                    负责从IO操作中获取事件, 将这些事件派发到对应的ChannelHandler中, 每个channel 代表一个连接或者IO操作, 在其pipeline中的一系列处理        channel:            负责网络IO操作相关的            1.1 管理IO 操作                对数据读取、发送、和连接的管理            1.2 处理事件                从网络传输到channelPipeline, 将channelPipeline 处理后的数据返回到网络中去            1.3 支持异步IO                即将数据异步写入到网络中,不会阻塞当前线程        channelPipeline: 是一个处理链, 每个IO 事件都会按照顺序通过channelPipeline, 将多个channelHandler连接起来, 形成一条链, 每个channelHandler只负责处理特定的事件        channelHandler: 用于处理特定类型事件的处理器, 不同的channelHandler 实现不同的功能, 有的可以用来编解码, 有的可以用来处理连接事件        Selector: 用于监听多个Channel 上的IO 事件, 当selector 发现某个Channel 上有事件发生的时候, 会通过EvenetLoop 来进行处理    工作流程:        boosGroup 和 workerGroup            bossGroup 负责监听客户端的连接请求事件, 将接收请求并将连接交给workerGroup进行处理            workerGroup负责处理具体的IO 操作        事件的监听与触发            当有IO发生的时候, EventLoop 会从selector 中获取到该事件, 并将其传递给绑定的channel            事件会按照事件类型依次在channelPipeline 上流过, 通过channelHandler 来具体处理        channelHandler 处理事件            入站事件有inbounder 处理, 出站事件由outbounder 处理            每个channelHandler 可以对事件进行处理, 处理完成后让下一个处理器进行处理    线程模型        EventLoop 绑定一个线程, 因此EventLoop管理的 channel 也是在同一个线程上去运行的, 确保每个channel 上的事件处理是安全的, 从而减少了上下文切换的开销异步非阻塞体现:    1. 基于java NIO 的非阻塞IO        基于NIO 中的selector 和 channel 来实现非阻塞的IO, 意味着每个IO 操作都是非阻塞的    2. selector 机制        使用selector 来监听channel 上的IO 事件    3. 异步操作的提交与处理        通过future 机制, IO 操作实现异步化    4. 异步事件的派发        eventLoop 监听到selector 上的IO 事件后, 异步派发给worker 去进行处理异步非阻塞和线程安全    线程安全通过单线程的eventLoop 去处理channel, 避免了多线程下的并发访问, 实现了一个channel 的线程安全支持零拷贝    零拷贝指的是全程不需要CPU 进行参与, 所有数据都是通过DMA来进行传输的    全程只需要2次上下文切换, 2次DMA数据copyByteBuf 好处:    1. 容量可以动态的调整    2. 支持零拷贝, 减少数据在不同内存区域之间的复制,     3. polling 机制 从而进行重复利用epool pool selector 的区别    epool原理 采用事件驱动的方式,     原理是通过内核维护的事件通知机制，将已注册的文件描述符放入红黑树中管理，并在文件描述符上发生事件时将其加入就绪队列（双向链表），应用程序通过 epoll_wait() 高效地等待并处理这些就绪事件    poll：需要定时扫描文件描述符,     每次调用时传入所有待监控的文件描述符，内核通过线性扫描检查文件描述符状态，返回已准备好进行 I/O 操作的文件描述符，性能随监控的文件描述符数量增加而线性下降动态代理    1. 进行接口定义, 创建一个自定义接口    2. 实现InvocationHandler接口, 类中的invoke 方法参数中有proxy 代理类, method 方法, args 对应的相关参数        proxy :动态生成的代理类        method : 与代理类对象调用的方法相对应        args : 当前 method 方法的参数    3. 创建代理类        通过java.lang.reflect.Proxy 类生成一个代理对象            Proxy.newProxyInstance(classLoader, interface, invocationHandler)                loader :类加载器，用于加载代理对象。                interfaces : 被代理类实现的一些接口；                h : 实现了 InvocationHandler 接口的对象；    4. 调用代理方法        通过newProxyInstance 创建出来的代理类, 去调用方法的时候, 实际上会去调用InvocationHandler 接口类中的invoke 方法, 因此可以再invoke 方法中自定义处理逻辑字节码增强:    cglib 通过生成目标类的子类的方法来创建代理对象            定义一个类；            自定义 MethodInterceptor 并重写 intercept 方法，intercept 用于拦截增强被代理类的方法，和 JDK 动态代理中的 invoke 方法类似；            通过 Enhancer 类的 create()创建代理类；        cglib 不可以代理声明为final 类型的类和方法    asm 是可以直接修改字节码的其中spring 默认是使用clglib高并发    GC 异步    futurepromiseSpring 的常见问题    HTTPTCP    三次握手 四次挥手 各个阶段, 以及每个阶段的问题动态代理    jdk cglib asmByteBufSpring 的IOC 和 AOP    IOC 指的是控制反转, 将对象的创建和管理委托给spring容器, 而不是直接有应用程序代码直接控制    AOP 指的是允许不修改代码的情况下, 方便的添加或者修改横切关注点        AOP 一般通过动态代理来进行实现            jdk 自身的动态代理: 基于java 的反射来进行实现的            cglib 反射    获取class 对象的方式:        1. Class alunbarClass = TargetObject.class;        2. Class alunbarClass1 = Class.forName(&quot;cn.javaguide.TargetObject&quot;);        3. TargetObject o = new TargetObject();                Class alunbarClass2 = o.getClass();        4. ClassLoader.getSystemClassLoader().loadClass(&quot;cn.javaguide.TargetObject&quot;);    反射的操作        创建一个我们要使用反射操作的类 TargetObject        使用反射操作这个类的方法以及参数            获取方法:Method[] methods = targetClass.getDeclaredMethods();            获取方法并调用: Method publicMethod = targetClass.getDeclaredMethod(&quot;publicMethod&quot;,String.class);            publicMethod.invoke(targetObject, &quot;JavaGuide&quot;);            获取指定参数:Field field = targetClass.getDeclaredField(&quot;value&quot;);            对指定参数进行修改                field.setAccessible(true);                field.set(targetObject, &quot;JavaGuide&quot;);问题:    1.     2. 堆外内存的排障    3. gdb --batch --pid 36563 --ex &#39;call malloc_trim() 进行内存释放    2. 并发压不上去怎么处理    3. dubbo    4. grpc    5. kafka    6. redis    7. HTTP 1.1 2.0 等    8. jdk 各个版本的差异 为了解决什么问题    9. spring spring boot     各个协议的问题, 并在下一个协议上怎么去解决的</code></pre><h2 id="极兔速递"><a href="#极兔速递" class="headerlink" title="极兔速递"></a>极兔速递</h2><pre><code class="hljs">1. 网关为什么要用netty2. 线程数怎么去定的 为什么大多数是CPU 核数+1    2. 每个请求耗时比较高    3. 4. pipeline handler 是做什么用的5. 后端机器上下线    下游应用存在非RPC 或者是非6. 鉴权怎么做的?7. 限流怎么做的    7.1 为什么要自己去进行限流8. 为什么使用4C 8G 升级到4C 16G9. 全链路灰度怎么做的    全链路定义:    请求头的识别        9.1 header、body、param、cookie、流量比例10. 网关自身怎么灰度11. 针对异步的请求怎么去做灰度12. 配置中心怎么去做灰度的, 数据库等的话 需要影子库13. 自动生成API 文档怎么说的 -&gt; 自动性怎么体现14. serverless 架构思想怎么体现的15. 流量怎么监控, 监控的告警阈值怎么配置??????????  告警 限流 等治理?????16. Agent17. 个人评估觉得厉害的:    17.1     17.2     17.3 MQ 延迟队列、灰度功能18. spring boot 的扩展点有哪些19. 什么是动态代理20. 如果自己去实现动态代理怎么去做21. MQ 的消息扭转, 生产者 消费者怎么消费22. 长轮训 怎么理解???    为什么要用长轮训去做23. 时间轮 怎么做的24. 语言表达不清楚</code></pre><h2 id="霸王茶姬"><a href="#霸王茶姬" class="headerlink" title="霸王茶姬"></a>霸王茶姬</h2><pre><code class="hljs">1. 请求的URL 配置2. 全链路灰度怎么做的3. 自研网关和spring cloud 或者zuul 4. 限流的模式是什么    4.1 和sentional 5. zk 脑裂问题6. netty 中的 channel 作用是什么7. netty 中的 eventLoop 作用8. 线程数中各个参数的关系是什么9. mysql 的隔离级别10. 幻读怎么解决的11. 缓存和数据库的一致性问题12. redis 缓存穿透和 击穿13. synchronized14. hashMap 中的扩容因子选取    14.1 为什么是0.75</code></pre><h2 id="神舟"><a href="#神舟" class="headerlink" title="神舟"></a>神舟</h2><pre><code class="hljs">1. 集群化分2. 和spring Cloud 怎么去对比3. 后端 IP信息怎么动态感知4. 日志是怎么记录的6. spring 注解 和 配置中心加载读取的顺序</code></pre><h2 id="华泰准备"><a href="#华泰准备" class="headerlink" title="华泰准备"></a>华泰准备</h2><pre><code class="hljs">1. 存储数据量很大 变化很大怎么处理        几百万条数据怎么处理        1.1 引入metaserver？？？？ 客户端主动向metaserver 去拉去数据, 注册中心只需要维护provider 的ip:port 信息        负载均衡算法        协议:            http2.0 Triple grpc http3.0        一些常用的配置????        一些常见的用户问题, 做了哪些功能？？？    2. 服务端不健康的时候, 怎么主动从注册中心上将自己给剔除掉    网关在协议转换上会不会常见很多个对象出来1. dubbo     失败重试的策略        1.1 快速失败策略: 请求失败, 直接把异常跑出去        1.2 失败安全策略:         1.3 失败自动恢复策略: 后台记录失败请求, 通过定时任务对失败请求进行充实        1.4 并行调用多个服务: 把消息广播给服务提供者集群, 只需要一个返回成功即可        1.5 广播调用策略: 逐个调用服务提供者的集群, 只要集群中任何一个节点返回异常, 表示本次请求失败    核心组建:        服务的提供方        服务的消费者        注册中心    请求的过程        服务注册:            服务的提供方在启动的时候将请求接口、方法、版本协议等信息注册到注册中心上            服务的消费者从注册中心订阅所依赖服务的信息, 注册中心会返回服务提供者地址的列表        服务发现            服务发现的过程, 服务的消费者会从注册中心拉取到服务提供者的列表并保存到本地缓存中, 当有新的服务的提供方或者老的服务提供方需要下线的时候, 注册中心会通知消费者, 消费者动态更新服务的提供者列表        服务准备调用            proxy 生成: 服务的消费者使用动态代理机制, 生成服务接口的代理对象, 当消费者调用接口方法时, 实际上是调用这个接口对象的方法            Cluster &amp; LoadBalance        网络通信准备            编码和序列化: 代理对象将方法调用, 参数信息封装成一个RPC请求, 通过编解码器对请求进行序列化和反序列化            Netty 通道管理: 使用Netty 作为底层通信框架, 消费者和提供方之间的通信依赖Netty 去进行传输数据        发送请求            consumer: 消费者通过Netty 客户端将序列化后的RPC 请求发送到指定的服务提供方            provider: 提供方的Netty server 会去接收请求, 并将其传递给指定的服务处理线程池去进行处理        请求处理            服务的提供方接收到请求并对接收到的数据进行反序列化, 恢复出原始请求对象            调用服务: 服务的提供方根据请求对象的服务名、方法名、通过反射的方式执行实际的业务逻辑            返回结果: 提供方将执行结果返回给响应对象, 并序列化后, 返回给发送方        接收响应            consumer: 消费者的Netty 客户端接收到响应后, 并将其反序列化成对象            结果处理: 将拿到的结果反序列化成对象返回给上层调用者        服务调用完成            上层的程序获得结果, 整个RPC 请求结束2. grpc 和 dubbo 的对比    grpc 直接基于http2.0 的, 默认使用 protobuf 来进行序列化和反序列化    dubbo 可以使用 Hessian、Kryo、Java 序列化 等http 1.1 2.0 quic 协议对比HTTP 1.X 存在的问题      单向请求: 只能单向请求, 不可以服务端主动给客户端发送响应    协议开销大: header里携带的内容过大，且不能压缩，增加了传输的成本。    队头阻塞: 下个请求必须要等待前面请求返回后, 才可以发出。导致带宽无法被利用HTTP2.0 怎么针对上述问题解决的    多路复用:  通过使用二进制帧来对数据进行传输, 不再是Http 1.x 的纯文本协议, 所有的请求都被分割成了更小的数据帧, 这些帧可以在网络中按照任意顺序发送, 接收方再根据帧的标识符进行重组, 提高了带宽的利用率    消除对头阻塞: 通过多路复用来允许多个请求和响应再同一个TCP 连接上进行传输, 从而消除了对头阻塞问题    减少了延迟: 多路复用可以使得数据流并行传输, 每个数据流有唯一的标示, 并且可以是无序的, 降低了延迟    减少连接开销: 可以共用链接HTTP2.0的问题    TCP 层面的队头堵塞问题:         TCP的顺序性:  发送方的某个数据包在传输过程中丢失了, 接收段需要等待重传的丢失包才可以处理后续的数据包, 导致了TCP 的队头堵塞        TCP 传输时某个数据流的数据包丢失了, 会导致后续的数据流堵塞, 因为TCP 需要等待丢失的数据包和重传    对比Http1.x 的话: 使得TCP的队头堵塞影响整个链接上的请求和响应, HTTP1.x 的话只影响对应链接的请求和响应可以通过QUIC 和 http3.0 去进行解决    基于UDP 去实现的    QUIC 实现了TCP + HTTPS + HTTP/2的功能，目的是保证可靠性的同时降低网络延迟    安全性:         1. 对于首次建立链接的: 需要交换密钥 消耗一次RTT, 再发送业务数据        2. 对于非首次的, 通过diff-Hellman 来进行密钥交换,     链接的唯一性基于64位的connection id    如何解决队头堵塞问题:        1. 基于UDP        2. 数据包级别的确认, 如何确定数据包是否一致 : 通过Stream ID 来标识当前数据流属于哪个资源请求, 同时增加stream offset 确认在数据流中的位置, 两个确定数据包重传    7. 总结    Protobuf：适合需要高效、跨语言通信和数据存储的场景，特别是在需要数据结构化的分布式系统和微服务架构中非常有用。    Kryo：专注于Java生态系统，提供高效的二进制序列化，适用于高性能计算和需要优化网络传输的应用。    FastJson：适合Web开发，特别是需要与前端进行数据交换的场景，尽管在性能上不如二进制序列化框架，但其易用性和广泛的语言支持使其非常流行。    Hessian2：用于分布式系统中的跨语言通信，适合需要轻量级二进制传输协议的场景，但在Java内部应用中，Kryo可能会有更好的性能表现。    4. HTTPS 的过程    1. 客户端发起请求    2. 服务器收到请求后, 向客户端发送数字证书(SSL/TLS 证书), 证书包含服务器的公钥和CA 签名的信息    3. 客户端验证证书    3.1 客户端检验证书、查看证书的有效期、证书链接、证书的域名是否和服务器匹配       防止中间人攻击    3.2 如果证书不可信, 客户端会警告用户并提示    4. 客户端使用生成会话密钥, 信息通过公钥进行加密, 服务器使用私钥进行解密。        确保只有对应私钥的才可以进行揭秘    5. 客户端和服务端双方拥有会话密钥后, 通过会话密钥进行对数据传输    6. 数据传输    7. 4. zk 和其他注册中心对比 Eureka    ZK CP Eureka 是AP     防止ZK 脑裂            如何解决ZK 脑裂问题            1. 确保奇数个节点            2. 网络分区的监控和恢复            4. 启用Observer 节点            5. 事物的日志和快照定期备份            6. Quorums: 当集群中存活节点少于法定人数的时候, 集群不可用            7. 冗余通信5. SPI     SPI 的具体原理是这样的：我们将接口的实现类放在配置文件中，我们在程序运行过程中读取配置文件，通过反射加载实现类。这样，我们可以在运行的时候，动态替换接口的实现类        META-INF/dubbo6. HTTP RPC 区别    1. 服务发现上的区别        HTTP 通过DNS 解析获取背后的地址        RPC 通过注册中心    2. 底层连接        HTTP keep-alive         RPC polling 机制    3. 传输内容        HTTP 传输内容多 冗余        RPC 定制化程度高7. 动态代理        jdk 动态代理通过Proxy 类生成一个代理对象, 这个代理对象实现了目标类的接口, 并将方法调用委托给InvocationHandler 来进行处理        1. 接口定义            1.1 创建一个自定义的接口        2. 实现InvocationHandler 接口            2.1 这个类的invoke 方法 会处理所有代理类上的方法调用                    proxy :动态生成的代理类                    method : 与代理类对象调用的方法相对应                    args : 当前 method 方法的参数        3. 创建代理类            MyInterface target = new MyInterfaceImpl();            // 创建InvocationHandler            MyInvocationHandler handler = new MyInvocationHandler(target);                loader :类加载器，用于加载代理对象。                    interfaces : 被代理类实现的一些接口；                    h : 实现了 InvocationHandler 接口的对象；            // 创建代理实例            MyInterface proxyInstance = (MyInterface) Proxy.newProxyInstance(                target.getClass().getClassLoader(),                target.getClass().getInterfaces(),                handler            );        4. 调用代理类的方法8. 线程数的配置方式    计算密集型        一般设置为接近于或等于CPU核心数。            计算密集型任务主要依赖于CPU执行计算。过多的线程会导致线程上下文切换增加，反而可能降低性能。因此，线程数与核心数保持一致或略多于核心数即可充分利用CPU。    IO 密集型        通常是CPU核心数的多倍。            IO密集型任务通常会有大量时间在等待IO操作完成，如网络或磁盘操作。在等待期间，CPU会空闲，因此可以通过增加线程数来提高并发量，减少CPU空闲时间。9. jdk 新版本特性        jdk11.             可以开始使用zgc,             移除的模块：Java EE 和 CORBA 模块 包的变化        jdk21:             虚拟线程            线程是映射到操作系统的本地线程去做的, 虚拟线程直接由jvm 去进行管理, 避免了上下文开销的切换</code></pre><h2 id="茄子科技"><a href="#茄子科技" class="headerlink" title="茄子科技"></a>茄子科技</h2><pre><code class="hljs">1. rocketMQ     生产消息的过程:    1. producer 发送消息之前, 先向NameServer 获取消息Topic 的路由信息    2. NameServer 返回 该 topic 的 路由表和 broker 列表    3. producer 根据代码指定的queue 选择策略, 从queue 列表中选择一个queue 进行存储        轮训        最小投递延迟    4. producer 向选出queue 所在的broker 发出rpc 请求, 将消息发送到选择出来的queue    消费者消费消息:        广播消费: 所有的consumer 实例 都会接受同一个Topic 的全量消息        集群消费: 每条消息只会发送给其中一个consumer        consumer 向Nameserver 获取Broker 的地址,        consumer 链接到Broker 上, 并订阅指定的topic        broker 根据ConsumerQueue 文件找到消息的偏移量和大小        broker 根据commitLog 文件读取消息数据        Broker 将消息数据返回给consumer    rebalance:    rocketMQ 怎么保证那么快的        使用了顺序存储, page cache、异步刷磁盘、 mmap 零拷贝技术        不是直接写入到磁盘的, 是写入到page cache 中, 随后以异步的方式pdflush 到磁盘上去        读操作的话也是走page cache     如何保证不被重复消费    kafka 吞吐量高的原因:        1. 顺序读写磁盘        2. 零拷贝linux 使用sendFile, 减少一次数据拷贝        3. 通常消费者批量从Broker 拉取数据    kafka 和 rocketmq 分别使用场景        1. kafka: 适用于高吞吐量、大规模数据处理的场景, 日志收集, 流式处理        2. rocketMQ 适用于消息的顺序性, 一致性有较高要求的应用, 对业务需要精确的控制消息    如何保证消息可靠性        可达性保证:             生产者:                 提供了sync 发送消息方式, 等待Broker 返回,                    支持同步, 线程池回调                 发送消息的时候失败或者是超时了, 则重新发送                    默认3次的重试次数                broker 提供了多master, 当某台broker 宕机了, 保证消息可以投递到另外一台上去                    利用多主的方式进行重试            broker 处理                提供同步的刷盘策略                当主的broker 磁盘损坏的时候, 可以给broker 指定slave, 同时设置slave 为同步刷盘策略, 设置master 为SYNC_MASTER, 保证消息同时落到master 和 slave            consumer 消费端                consmuer 默认提供 at least one 策略: consumer pull 消息到本地后, 消费完成才响应ack                提供重新消费的能力, 防止消费的时候异常    如何解决消息堆积的问题        耗时高原因: CPU  内部计算, 外部IO: 读写数据库, 访问redis, 下游RPC 调用        消息堆积带来影响:             存储压力上涨, 延迟增加, 一致处理积压的消息        怎么解决消息堆积            1. 梳理消费耗时: 是否计算逻辑过于复杂, 是否存在死循环, 是否可以做异步处理,             2. 增加 消费端 的并发度, 增加单个节点消费者的消费线程, 增加消费节点                消费节点 = 流量峰值 / 单个节点消息吞吐量redis    支持的数据结构:        String、Hash、List、Set、ZSet    可以持久化保存在磁盘中    redis 单线程        接收客户端请求-&gt;解析请求 -&gt;进行数据读写等操作-&gt;发送数据给客户端 整个过程是单线程的        单线程为什么那么快:            1. 大部分操作都是在内存当中操作的, 采用了高效的数据结构,              2. I/O 多路复用去处理大量客户端的Socket 请求,             使用单线程的原因:                CPU 不是Redis 性能的瓶颈, 更多的是在内存上和网络I/O的限制, 同时单线程可维护性高, 多线程的话增加系统复杂度, 存在线程切换等问题        6.0 后用多线程去做            为什么要在6.0 后用多线程去做: 提升网络I/O, 命令的执行仍然是单线程的    Redis 如何实现数据不丢失        1. 读写操作在内存中, 同时有做持久化        2. 持久化日志:             AOF 日志、每一个写的命令, 将对应的命令写入到该文件中                先执行命令操作, 再记录到AOF 文件日志中                写回的策略                alwaysEverySyc No                同步写回每秒回写由操作系统控制                可靠性高,性能适中, 性能好                但是开销大宕机丢失一秒数据宕机丢失的数据多                            RDB 日志: 将某一时刻的内存数据, 以二进制的方式写入磁盘                生成rdb 文件: save(会阻塞主线程) 和 bgsave(后台线程操作)                使用bgsave 的时候可以继续处理命令            混合持久化方式    Redis 如何实现集群的高可用        1. 主从复制            主从复制采用读写分离的方式, 写数据的时候写到主节点, 主节点收到写的命令后会更新给从节点,  客户端无须等到从节点都更新完再拿到响应的结果        2. 哨兵模式            可以对主从进行监控, 同时进行主从切换        3. 切片集群            数据量很大的时候, 可以用redis cluster        redis cluster 或者主从的时候出现脑裂怎么办            当主节点发现从节点下线, 或者通信的数量少于阈值时, 那么禁止主节点进行写数据, 直接把错误返回给客户端            min-slave-to-write x 主节点至少要和 x 个节点进行连接, 如果小于这个数量, 主节点会禁止写数据            min-slave-to-lag x   主从复制的延迟同步不可以超过 x 秒,  如果超过的话, 会禁止 主节点写数据            上述的配置可以防止主节点故障的时候进行写数据, 只有新的主库才可以写数据                        哨兵模式和主从模式        哨兵负责三个事情:             监控:                 主观下线                    发送Ping 命令给主节点, 如果主节点在一定时间内没有相应的话, 会被标记为SDOWN, 主观下线,                客观下线                    多个哨兵节点通信认为某个节点不可用, 则认为改节点为客观下线, ODOWN            哨兵节点的选主:                在主节点被标记为ODOWN 后, 哨兵节点会通过RAFT进行一次投票选举, 确定哪个哨兵节点作为领导者, 负责执行故障转移, 每个哨兵节点可以发起投票,并且每个哨兵节点只能投票给一个哨兵节点                获得多数票的哨兵节点被选为领导者, 负责后续的主从切换            选择主节点                哨兵的leader 从可用的从节点中选主一个新的主节点, 主节点标准:                    1. 从节点的优先级高的更可能被选中                    2. 复制偏移量, (代表和主节点是否更接近的,) 更有可能选中                    3. 链接状态好的                哨兵的leader 会向其他哨兵节点通知选主的主节点            主从切换                选中的从节点会倍提升为主节点, 新的主节点会停止从旧的主节点同步数据, 并且开始接受写入操作                重新配置集群,  其他从节点开始从新的主节点上去同步数据, 包含和旧的主节点连接的断开. 从新的主节点获取数据                通知客户端, 客户端根据配置更新配置            恢复正常运行    删除策略        1. 主库通过lazy 的方式进行删除        2. 主库会发送一个del 事件给从库, 从库收到后对数据进行删除    内存满了后怎么处理        1. 进行淘汰    Redis 缓存设计        如何避免缓存失效            1. 不给热点key 设置过期时间            2. 将缓存失效的事件随机打散, 防止集体失效        如何避免缓存击穿            1. 热点key 要过期的时候, 通知后台线程进行更新        如何避免缓存穿透 数据不存在数据库中, 要不存在redis 中            1. 对恶意请求进行限制拦截            2. 设置默认值            3. 通过布隆过滤器 去设置值是否存在, 不是直接通过数据库进行查询    更新缓存策略        1. cache aside:             针对读多写少的场景: 先更新数据库, 再去删除缓存        写多读少的场景            Write Through 策略            数据更新的时候, 如果数据库中有数据, 则先更新缓存中的数据,通过缓存组建同步更新到数据库中, 缓存组建告知应用程序更新完成            如果没有数据的话 则直接进行更新即可        Write back            更新数据库的时候, 只更新缓存, 将缓存数据设置为脏数据, 然后立马返回, 数据库的更新 再通过批量更新    大key 的影响        1. 客户端阻塞超时        2. 引发网络阻塞        3. 内存分布不均匀        4. 阻塞工作线程    如果找到大key        1. redis-cli --bigkeys        2. scan 找大keymmap    mmap 是一种将文件或其他对象映射到进程的虚拟内存空间的机制。通过 mmap，进程可以直接访问文件内容，就像访问内存中的数据一样，而不需要调用传统的 read 或 write 系统调用零拷贝    零拷贝是一种优化技术，旨在减少数据在用户态和内核态之间的拷贝次数，从而提高 I/O 性能。传统的文件 I/O 操作需要多次数据拷贝，例如从磁盘到内核缓冲区、从内核缓冲区到用户态缓冲区等。而零拷贝技术通过直接在内核空间中处理数据，避免了这些不必要的拷贝操作为什么要分代    1. 大多数对象的存活时间比较短, 少数对象存活时间比较长, 可以减少GC 扫描的范围, 提升GC 的效率    2. 不同年代的GC 算法采取不一样的, 年轻代 标记复制算法, 老年代, 标记清除 或者是标记整理问题:    1. 网关内外网流量怎么区分    1. 内部服务治理有哪些        1.1 负载均衡        1.2 服务路由        1.3 服务降级        1.4 服务限流        1.5 服务监控    2. 限流机制        1. 如何进行自我保护    3. 网关下游处理时长抖动怎么保证网关的可用性    4. 一次RPC 调用的过程    请求的过程        服务注册:            服务的提供方在启动的时候将请求接口、方法、版本协议等信息注册到注册中心上            服务的消费者从注册中心订阅所依赖服务的信息, 注册中心会返回服务提供者地址的列表        服务发现            服务发现的过程, 服务的消费者会从注册中心拉取到服务提供者的列表并保存到本地缓存中, 当有新的服务的提供方或者老的服务提供方需要下线的时候, 注册中心会通知消费者, 消费者动态更新服务的提供者列表        服务准备调用            proxy 生成: 服务的消费者使用动态代理机制, 生成服务接口的代理对象, 当消费者调用接口方法时, 实际上是调用这个接口对象的方法            Cluster &amp; LoadBalance        网络通信准备            编码和序列化: 代理对象将方法调用, 参数信息封装成一个RPC请求, 通过编解码器对请求进行序列化和反序列化            Netty 通道管理: 使用 Netty 作为底层通信框架, 消费者和提供方之间的通信依赖 Netty 去进行传输数据        发送请求            consumer: 消费者通过Netty 客户端将序列化后的RPC 请求发送到指定的服务提供方            provider: 提供方的Netty server 会去接收请求, 并将其传递给指定的服务处理线程池去进行处理        请求处理            服务的提供方接收到请求并对接收到的数据进行反序列化, 恢复出原始请求对象            调用服务: 服务的提供方根据请求对象的服务名、方法名、通过反射的方式执行实际的业务逻辑            返回结果: 提供方将执行结果返回给响应对象, 并序列化后, 返回给发送方        接收响应            consumer: 消费者的Netty 客户端接收到响应后, 并将其反序列化成对象            结果处理: 将拿到的结果反序列化成对象返回给上层调用者        服务调用完成            上层的程序获得结果, 整个RPC 请求结束    5. Netty 的一次网络请求过程是什么        客户端            初始化:                EventLoopGroup 的创建, 用于管理和服务之间网络链接和IO 操作, Bootstrap 配置客户端的各种参数, 包括线程模型, NioSocketChannel, 远端服务器的地址, 以及客户端的handler            建立链接                连接服务器: 通过Bootstrap.connect() 方法启动连接过程, 链接成功后会将channel 注册到event loop 上                等待建立连接完成:  connect() 返回一个ChannelFuture, 可以通过sync() 或者是addListener 进行完成            发送请求                构造数据进行请求, 连接成功后, 通过channel 向服务器发送数据, 通常是将请求封装成ByteBuf                 对数据进行writeAndFlush 写数据, 数据会通过ChannelPipeline 的outbounder 进行处理, 通过底层的socket 发送到服务器            接收响应                pipeline 处理, 当服务器响应数据到的时候, 数据会到channelHander 的inbounder,                处理响应数据: 业务逻辑进行处理, 处理完后返回给应用层            关闭连接                主动关闭连接: channel.close 关闭连接, 释放资源                监听关闭操作: close 返回的future 进行监听, 进行监听关闭是否成功。            资源清理                group.shutDownGracefully() 进行清理        服务端            初始化阶段                创建EventLoopGroup, bossGroup 和 workerGroup, bossGroup 负责接受请求, workerGroup 负责处理BossGroup 分配过来的IO 操作                配置serverBootstrap: 使用ServerBootstrap 来配置Netty 服务, 包括channel 的类型, 指定EventLoopGroup, 配置channelPipeline, 以及设置服务器的监听端口            绑定端口                serverBootStrap.bind() 方法绑定服务器的监听端口, 会启动一个异步操作过程, bossGroup 中的线程会监听这个连接请求                bind() 返回一个future, 可以通过sync()  或者是addListener 来等待响应            接受客户端请求                bossGroup 中的线程会去监听端口的连接请求, 当有新的请求进来的时候, Netty会为这个连接创建一个channel, 并将其分配给worker 的EventLoop上,                注册channel: 新的channel 会被注册在worker Group 中的eventLoop 上, 接下来和这个连接的相关读写操作都是在这个EventLoop 上            处理客户端请求                每个channel 关联的channelpipeline, 包含了一系列的handler                当客户数据到达的时候, 数据会通过channelPipeline 中的inbounder 来进行处理, 负责数据的读取, 解码，业务逻辑处理等            响应客户端                当业务逻辑处理完后, 通过会通过ChannelHandlerContext.writeAndFlush() 将数据响应回给客户端                数据会通过channelpipeline 中的outbounder，然后通过底层的socket 发送给客户端            关闭连接                客户端关闭连接, 或者是服务端主动关闭连接的时候, Netty 会处发ChannelInbounderHandler 的channelInactive 或者是channelUnregistered, 可以进行资源清理                在关闭服务器的时候, 需要调用bossGroup 和worker Group 的shutdownGracefully 进行线程资源的释放    6. TCP 流式处理怎么对流量进行拆分    7. Redis 的高可用怎么保证的,         哨兵模式和主从模式        哨兵负责三个事情:             监控:                 主观下线                    发送Ping 命令给主节点, 如果主节点在一定时间内没有相应的话, 会被标记为SDOWN, 主观下线,                客观下线                    多个哨兵节点通信认为某个节点不可用, 则认为改节点为客观下线, ODOWN            哨兵节点的选主:                在主节点被标记为ODOWN 后, 哨兵节点会通过RAFT进行一次投票选举, 确定哪个哨兵节点作为领导者, 负责执行故障转移, 每个哨兵节点可以发起投票,并且每个哨兵节点只能投票给一个哨兵节点                获得多数票的哨兵节点被选为领导者, 负责后续的主从切换            选择主节点                哨兵的leader 从可用的从节点中选主一个新的主节点, 主节点标准:                    1. 从节点的优先级高的更可能被选中                    2. 复制偏移量, (代表和主节点是否更接近的,) 更有可能选中                    3. 链接状态好的                哨兵的leader 会向其他哨兵节点通知选主的主节点            主从切换                选中的从节点会倍提升为主节点, 新的主节点会停止从旧的主节点同步数据, 并且开始接受写入操作                重新配置集群,  其他从节点开始从新的主节点上去同步数据, 包含和旧的主节点连接的断开. 从新的主节点获取数据                通知客户端, 客户端根据配置更新配置            恢复正常运行    8. 问题:        底层技术不是太差? 广度上不够, 需要对各个原理有了解</code></pre><!-- ### 注册中心#### eureka##### eureka 如果实现数据同步    1. 多节点部署与复制        eureka 集群中的各个节点会相互的同步注册信息和服务信息    2. 服务注册和同步的流程        1. 服务注册过程: 微服务向eureka 节点发送注册请求        2. 增量同步            1. 服务注册的时候, 当一个服务实例向其中一个eureka 节点进行注册, 对应的eureka 节点会将该实例信息同步给其他的eureka 节点            2. 服务续约. 服务节点定时给eureka 进行心跳请求续约, 每次续约都会触发增量同步            3. 服务下线.             4. 服务状态变更            2.1 实现方式:                通过增量队列来实现的, 当有节点注册、续约、下线、状态变化的时候, 会放到增量队列中,eureka 会定时从增量队列中获取数据, 将需要同步的数据发送给其他节点, 其中防止很长时间都没有被同步, 增量队列中需要携带上时间戳, 可以用来进行触发全量同步            自我保护机制, 设置成一个阈值可以判断时因为节点异常了,            具体case                服务实例向节点 A 注册，A 将该变更添加到自己的增量队列中。                节点 A 定期检查增量队列，发现有新注册的服务实例。                节点 A 通过增量同步的 API /eureka/v2/apps/delta，将该变更同步给节点 B。                节点 B 接收到增量信息后，更新其本地的注册表，保持与节点 A 的数据一致性。        3. 全量同步            3.1 节点重启: 当有一个节点重启了            3.2 增量同步失败: 由于增量同步出现异常, 节点之间注册信息不一致, 触发全量同步. 增量同步失败的原因可能因为网络故障、超时、抖动等            3.3 数据检测不一致: 节点会去定时检测其他节点信息和注册表中的数据是否一致, 发现有不一致的, 并且增量失败            3.4 全量同步过程:                3.4.1 节点向其他节点发送全量同步请求                3.4.2 接受其他节点的全量注册信息,                 3.4.3 将全量节点更新到本地                3.4.4 恢复正常        4. 新的节点起来以后怎么做的数据同步            全量同步        5. 如何通知给服务的消费方            5.1 客户端通过定时拉的方式获取,初次时进行全量拉取, 后面是进行增量拉取            5.2 拉增量失败后, 会触发拉取全量的            5.3 当服务器进入到自我保护机制时, 拉取到的数据可能是旧的##### 如何解决eureka问题: 当客户端很多的时候怎么处理, hash 环 + 虚拟节点            如何做到注册方的上下线, 秒级别推送:                基于WS 或者是长轮训                    WS:                        1. 服务消费方在初始化过程中，会先经Session域名查询Session的IP地址列表并缓存到本地，然后再从列表中选择一台Session服务器与之建立 WebSocket长连接，并发送服务订阅请求。                        2. Session在收到服务订阅请求后，先会将服务订阅信息和 WebSocket 连接的映射关系存储到本地。后续当Session收到Data推送的服务变更消息时，它会先从上述映射关系中查询该服务对应的变更订阅方（即对应的WebSocket 连接列表），然后将消息通过这些连接推送出去。                        3. 在收到服务变更消息后，服务消费方会根据消息的内容更新本地缓存中的服务地址列表                上下线的时候, data 节点通知所有的session 节点#### zk##### zk 选举    1. 节点分类        leader: 主节点，负责处理写请求，并将事务日志同步到从节点        flower: 从节点，接收 Leader 的同步数据，并参与读请求。        observer: 观察者节点，不参与选举和投票，但接收 Leader 的同步数据。    2. 选举算法        Fast Leader Election 参考的点: zxid, myId, 当前数据的完整度和 机器的优先级##### zk 写数据的过程    1. 客户端发起写的操作, 这个操作只能到leader 节点上去    2. leader 收到写请求后, 会生成一个zxId, 通知zxId 是递增的    3. leader 会将zxId 封装成一个propersal 进行广播, 基于zab 协议,确保所有flower 接收到    4. flower 接受propersal 并进行ACK 响应    5. leader 接受ACK, 过半就可以持久化写入    6. leader 进行commit, 并通知所有的flower    7. flower 收到leader 的commit 后并对自己进行刷新    8. leader 确认写完成后并通知客户端    通过写请求只能leader 处理、zxId 是递增的、zab 协议来实现一致性    P 的话通过法定人数, 过半节点##### 如何解决脑裂问题    1. 确保奇数个节点    2. 网络分区的监控和恢复    4. 启用Observer 节点    5. 事物的日志和快照定期备份    6. Quorums: 当集群中存活节点少于法定人数的时候, 集群不可用    7. 冗余通信 --><!-- ### Consul    1. 通过WAN Gossip 协议 解决多数据中心的问题    WAN Gossip 协议: 通过随机选择节点进行数据交换, 但是传播速度比较慢, 节点可能会有重复的数据通信,### 注册中心发布怎么解决    一是关闭/启动应用程序前，先拉出服务实例，程序启动成功后，再拉入服务实例；二是客户端负载均衡自动拉出访问异常服务实例。 --><h2 id="美团"><a href="#美团" class="headerlink" title="美团"></a>美团</h2><pre><code class="hljs">1. mysql    char 和 varchar的区别        char: 固定长度的字符类型, 定义时需要指定字符长度, 不够的时候会在末尾补足空格, 适合存储固定长度的        varchar:  可变长度的字符串类型, 存储时需要指定最大长度,存储的时候根据实际长度占用存储空间    in 和 exist 的区别        in 表示左边表达式是否存在于右边, 返回true or false        exist 可以返回一行数据        性能上的差异:            exists 的性能要比in 好, 尤其是在表比较大的情况下, 因为exist 找到一条后就立刻返回停止查询, in 需要遍历整个子查询        使用场景:            查询子集合较小并且变动属于低频的, in 更加直观,  当子查询涉及到外部查询的每一行判断的时候,  并且子查询效率较高, exist 更为合适        null 值的处理:            in 可以正确处理子查询中包含null 的情况, 而exist 不受子查询结果中null  值的影响    执行一条sql 请求的过程        1. 客户端发送请求            客户端通过网络连接向数据库发送一条sql 语句,         2. 连接管理            连接处理: 数据库服务器收到客户端的请求后, 检查是否有可用的连接池, 如果有的话 则用现有的处理连接, 没有的话创建一个新的连接            权限验证: 服务器会去验证客户端的身份, 检查客户端是否有执行这条sql 命令的权限, 如果校验失败, 则返回错误        3. SQL 解析            词法分析            语法分析            语义检查        4. 查询优化            生成查询计划: 数据库会根据语法树生成多个可能的查询计划, 查询计划是SQL 执行的方案, 描述了如何访问和处理            选择最优计划: 数据库会根据执行的代价选择一个最优的方案, 代价评估包含有IO成本, CPU 资源消耗 内存使用等        5. 查询计划            执行计划: 根据选定的查询计划, 逐步执行sql 语句            中间结果处理: 执行过程中, 可能会有一些中间结果, 中间结果会在最终结果生成前被处理        6. 返回结果            结果集生成: 将最终的结果集返回给客户端, 可能是查询的结果, 可能是更新的影响数等等            资源释放: 清理执行过程中使用的临时资源, 并对资源进行释放        7. 事物处理            如果SQL 是在事物中执行的, 数据库还需要执行事物的提交或回滚        8. 日志记录    存储引擎为什么默认选择innodb        1. 支持事物        2. innodb 是聚集索引, MyISAM 是非聚集索引        3. 锁力度: innodb 最小是行锁，myIsam 是表锁    索引        适合当主键的字段            1. 唯一性, 且不为空            2. 递增的                原因:                     1. 避免页分裂                        1.1 尽可能的顺序写, 无需在中间插入数据                        1.2 避免页分裂: 如果是随机的话, 新数据可能要在中间插入, 导致数据库对现有数据进行分割                     1.3 插入效率高                    2. 缓存命中率比较高                        2.1 减少缓存压力, 新的数据可以顺序写入和读取, 减少缓存中不断去进行对老数据替换                        2.2 数据和索引的缓存优化: 如果主键是递增的, 最新的数据往往是在相邻页上, 这些页面可能已经被加载到了缓存中, 从而提高缓存命中率                    3. 索引维护简单                        3.1 顺序更新, 减少维护索引结构的复杂性                        3.2 避免索引碎片: 随机主键会导致叶子结点不断被打乱, 产生大量的碎片, 需要频繁的进行索引重组. 顺序可以保证索引结构的稳定性增长                    4. 空间利用率高                        4.1 有助于更好的利用磁盘空间                        4.2 减少数据碎片            3. 不建议用业务字段, 无法预测未来是否重复            4. 大多数情况下用唯一自增id        聚集索引 和 非聚集索引区别:            1. 数据存储上                聚集索引和数据是存放在一起的, 聚集索引的叶子结点就是实际的数据行, 非聚集索引的叶子结点不包含完整的数据行, 而是包含指向完整数据行的指针或者是主键值, 数据行本身存储在聚集索引中            2. 索引和数据关系上                直接通过聚集索引可以找到数据行, 不需要额外的步骤去进行查找, 非聚集索引查找数据的时候, 现在非聚集索引中找到对应的主键值, 再通过主键值回溯到聚集索引上去找对应的数据行            3. 唯一性上                聚集索引是基于主键构建的, 每个表只能有一个主键, 一个表可以有多个非聚集索引            4. 效率                对于范围查询和排序查询, 聚集索引的查询效率更高, 因为避免了额外的寻址查询                非聚集索引在使用覆盖索引进行查询的时候效率更高, 无需进行回表操作            5. 使用场景                聚集索引适合频繁的范围查询, 顺序插入, 大量返回完整行数据的                非聚集索引适合更加频繁的多列查询, 覆盖索引查询        B+ 树的叶子结点是双向链表        联合索引的条件            将区分度大的字段放在前面        需要回表的：            如果要查询的数据不再二级索引中, 就会先检查二级索引,  找到对应的叶子结点, 获取到主键的值, 再去主键索引查找        覆盖索引            一个索引列包含了查询的所有列, 不需要回表就可以完成查询        查询的时候会尽量用联合索引        索引的缺点            1. 占用物理空间            2. 创建和维护需要耗时, 随着数据量的变大而变大            3. 降低表增删改的效率, 每次增删改, 需要动态更新索引        需要用索引:            1. 字段有唯一性限制            2， 经常用于where 条件的            3. 经常用于group by 或者是order by 的        不适合的            1. where group by order by 中用不到的字段            2. 大量重复的字读            3. 数据表很少的情况下            4. 经常更新的字段        防止索引失效            1. like %xx 的 或者是like %xx% 的            2. 索引列进行计算的            3. 遵循最左匹配原则            4. where 条件中 or 前后不是索引列的            5. 联合索引遇到范围查询后, 范围查询后面就会停止精确匹配        mysql 如何解决并发问题的            1. 锁机制, 行级锁、表锁、页锁等            2. 事物隔离级别            3. MVCC        隔离级别如何实现            读已提交: 事物中只能读取到其他已提交的数据                通过在语句语句执行之前生成一个read view, 因此可以保证每次读取的时候可以读取到其他事物提交后的数据            可重复读 是通过在启动事物时生成一个read view, 整个事物期间都在用这个read view, 因此没办法防止幻读, 因为整个事物期间基于的视图时一样的        MVCC: 多版本并发控制协议            通过维护数据的多个版本, 允许事物在不加锁的条件下并发的读取数据,  从而提高系统的并发性和数据的一致性            innodb 在每行的数据库上额外记录两个隐藏字段:                创建版本号: 标识插入或者更新这行数据事物的id                删除版本号: 标识删除这行数据事物的id，实际指向undo log的指针, 用于回滚或者读取旧版本            工作过程:                1. 插入操作:                    插入新行的时候, innodb会为这行记录事物ID 并创建版本号, 删除版本号为空                2. 更新操作                    更新数据的时候, 会在当前数据上创建新的版本, 更新创建版本号, 同时保留旧的版本号用于并发事物读取                3. 删除操作                    删除数据的时候, 不会立马去进行物理删除, 而是将删除记录在undo log 中, 同时给该行数据的删除版本号写入当前事物id                4. 读取操作                    根据当前的事物隔离级别, 会通过事物的id 和 版本号来判定是否可以看到特定的数据版本            read view:                是MVCC 中的一个概念, 表明特定时间点当前事物可以看到哪些数据                一致性试图: 当事物开始读取数据的时候,  该视图定义了可以看到的数据版本,                 事物的范围: 当前系统中未提交的最早事物的id, 当前系统中最新的事物id, 当前还未提交的事物id            优点:                 高并发: 读操作不需要加锁, 避免了读写之间的冲突, 提升系统的能力                数据一致性: 保证数据的一致性的同时, 提供了更高的查询能力                避免思索: 读操作不需要加锁, 减少了死锁的发生            缺点:                额外的存储空间: 由于需要维护多个版本的数据, MVCC 会占用额外的存储空间                版本链的管理: 随着数据的更新, 版本链可能变长                复杂的实现        mysql 中的锁:            全局锁                flush tables with read lock: 会将整个库设置为只读状态            表锁            行锁                例如在select for update 的时候 或者update 的时候会用到拍他锁                innodb 支持行锁                记录锁                    S锁: 共享锁                        允许多个事物读取同一条数据,但是禁止对改数据进行修改                        当一个事物持有S锁, 其他事物也可以获取S锁, 但是其他事物允许获得X锁, 不可以对数据进行修改                        适用于select 查询的场景                    X锁: 排他锁                        确保同一个事物对数据的独占, 既可以读取数据, 也可以修改数据, 拍他锁禁止其他事物同时修改数据                        当一个事物持有X锁的时候, 其他事物不允许获取X锁, 也不可以获取X锁, 只有持有X锁的事物才可以对数据进行读取和更改, 保证事物的独占                        适用于更新的场景                gap 锁                    防止幻读                    BEGIN;                    SELECT * FROM orders WHERE order_date &gt;= &#39;2023-01-01&#39; AND order_date &lt; &#39;2023-02-01&#39; FOR UPDATE;                    -- 对指定日期范围内的间隙加锁，防止其他事务插入新的订单记录                    COMMIT;                next-key-lock        一条update 是不是原子性的             是的, 通过undolog 来实现的        大事物带来的问题            1. 一个事物特别多的sql, 锁定的数据会特别多,             2. 回滚的时候会占用大量的空间            3. 执行时间长 会导致主从延迟        日志的分类:            redo log: 实现了事物的持久性, 用于掉电等故障            undo log: 实现了事物的原子性, 用于事物的回滚和MVCC            bin log: server 生成的日志, 用于数据备份和主从复制            relay log        binlog: 记录了数据库表结构变更, 表数据修改的日志            格式有STATEMENT(每一条修改数据的SQL 都会记录到日志中) 、row(记录每条数据的最终数据)、 MIXED            主要用于主从复制的一致性, 可以精准的重新主库中所有数据的变更        undoLog: 用于撤销回退的日志, 保证了ACID中的原子性            在事物没有提交之前, 会将之前的日志记录到undoLog 中, 可以用来回滚            1. 没有事物引用、事物已经提交、数据库中没有长时间运行的事物的情况下可以删除        redoLog: 保证数据的持久化            1. redoLog 中记录事物完成后的数据, 记录的是更新后的值            2. 可以确保在崩溃后, 通过redolog 可以将数据恢复到一致性状态            3. 性能优化, redolog 允许mysql数据页的修改 可以异步的刷新到磁盘中去, 不必每次去写, 提高写性能        能不能只有binlog 没有redoLog            不能, binlog 是server 层的日志, 没办法记录哪些脏页还没有刷盘, redoLog 是引擎层的日志, 可以记录哪些数据没有刷盘, 崩溃恢复的时候可以通过它来进行恢复数据        binlog redolog  undolog 关系            binlog 是逻辑层面sql 的修改, 主要用于主从复制和数据恢复            redolog 是物理层面数据页更改, 保证事物的持久性和恢复            undolog 是数据的旧版本, 用于事物回滚和MVCC        WAL 技术: write ahead of log 先写日志, 再在合适的时间点将数据刷新到磁盘上去        事物提交的过程起的作用:            undolog 记录旧版本数据, redolog 记录新数据, 事物提交时, redo log会先标记事物为prepare状态, 再写入binlog, 最后将事物标记为commit 再进行提交        恢复的时候:            redolog 来完成所有已提交事物的操作, 使用undolog 来进行事物的回滚, binlog 用于主从复制或者是后续重演事物        binlog 的两阶段提交            目的:                 保持binlog 和 redo log 的一致性: 确保数据库崩溃后, 保证事物提交的原子性和一致性                防止数据丢失: 如果事物已经提交到了redo log，但是没有写入到binlog 中, 在系统奔溃后恢复, 由于binlog 没有该事物的记录, 从而影响主从复制                防止数据不一致: 如果事物已经写入到binlog 但是没有写入到redolog， 奔溃后恢复的时候会导致binlog 中有记录, 但是实际数据库没有应用, 导致数据不一致            过程                1. prepare 阶段                    事物执行, innondb 会将事物的更改记录写入到redo log 中, 并将这些日志标记为 prepare 状态, 这意味着这些事物已经在操作了, 但是还未提交, 数据的修改刷新了内存中, 但是还没有刷新到磁盘                2. commit 阶段                    写入binlog， 在事物提交之前, 将事物的更改写入到binlog 中, 此时binlog 记录的是最终持久化的数据, 此时redolog 中数据还是处于prepare 状态                    提交事物, 将redolog 中的事物标记为commit 状态, 一旦事物标记为commit, 数据页的修改会被刷新到磁盘上            关键:                顺序性和原子性:                    先记录redolog 的prepare 状态, 再写入binlog, 最后提交redo log， 防止奔溃恢复时出现数据的不一致                奔溃恢复                    如果在写入binlog 后, 但是在提交redolog 之前的 发生了奔溃, mysql 在恢复时根据redolog 的prepare状态 和binlog 的记录继续完成提交, 确保事物的一致性            update 的具体过程                服务端处理的过程, 假设校验这些都过了                1. 调用执行引擎查找对应的记录, 如果数据本来就是在buffer pool 中, 则直接返回, 没有的话从磁盘中读取到buffer pool。再返回                2. 执行器查看更新后的数据是否和前面的是一样的，一样的话不做任何处理, 不一样的话，将更新前后的值传递给innodb 进行处理                3. 开启事物, 先将记录记录到undo log 中, 将更新的旧数据记录到undo log中                4. innodb 开始更新记录, 先更新内存, 同时标记为脏页, 将记录写入redolog 中, 为了减少磁盘的IO, 由后台线程将脏页数据写入到磁盘中                5. 更新完成后, 记录该语句对应的binlog, 此时binlog 会保存到binlog cache 中, 在事物提交的时候统一将所有binlog刷新的磁盘上                6. 事物提交                    prepare 阶段 redolog 设置事物状态为prepare, 将redolog 刷盘                    commit 阶段 binlog刷盘, 将redolog设置为commit        主从复制            主从复制:                 1. 写入binlog                2. 同步binlog                3. 回放binlog            主库在收到客户端的提交事物请求后, 先将数据写入到binlog 中,更新存储引擎中的数据, 再返回给客户端            从库会起一个专门的IO 线程, 连接主库的log dump 线程, 接收主库的binlog日志, 再将binlog 信息relay log 到从库的中继日志            从库创建一个专门回放binlog的线程, 去读relay log 中日志, 回放binlog 更新存储引擎中数据            保证写数据的时候只写主库, 读的时候从从库读取        主从延迟怎么处理            强制从主库上读取        分库分表            分库: 将数据按照一定的规则划分到多个库中, 每个库只负责部分数据的存储, 为了解决单台mysql 扛不住的问题            分表: 将数据分摊到不同的表上, 为了解决单个表太大的问题            垂直分库: 按照业务功能            水平分库: 同一个表按照一定的规则拆分        MHA 如何实现主从切换            MHA manager 会对主库的状态进行检测, 发送探测请求,ping 命令, 同时监控mysql 的错误日志和系统日志, 用来捕捉异常信息, 根据设定的阈值来判别主库是否发生了异常,            重新选主的策略                1. 复制延迟小, 选择延迟最小的从库, 减少数据不一致的风险                2. 数据一致性 优先选择最具完整事物日志的从库                3. 可用性: 当前运行良好的从库            提升主库                停止新主库的slave 进程, 使得不再继续同步, 重新命名realy log, 确保从库变为主库                修改每个从库的change master to 命令, 让他指向到新的主库                启动从库的slave 进程, 开始从新的主库上同步数据            MHA 自身的高可用                1. 部署多个MHA 实例, 确保一个MHA 实例出了问题, 另一个可以继续工作                2. MHA 通过VIP 的方式去处理, 对于客户端来说无需感知                3. 心跳机制和自动切换: 定时心跳检测主的MHA Manager 的状态.                 4. 防止 MHA 节点脑裂: 使用仲裁机制, 类似于ZK, 优先级和选举机制,        write-set            每次提交的时候, 相当于对事物的写操作生成了一个集合        WriteSet            WriteSet 是一个集合, 包含了某个事物修改的所有操作的元数据,  可以用来冲突检测(将提交事物的writeset 和 其他节点中未提交的进行比较, 检测是否有冲突), 全局一致性        MGR            使用Paxos 一致性协议, 支持多主的模式, 集群内所有结点通过一致性写作, 决定事物的提交顺序, 检测到节点故障的时候, 自动从剩余的节点中选举出新的主节点(如果是单主的情况下)            如何解决数据的冲突                1. 基于组内通信的全局事物一致性                    基于paxos 实现事物的全局一致性, 一个节点发起事物投票后, 事物会被广播到组内, 确保所有结点对该事物达成一致                2. 冲突与检测处理                    基于writeSet 的冲突检测机制: 每个事物提交的时候, MGR 会生成一个write-set, 记录了该事物中所有的修改, 相当于对该事物的写操作生成了一个集合                    冲突检测: 当一个节点尝试提交事物的时候, 会将该事物的write-set 与组内其他节点已提交但未应用的事物write-set 进行比较, 判断是否有冲突发生                3. 检测到冲突                    丢弃冲突的事物: 根据事物的先后顺序, 来决定保留哪个事物, 通常是保留先提交的事物                4. 冲突处理后的应用                    处理完冲突后, MGR会将所有成功提交的事物 应用到每个节点上去. 确保所有结点数据的一致性                5. 用户对冲突自行处理                    1. 默认将数据写到某个节点上去, 按照节点的轮训, 避免冲突    DTS:        1. 怎么保证网络可用        2. 高效同步???        3. HA        1. 语法转换和解析        2. 迁移过程的一个高可用            2.1 日志读取高可用            2.2 日志回放高可用            2.3 数据拉取的时候怎么控制速率和大小        3. 源数据所在集群发生了变化怎么处理        4. 全量迁移的时候需要同时进行增量        5. 顺序ABA 问题        零拷贝             1. 零拷贝指的是在IO时减少或者消除数据内存拷贝的次数以及CPU的参与, 使得数据在IO的时候可以更加高效            主要实现手段:            1. sendfile() 系统调用: 是linux 提供的一种系统调用, 可以直接将数据从文件描述符传输到网络套接字上, 不需要将数据复制到用户空间, 内核直接通过mmap 和 DMA 进行数据传输            2. mmap 系统调用: 可以将文件映射到进程的地址空间, 这样进程可以直接在自己的地址空间访问文件内容, 不需要显示的读写            3. DMA 技术, 通过DMA 允许设备直接访问内存, 无需经过CPU, 通过DMA,            优点:                1. 减少CPU的开销, 避免了不必要的内存拷贝                2. 提高数据传输效率. 减少了数据的传输效率                3. 减少上下文的切换. 减少用户态和内核态的上下文切换        page cache            是磁盘上的数据缓存到内存中的操作, 加速读写            读操作:                如果读取的时候数据已经在page cache 中, 则说明命中了直接返回, 避免了磁盘的IO                如果读取的时候数据没有在page cache 中, 则从磁盘中获取并缓存到page cache中            写操作                预先将数据写入到page cache 中, 操作系统会在后台将page cache 数据写入到磁盘上去            优点:                提高读取速度: 加速磁盘的读取, 降低磁盘IO                减少写入次数: 集中写的机制                提高内存利用率: 操作系统会动态调整大小            缺点:                内存占用                写入延迟        netty 高低水位怎么控制发送速率, netty 怎么进行流量限流            通过检测给外部发送的缓冲区数据是否超过了高低水位, 从而控制TCP的发送速率            config.setWriteBufferHighWaterMark(64 * 1024); // 64KB 高水位线            config.setWriteBufferLowWaterMark(32 * 1024);  // 32KB 低水位线        java agent 机制        ringBuffer            是一种固定的环形缓冲区,             优点:                 固定长度                循环利用                低延迟                由于是固定内存的 因此减少GC压力        id 生成器, 雪花算法,twitter 那个            雪花算法的64位组成如下            符号(1)_时间戳(41)_数据中心(5)_机器id(5)_序列号(12)        磁盘 堆外读取        mysql 中 Event 怎么理解????        heartbeat_event 怎么理解???        通过WRITE_BUFFER_WATER_MARK 控制发送速率        数据一致性保证        1. 时序保证: replicator 消费时顺序发送给applier        2. At Least Once            2.1 一边重启怎么处理                replicator 重启的话 通过读取本地的gtid set                applicator 重启的话 通过目标数据库当前执行过的gtid set 进行对比            2.2 解决循环复制的问题                set gtid_next 将该事物的gtid 设置为同步过来的gtid_event 中的GTID                set gtid_next=GTID        3. DDL         netty        java agent proxy-client        ringbuffer        DDL 怎么处理        回环怎么处理        大数据怎么处理??        分布式id 生成器 算法</code></pre><h3 id="一面问题"><a href="#一面问题" class="headerlink" title="一面问题"></a>一面问题</h3><pre><code class="hljs">1. qconfig 服务端 CAP 怎么选择, 为什么这样去选2. qconfig 元数据是否放在ZK 中3. 单元化的理解3.1 单元化如何实现的, 就是从整个公司的角度, 以及从配置中心角度=====3.2 单元化的时候数据怎么落到正确的存储上去    3.2.1 单元化的目的:4. 数据批量变换和数据预热怎么处理, 为什么要这样去做5. 批量变更在什么情况下有问题    5.1 批量变更不是delay 去做, 是从请求方开始就聚集去做处理6. jmap 查看堆上的内存, 查看内存占用的过程是什么样的7. pmap 查看堆外内存的场景,为什么会怀疑和malloc 分配内存有关联    7.1. ptmalloc 申请内存 和 jemlloc 为什么 ptmalloc    7.2 ptmalloc 中用户释放掉的内存, 为了下次快速使用, 会存到自己的空闲列表中, 因此导致了很多的64M 内存占用的问题8. 线程资源占用 应该调整哪个参数 或者jvm 应该怎么调整=======    1. 需要调整线程栈的大小 和 堆上的大小9. 稳定性有什么总结性的    9.1 幂等服务    =======    事物管理    限流熔断    重试机制10. 网关 为什么要从tomcat 换成netty11. 为什么netty 可以用更少的线程来做同样的事情12. netty 怎么去管理堆外内存    12.1 mmap + bytebuf    12.1 每个bytebuf 有个引用计数器, 当bytebuf 被使用的时候, 计数器+1, 不再需要使用的时候, 计数器-1, 当byteBuf关联的计数器降为0的时候。    通过PooledByteBufAllocator 和 ByteBuf 来实现的, 在需要使用堆外内存的时候, 分配一个新chunk 或者直接向操作系统申请一个, 然后通过ByteBuf 的API 对堆外内存去进行读写. 内存释放的时候通过引用计数机制的减少ResourceLeakDetector 可以用来检测-XX:MaxDirectMemorySize=1G 限制堆外内存的使用13. 网关上降本增效 怎么去做这个事情14. 读已提交 和 可重复读 怎么保证的15. mvcc 是利用什么机制实现的16. undo log 在什么时候会去删除掉17. undo log 在多版本比较的时候会在什么时候可以删除 ===============    17.1 当所有以来undo log 的事物都不再使用的时候就可以删除了18. 内存写了, 磁盘还没有落的时候, crash 了.  怎么去保证19. synchronized 的锁升级的过程20. cas 会有什么问题</code></pre><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><pre><code class="hljs">1. 项目哪个印象更深刻一点2. 详细介绍一下配置中心做了哪些事情3. 配置读取的单元化    3.1 配置读取的就近读、就近写的单元化, 配置中心底层的数据读取怎么做到单元化    3.2 配置中心数据放在MGR数据库上, MGR集群4. 网关tomcat 换成netty 为什么要去做这个事情5. 对重要应用的隔离是怎么去做的    5.1 重要应用的定义怎么定义    5.1 重要性怎么收集6. 网关集群流量配置的灰度, 配置的灰度怎么去做的7. 网关流量权重怎么设计的8. 网关灰度的机器和普通机器怎么做, 其他人是怎么做的 业界方案怎么做的9. 单台机器QPS 从多少提升到10000    9.1 原来值是多少 2000    9.2 做了哪些改造有那么高提升10. 网关服务的容灾 和 高可用11. 网关的水平扩、缩容怎么做的12. 基于k8s 的自动扩缩容, 提供给业务同学用, 和网关之间的关联性    12.1 进行扩缩绒的标准是什么    12.2 自动扩缩容的机制是怎么实现的    12.3 采集流量的QPS 信息    12.4 如何确定好下游的节点是够的???    12.5 弹性伸缩为什么要放在网关侧去做13. 网关项目的参与人    13.1 为啥人那么少14. 项目的迭代周期是什么    14.1 网关项目的重点是什么15. 网关转发的同样的请求, 转发到不同的应用、集群、机器上去16. 项目有什么做的不好的???17. 项目中长期的规划, 有哪些可以做的18. 对标其他公司的差距有哪些?    18.1. 稳定性、容灾性、性能上的差距, 支持的能力上差距19. 性能优化的思路、流程    19.1 以耗时高的为例子    19.2 CPU比较高的话 排查工具20. 如何快速定位full GC21. java 服务 的full GC 多久是属于正常的22. java 服务日常关注哪些指标23. mysql 的高可用架构24. 主从架构下, mysql update 的数据流程25. 有了解过消息中间件么?? 使用的场景有么?26. 多线程并发工具, 如何控制多线程同步, 控制线程的调度顺序27. 网关部分线程池在什么情况下会用到28. 算法题: 接雨水29. 为什么离职30. 是否有其他offer31. 容灾、可用性、稳定性32. 个人关注的技术方向有哪些、以及了解渠道33. 日常自己总结, 提升效率的有什么方法</code></pre><h4 id="MNS"><a href="#MNS" class="headerlink" title="MNS"></a>MNS</h4><h5 id="MNS-准备"><a href="#MNS-准备" class="headerlink" title="MNS 准备"></a>MNS 准备</h5><pre><code class="hljs">1. MNS 工作流程2. OCTO 工作流程3. 路由策略4. 限流方法有哪些, 分别有什么问题5. 如何解决分片的reblance普通哈希 和 一致性哈希</code></pre><p>限流算法:<br>    1. 计数器<br>        实现方式: 在一个固定的时间内, 维护一个计数器, 记录当前请求的次数, 超过预定的值, 就进行限流<br>        优点: 简单<br>        缺点: 窗口边界有突发流量<br>                假设1min内服务器的负载能力为100，因此一个周期的访问量限制在100，然而在第一个周期的最后5秒和下一个周期的开始5秒时间段内，分别涌入100的访问量，虽然没有超过每个周期的限制量，但是整体上10秒内已达到200的访问量，已远远超过服务器的负载能力，由此可见，计数器算法方式限流对于周期比较长的限流，存在很大的弊端<br>    2. 滑动窗口<br>        实现方式: 将固定的窗口分割成细小的窗口, 通过不断的滑动来统计某段时间内的流量请求情况,<br>        优点: 减少临届问题, 限流更加平滑<br>        缺点: 实现复杂度高, 内存占用高<br>    3. 漏桶<br>        实现方式: 将请求流量看成是水流, 漏桶以固定的速率漏水, 如果漏桶满了, 超出的流量则被丢弃或者是排队处理<br>        优点: 可以平滑处理突发流量, 严格限制流量速度<br>        缺点: 容易导致短时间内的高峰流量被拒绝<br>    4. 令牌痛<br>        实现方式: 按照固定速率生成令牌, 每次请求需要拿一个令牌才可以被处理, 如果桶内没有令牌, 则进行拒绝<br>        优点: 相对灵活, 允许在时间范围内处理突发流量, 同时平滑处理长时间的流量<br>        缺点: 实现复杂</p><h3 id="单元化理解-1"><a href="#单元化理解-1" class="headerlink" title="单元化理解:"></a>单元化理解:</h3><pre><code class="hljs">单元化定义: 一个能完成所有业务操作的自包含集合, 包含了这个业务所需要的所有服务和数据, 每一个单元部署了系统所需要的所有应用, 数据则是按照某种数据维度划分后的一部分核心在于水平模式, 每个机房都有完成全站所有业务的能力数据分区: </code></pre><h4 id="netty-组建介绍"><a href="#netty-组建介绍" class="headerlink" title="netty 组建介绍"></a>netty 组建介绍</h4><h5 id="Channel-的作用-1"><a href="#Channel-的作用-1" class="headerlink" title="Channel 的作用"></a>Channel 的作用</h5><pre><code class="hljs">负责网络IO操作相关的    1.1 管理IO 操作        对数据读取、发送、和连接的管理    1.2 处理事件        从网络传输到channelPipeline, 将channelPipeline 处理后的数据返回到网络中去    1.3 支持异步IO        即将数据异步写入到网络中,不会阻塞当前线程</code></pre><h5 id="EventLoop-作用-1"><a href="#EventLoop-作用-1" class="headerlink" title="EventLoop 作用"></a>EventLoop 作用</h5><pre><code class="hljs">1.每一个EventLoop 维护着一个 Selector 和 线程2.处理IO 事件和任务    监视和处理IO事件, 基于Java NIO 的selector 事件3. 任务的调度    还可以管理定时任务和普通任务, 可以提交任务到eventLoop上, 按照顺序和指定周期执行4. 线程管理    一个eventLoop通常和一个线程绑定, 每个eventLoop 可以维护多个channel, 但一个channel 始终绑定在一个eventLoop 上, 确保了同一个channel 上的事件处理是线程安全的5. 事件的派发与处理    负责从IO操作中获取事件, 将这些事件派发到对应的ChannelHandler中, 每个channel 代表一个连接或者IO操作, 在其pipeline中的一系列处理</code></pre><h5 id="EventLoopGroup-作用-1"><a href="#EventLoopGroup-作用-1" class="headerlink" title="EventLoopGroup 作用"></a>EventLoopGroup 作用</h5><pre><code class="hljs">用于管理所有的EventLoop, 一个 EventLoopGroup 用于管理多个线程来并发去处理执行IO 事件</code></pre><p>Channel 是网络通信的管道, 负责实际数据的读写, EventLoop 是负载驱动Channel 的 执行, 通过循环监听IO 事件来处理这些事件, EventLoopGroup 是多个EventLoop 的管理着, 负责分配和管理多个EventLoop, 并支持多并发处理多个Channel</p><h5 id="为什么需要将网络容器从tomcat-换成Netty-1"><a href="#为什么需要将网络容器从tomcat-换成Netty-1" class="headerlink" title="为什么需要将网络容器从tomcat 换成Netty"></a>为什么需要将网络容器从tomcat 换成Netty</h5><pre><code class="hljs">vmstat 1/proc/stat top 等可以判断进程啥下文切换可以检测上下文切换是否很高,1. 实现机制上:     serverlet 通过 startAsync 本质上依赖线程池去进行处理, netty天生为异步非阻塞的, 使用事件驱动的方式, 每个EventLoop 可以处理多个IO操作事件,可以极大的降低了线程数和线程切换的开销2. 线程模型:    serverlet 3.0异步依赖容器的线程管理, 在并发增加的情况下可能会导致线程的耗尽; netty 中使用少量的worker 线程来处理事件, 减少了上下文的切换, 避免了传统线程池模型的问题.3. IO 模型    serverlet 3.0 虽然支持异步处理, 但是底层依赖于阻塞IO模型; netty 使用java NIO 的非阻塞式, 从底层上确保了高并发表现的性能4. 并发高的情况下 tomcat 由于采用的是BIO 加上异步线程的方式去处理的, 会有大量的线程产生, CPU 内存 文件描述符都会发生资源竞争，netty 是通过NIO 方式去做的，使用少量的 worker 线程就可以去处理</code></pre><h2 id="为什么要用netty-1"><a href="#为什么要用netty-1" class="headerlink" title="为什么要用netty"></a>为什么要用netty</h2><pre><code class="hljs">事件驱动模型:    基于reactor模式去做的, 通过EventLoop来管理IO 操作事件, 并将这些事件派发给相关的channelHandler, 实现高效的网络通信, 可以处理大量的并发连接    核心组建:        eventLoop            1.每一个EventLoop 维护着一个 Selector 和 线程            2.处理IO 事件和任务                监视和处理IO事件, 基于Java NIO 的selector 事件            3. 任务的调度                还可以管理定时任务和普通任务, 可以提交任务到eventLoop上, 按照顺序和指定周期执行            4. 线程管理                一个eventLoop通常和一个线程绑定, 每个 eventLoop 可以维护多个channel, 但一个channel 始终绑定在一个eventLoop 上, 确保了同一个channel 上的事件处理是线程安全的            5. 事件的派发与处理                负责从IO操作中获取事件, 将这些事件派发到对应的ChannelHandler中, 每个channel 代表一个连接或者IO操作, 在其pipeline中的一系列处理        channel            负责网络IO操作相关的            1.1 管理IO 操作                对数据读取、发送、和连接的管理            1.2 处理事件                从网络传输到channelPipeline, 将channelPipeline 处理后的数据返回到网络中去            1.3 支持异步IO                即将数据异步写入到网络中,不会阻塞当前线程        channelPipeline: 是一个处理链, 每个IO 事件都会按照顺序通过channelPipeline, 将多个channelHandler连接起来, 形成一条链, 每个channelHandler只负责处理特定的事件        channelHandler: 用于处理特定类型事件的处理器, 不同的channelHandler 实现不同的功能, 有的可以用来编解码, 有的可以用来处理连接事件        Selector: 用于监听多个 Channel 上的IO 事件, 当selector 发现某个Channel 上有事件发生的时候, 会通过EvenetLoop 来进行处理    工作流程:        boosGroup 和 workerGroup            bossGroup 负责监听客户端的连接请求事件, 将接收请求并将连接交给workerGroup进行处理            workerGroup负责处理具体的IO 操作        事件的监听与触发            当有IO发生的时候, EventLoop 会从selector 中获取到该事件, 并将其传递给绑定的channel            事件会按照事件类型依次在channelPipeline 上流过, 通过channelHandler 来具体处理        channelHandler 处理事件            入站事件有inbounder 处理, 出站事件由outbounder 处理            每个channelHandler 可以对事件进行处理, 处理完成后让下一个处理器进行处理    线程模型        EventLoop 绑定一个线程, 因此EventLoop管理的channel 也是在同一个线程上去运行的, 确保每个channel 上的事件处理是安全的, 从而减少了上下文切换的开销零拷贝     1. 零拷贝指的是在IO时减少或者消除数据内存拷贝的次数以及CPU的参与, 使得数据在IO的时候可以更加高效    主要实现手段:    1. sendfile() 系统调用: 是linux 提供的一种系统调用, 可以直接将数据从文件描述符传输到网络套接字上, 不需要将数据复制到用户空间, 内核直接通过mmap 和 DMA 进行数据传输    2. mmap 系统调用: 可以将文件映射到进程的地址空间, 这样进程可以直接在自己的地址空间访问文件内容, 不需要显示的读写    3. DMA 技术, 通过DMA 允许设备直接访问内存, 无需经过CPU, 通过DMA,    优点:        1. 减少CPU的开销, 避免了不必要的内存拷贝        2. 提高数据传输效率. 减少了数据的传输效率        3. 减少上下文的切换. 减少用户态和内核态的上下文切换page cache    是磁盘上的数据缓存到内存中的操作, 加速读写    读操作:        如果读取的时候数据已经在page cache 中, 则说明命中了直接返回, 避免了磁盘的IO        如果读取的时候数据没有在page cache 中, 则从磁盘中获取并缓存到page cache中    写操作        预先将数据写入到page cache 中, 操作系统会在后台将page cache 数据写入到磁盘上去    优点:        提高读取速度: 加速磁盘的读取, 降低磁盘IO        减少写入次数: 集中写的机制        提高内存利用率: 操作系统会动态调整大小    缺点:        内存占用        写入延迟支持零拷贝    零拷贝指的是全程不需要 CPU 进行参与, 所有数据都是通过DMA来进行传输的    全程只需要2次上下文切换, 2次DMA数据copyByteBuf 好处:    1. 容量可以动态的调整    2. 支持零拷贝, 减少数据在不同内存区域之间的复制,     3. polling 机制 从而进行重复利用</code></pre><h5 id="Netty-的一次网络请求过程是什么-1"><a href="#Netty-的一次网络请求过程是什么-1" class="headerlink" title="Netty 的一次网络请求过程是什么"></a>Netty 的一次网络请求过程是什么</h5><pre><code class="hljs">客户端    初始化:        EventLoopGroup 的创建, 用于管理和服务之间网络链接和IO 操作, Bootstrap 配置客户端的各种参数, 包括线程模型, NioSocketChannel, 远端服务器的地址, 以及客户端的handler    建立链接        连接服务器: 通过Bootstrap.connect() 方法启动连接过程, 链接成功后会将channel 注册到event loop 上        等待建立连接完成:  connect() 返回一个ChannelFuture, 可以通过sync() 或者是addListener 进行完成    发送请求        构造数据进行请求, 连接成功后, 通过channel 向服务器发送数据, 通常是将请求封装成 ByteBuf         对数据进行writeAndFlush 写数据, 数据会通过ChannelPipeline 的outbounder 进行处理, 通过底层的socket 发送到服务器    接收响应        pipeline 处理, 当服务器响应数据到的时候, 数据会到channelHander 的inbounder,        处理响应数据: 业务逻辑进行处理, 处理完后返回给应用层    关闭连接        主动关闭连接: channel.close 关闭连接, 释放资源        监听关闭操作: close 返回的future 进行监听, 进行监听关闭是否成功。    资源清理        group.shutDownGracefully() 进行清理服务端    初始化阶段        创建EventLoopGroup, bossGroup 和 workerGroup, bossGroup 负责接受请求, workerGroup 负责处理; BossGroup 分配过来的IO 操作        配置 serverBootstrap : 使用 ServerBootstrap 来配置 Netty 服务, 包括 channel 的类型, 指定 EventLoopGroup, 配置 channelPipeline , 以及设置服务器的监听端口    绑定端口        serverBootStrap.bind() 方法绑定服务器的监听端口, 会启动一个异步操作过程, bossGroup 中的线程会监听这个连接请求        bind() 返回一个future, 可以通过sync()  或者是addListener 来等待响应    接受客户端请求        bossGroup 中的线程会去监听端口的连接请求, 当有新的请求进来的时候,bossGroup 中的某个eventLoop 会调用 NIO 的 selector 来监听OP_ACCEPT 事件, 一旦有新的连接时间发生, Boss Group 会接受这个连接并为这个连接创建一个channel, 并将连接对应的 channel 分配给worker 的EventLoop上,        注册channel: 新的channel 会被注册在worker Group 中的eventLoop 上, 接下来和这个连接的相关读写操作都是在这个EventLoop 上    处理客户端请求        每个channel 关联的channelpipeline, 包含了一系列的handler        当客户数据到达的时候, 数据会通过channelPipeline 中的inbounder 来进行处理, 负责数据的读取, 解码，业务逻辑处理等    响应客户端        当业务逻辑处理完后, 通过会通过ChannelHandlerContext.writeAndFlush() 将数据响应回给客户端        数据会通过channelpipeline 中的outbounder，然后通过底层的socket 发送给客户端    关闭连接        客户端关闭连接, 或者是服务端主动关闭连接的时候, Netty 会处发ChannelInbounderHandler 的channelInactive 或者是channelUnregistered, 可以进行资源清理        在关闭服务器的时候, 需要调用bossGroup 和worker Group 的shutdownGracefully 进行线程资源的释放</code></pre><h3 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h3><pre><code class="hljs">1. yong gc 和full GC 如何优化的    1.1 full gc 找到大的文件    1.2 yong gc 在配置的快速变更期间, 导致客户端全都重新建立长轮训请求, 导致服务端的压力比较大, 服务端为了保证配置检测到配置文件的快速变更下发, 需要解析所有的配置文件版本号,以及和本地对比, 这部分数据都是瞬时压力比较大的, 因为客户端的数量比较多, 每次变更都是需要重新连上来, 因此一开始怀疑是不是Yong 区太小了, 导致yong 区GC 比较频繁, 因此将yong 区的大小调大 G1NewSizePercent, 观察效果. 同时由于我们采用的是G1 的算法, 他在yong gc 的时候会有STW, 导致处理耗时变长, 并且此时由于yong 区的对象比较多, 因此我们决定将G1 换成zgc, 第一步就是需要jdk 从1.8 升级到jdk11    升级jdk 的时候有一些依赖 包的调整,  因为jdk11 引入了一些模块化, 一些类都废弃掉了. 升级完后再去将gc 方式换成zgc,</code></pre><h1 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a>项目总结</h1><h2 id="API-网关"><a href="#API-网关" class="headerlink" title="API 网关"></a>API 网关</h2><h4 id="对比其他网关区别"><a href="#对比其他网关区别" class="headerlink" title="对比其他网关区别"></a>对比其他网关区别</h4><pre><code class="hljs">1. 服务端支持集群模式的, 根据不同的集群功能, 拉取不同的配置2. 数据集群有区分, 不同的数据类型拉取方式不一样3. 限流功能自己实现4. 有一些缓存的配置没有实现. 业务属性太强, 容易出问题</code></pre><h2 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h2><h3 id="对比apollo-实现差别"><a href="#对比apollo-实现差别" class="headerlink" title="对比apollo 实现差别"></a>对比apollo 实现差别</h3><pre><code class="hljs">1. apollo config server 会定时轮训数据库去进行感知变化, 简单, 但是会带来延迟性高和资源的浪费2. qconfig 通过两者结合3. 对于配置的一些集群限流, 配置中心的服务端没有分集群, 但是控台对外restAPI  会根据不同的应用属性, 进行限制</code></pre><!-- 1. 网关如何提高性能    4C 8G    请求方式就是一个healthCheck 响应ok 这种的    1.1 一开始压测        如何解决压不上去的问题    1.2 发现CPU 一下子就上去了    1.3 更换网络框架    1.4 更换IO 模型2. 配置中心如何提升性能3. 用户体验上的???4. 单元测试上的     -->]]></content>
    
    
    <categories>
      
      <category>总结</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>jvm 整理</title>
    <link href="/2024/08/11/jvm/jvm%20%E6%95%B4%E7%90%86/"/>
    <url>/2024/08/11/jvm/jvm%20%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="内存的区域"><a href="#内存的区域" class="headerlink" title="内存的区域:"></a>内存的区域:</h1><pre><code class="hljs">1. 共享    1.1 堆(GC 回收的区域)、字符串常量2. 私有的    2.1 虚拟机栈(方法调用需要通过栈来实现, 每一次方法的调用都是需要入栈, 每次方法调用的结束都是对应到出栈)、本地方法栈(一些native 方法的)、程序计数器(当前线程执行到哪里的一个字节码指使器)3. 本地内存    3.1 metaspace、直接内存</code></pre><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><pre><code class="hljs">新生代 Eden + S0 +  S1    对应的比列是多少 8:1:1老年代    G1 默认是5%</code></pre><h1 id="创建对象的过程"><a href="#创建对象的过程" class="headerlink" title="创建对象的过程"></a>创建对象的过程</h1><h2 id="1-类加载检查"><a href="#1-类加载检查" class="headerlink" title="1. 类加载检查"></a>1. 类加载检查</h2><pre><code class="hljs">1.1 类加载机制    主要有三个过程:         加载 链接 初始化        加载: 将字节码文件加载到内存中        链接: 分为 验证、准备、解析 三个过程            验证: 确保加载的类文件符合JVM 的规范            准备: 为类的静态变量分配内存, 并初始化            解析: 将 类、接口、方法中的符号引用替换成直接饮用, 符号引用指的是符号名(如String), 直接引用指的是具体的内存地址或者是偏移量        初始化: 执行类的初始化, 为静态变量赋予默认值,     类加载器有:        启动类加载器(rt.jar)        扩展类加载器(JAVA_HOME/lib/ext)        应用程序类加载器 ( 加载应用程序中类的路径)        自定义类加载器 (通过继承ClassLoader 来实现自定义类加载器)    类加载机制的模型为: 双亲委派        启动一个类的时候优先给他的父类加载器, 如果父类加载器无法加载该类的时候, 才由当前类加载器去进行加载        优点: 保证核心类库不会被篡改, 避免重复加载        缺点: 多版本库依赖的情况下需要打破双亲委派, 例如tomcat, 这样可以让每个web 容器去独立加载类和资源, 而不是委派给父类去进行加载            打破双亲委派的目的是需要灵活性、隔离性或者需要自定义加载类的情况下2. 分配内存    2.1 指针碰撞 --------&gt; 标记清除        堆内存规整     2.2 空闲列表---------&gt; 标记整理        堆内存不规整3. 初始化零值4. 设置对象头5. 执行init 方法</code></pre><h1 id="判断对象是否死亡"><a href="#判断对象是否死亡" class="headerlink" title="判断对象是否死亡"></a>判断对象是否死亡</h1><pre><code class="hljs">1. 引用计数法    1.1 相互引用的无法处理2. 可达性分析法    只有至少经过两次标记的才会被清理, 调用finalize</code></pre><h1 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1><pre><code class="hljs">1. 强引用2. 弱引用3. 软引用4. 虚引用</code></pre><h1 id="GC-算法"><a href="#GC-算法" class="headerlink" title="GC 算法"></a>GC 算法</h1><pre><code class="hljs">1. 标记清除 老年代    1.1 从根对象出发, 遍历所有的可达对象    1.2 对可达对象进行标记    1.3 未被标记的对象属于不可达对象, 等待清除的对象    1.4 对不可达对象进行清除优点: 实现简单, 不需要移动对象缺点: 容易造成内存的碎片, 处理达对象困难    解决方式: 增加压缩, 称之为标记整理算法2. 标记复制新生代    将内存分为两部分, 每次使用其中的一部分, 当内存使用完后, 将存活的对象复制到另外一部分去    1. 将内存区域划分为From 区 和 To 区        1.1 From 区: 当前正在使用的区域, 存放正在使用的存活对象        1.2 To 区: 空闲的列表, 用于存放GC 存活时的对象    2. 从GCRoots 对象出发, 遍历所有的可达对象        2.1 标记From 区的存活对象, 确定在To 区的位置    3. 将From 区的对象复制到To 区, 在复制期间, 对象的地址会重新发生变化    4. 更新对象地址的引用    5. 清空From 区, 将From 区和To 区进行互换角色优点: 所有对象都整齐的放到新的区域上去, 不会产生内存碎片      新生代中对象生存时期比较短, 复制对象比较少, 效率高缺点: 对象内存浪费, 需要使用两个大小相同的内存区域, 实际每次只使用一半      每次收集的时候需要从一边复制到另外一边去, 会产生一定的开销3. 标记整理算法 老年代    标记过程和标记清除一样, 只是在回收对象的时候, 将对象移动到一侧, 然后直接去清理 </code></pre><h1 id="收集器"><a href="#收集器" class="headerlink" title="收集器"></a>收集器</h1><h2 id="CMS-使用-的-标记清除算法-主要用于老年代的"><a href="#CMS-使用-的-标记清除算法-主要用于老年代的" class="headerlink" title="CMS 使用 的 标记清除算法 主要用于老年代的"></a>CMS 使用 的 标记清除算法 主要用于老年代的</h2><pre><code class="hljs">1. 初始标记    从GCRoots 出发的直接可达性对象, 需要进行STW, 2. 并发标记    在初始标记的基础上, 标记处内存中所有的可达性对象, 此时没有进行STW, 用户线程和GC 线程同时在运行.3. 重新标记    需要进行STW, 对并发标记遗漏的对象进行修正, 在并发标记起期间产生的不可达对象需要在下一次GC 周期才能被回收4. 并发清除    清除所有未被标记的对象, 进行对象回收, GC 线程和 用户线程同时在运行缺点:     1. 碎片化验证, 清除过程中不对内存进行压缩整理, 导致内存碎片话严重    1.1 影响: 碎片化严重, 可能会导致老年代无法分配达对象, 触发full GC    2. 浮动垃圾: 在并发标记期间产生的垃圾, 无法在当前GC周期被清除, 只能等到下一次GC    2.1 影响: GC 效果不如预期, 需要预留更多的内存空间    3. 某些情况下会退化成单线程回收    3.1 如果堆内存不足以支撑程序的内存分配, 进而出发一次Full GC    3.2 年轻代向老年代晋升, 如果老年代没有足够的空间去容纳这些对象的时候, 也会导致CMS 失败, 从而退化成单线程的Serial Old 收集器    3.3 空间碎片化, 由于CMS 回收产生的碎片化, 导致大对象无法找到连续的内存进行分配, 最终触发full GC</code></pre><h2 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h2><pre><code class="hljs">其中-XX:G1NewSizePercent  新生代比列默认时5%使用标记-整理算法    1. 标记阶段        1. 初始标记        从GC Roots 出发, 标记直接可达的对象, 需要进行STW        2. 并发标记            从GCRoots 出发, 找出存活对象, 应用线程和GC线程是可以同时活动的,         3. 再标记            标记在并发标记时转移的对象    2. 清理阶段            清点出有存活的对象和没有存活的对象    3. 复制阶段        重新分配对象内存和复制成员变量, 转移的时候需要进行STW, 复制的耗时和存活对象的数量以及对象的复杂程度成正比           **初始标记**        标记从GC Roots 出发的可达对象 需要进行STW    - **并发标记**        标记整个堆中的存活对象, 不会进行STW    - **最终标记**        完成并发标记, 并且处理在并发标记期间导致应用对象的变化, 需要进行STW    - **筛选回收**        确定进行回收, 并根据收集的数据区域进行回收    - **拷贝回收**        将存活的对象从回收区拷贝到新的区块, 方便进行回收        特点:            region 管理, 每个区域可能是Eden 区, 也可能是Survivor区, 也可能是old区            并发标记和整理, 支持并发标记, 降低了STW             可预测的停顿时间            优先回收: 维护一个优先队列, 根据各个区域回收的价值(回收成本和收益) 决定哪些要优先回收        G1 怎么解决浮动垃圾:            将对分割成多个region, 更加灵活的去管理和回收内存, 降低浮动垃圾的影响            垃圾回收的时候, 可以进行并发标记和整理, 最大限度的降低程序的停顿</code></pre><h2 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h2><pre><code class="hljs">    通过染色指针和读屏障技术解决了对象转移的问题, 从而降低了耗时        染色指针: 指针中存放了对象的一些信息, 例如对象是否被标记, 是否移动了, 相当于用空间换时间</code></pre><p>MaxGCPauseMillis<br>RSS 回收<br>zgc + jdk11</p><p>经验</p><ol><li><p>FullGc消除, young gc 从2秒到10ms 怎么做到的<br>背景: 每次演练后, 通过CAT 的老年代明显的上涨, 再过1-2周, 会导致应用发生OOM<br>1.1 FullGC 怎么消除<br>1.1.1 增加jvm 的OOM 文件dump, -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;${DUMP_LOG_DIR}<br>1.1.2 主动去dump 文件 jmap -dump:live,format&#x3D;b,file&#x3D;test.hprof pid<br>1.1.3 将dump 下来的文件导入到MAT上<br>1.1.4 查看堆上的内存占用<br>1.1.5 发现有个对象占用特别高, 但是该对象也是需要常驻内存的, 该内存具体使用的是哪些客户端正在监听该配置文件, 每次配置推送的时候需要通过该对内存找到有哪些客户端正在使用该配置文件,从而将最新的版本好内容推送给客户端。<br>具体流程如下:</p></li><li><p>根据变更配置文件去找到对应的监听机器, 其中数据结构如下</p></li><li><p>行是ip, 列是ConfigMeta, value 是Cache&lt;Listener, Listener&gt;&gt;,<br>3.1 出发点是有哪些IP 用了这个配置文件, 因此key 是IP, value 是configMeta, 然后每个缓存用的是Listener<br>3.2 从机器出发, 机器的Ip 是固定,  当机器重启后, IP 出现了漂移, ip1在应用A 读取的配置是a,b,c 经过漂移后, ip1在应用B 下面读取的配置是e，f,g. 其中a,b,c 的数据不会被删除掉, 从而导致内存越用越多<br>3.3 更改数据结构, 将监听列表从table 换成了一个map, 换成从配置文件的角度出发, k 是configMeta, value 是cache<Listener>。 每个配置文件有哪些客户端正在使用,</p></li><li><p>如果解决yong gc 比较耗时比较高的问题<br>2.1 其中yong 区的比例是5<br>2.1.1  设置 MaxGCPauseMillis 到100ms<br>2.1.2 jdk1.8 默认的是新生代比列是5%, 调整 G1NewSizePercent 的比列到30,<br>2.1.3 结果: 对上面设置了以后yong gc 时间还是在1秒左右<br>yong gc 的频率从原来的7几次降低到了3次, 然后此时yong gc 的频率下来了, 但是每次的时间从原来的 300 ms 变成了450ms左右</p></li><li><p>其中总的耗时仍然为1分钟1.5 秒左右</p></li><li><p>最后将g1 替换成了zgc<br>根据g1 的算法<br>G1 里面的yong gc采用标记-复制的算法<br>复制的时候用户线程和GC线程无法并行处理</p></li><li><p>并发标记:在用户线程运行的同时, GC 线程 从root 对象出发, 标记会并发的标记存活对象, 这个过程是和用户同时进行的</p></li><li><p>初始标记:<br>2.1 初始标记: 从root 对象出发, 标记所有root 对象(需要STW), 时间比较短, 由于root 对象比较少<br>2.2 并发标记: 再从root 对象到可直接到达的对象 有哪些对象可达, 其中应用线程和GC线程可以同时去处理<br>2.3 再标记: 在并发2.2 中过程中发生变化的对象, 需要STW</p></li><li><p>确定回收集<br>进行最后的一次标记, 标记哪些对象需要回收, 需要STW</p></li><li><p>删选回收<br>采用复制算法, 会进行存活对象的移动<br>在次过程是需要STW的, 这个过程中为什么耗时比较高?????? 复制过程的耗时与对象的存活数量以及对象的复杂度成正比, 并且是没办法和用户线程去并行处理的，这个过程如果进行和用户线程进行并行处理, 会导致指针无法确认对象的问题<br>1.1 并发标记在初始标记之前的目的: 并发标记是用户线程和GC线程可以同时进行的, 但是在并发标记的时候可能会有新的对象被分配和标记, 因此在并发标记完成后, 再进行准确的初始标记, 用来获得准确的对象, 目的是可以准确的利用并发标记的优势, 将第GC 对程序的影响, 提高回收的准确率<br>G1 是将整个堆的空间分成多个大小的内存区域, 每个内存区域即可以是yong 区的一部分, 也有可能是old 区的一部分,其中我们指定的是4M<br>2.5 最终考虑升级到 zgc<br> zgc 相比较于g1 的gc 方式, 有了完全的提升<br>2.6 带来影响CPU 负载会有上升<br>GC 算法</p></li><li><p>不过 G1 为了解决 CMS 并发清理导致内存碎片化的问题，使用了复制算法转移对象，这样如果在转移过程中 GC 线程和用户线程并行，会导致指针无法准确定位对象的问题</p></li><li><p>zgc: 采用内存分区，使用染色指针和读屏障解决了复制算法并发转移对象导致的指针无法准确定位对象的问题<br>染色指针: 每个对象的指针在存储时都包含了附加的信息，用于表示对象的状态，比如是否是可达对象、是否需要被回收等<br>读屏障: 在 ZGC 中，读屏障用于捕获并记录正在被并发标记的对象引用，以便在后续的并发标记阶段中正确地标记这些对象。读屏障能够保证并发标记的准确性，防止对象在标记过程中被移动或修改引用关系导致的错误标记。</p></li></ol><p>原来是把GC 的标记放在了对象头上去, zgc 是将GC 的标记放在了指针中<br>M0,M1, Remapped<br>mmap 地址映射<br>读屏障<br>对象引用指针<br>  : 之前: GC 的标记信息放在对象头上去<br>  : 之后: GC 的标记信息直接放在引用指针上去<br>ZGC 过程:<br>  标记 -&gt; 转移<br>  完全做到了和用户进程的并发去处理<br>    并发标记: 使用读屏障的并发标记, 访问对象时插入特殊的屏障来跟踪对象的引用关系<br>    并发整理:<br>    并发引用重定位: 使用并发引用重定位去更新引用对象, 对象移动的时候, 可以正确更新对象的引用</p><p>  具体实现: 通过着色指针和读屏障技术<br>    读屏障技术: 解决对象发生转移, 对象地址未及时更新的情况, 读屏障在对象发生转移后, 会将读出来的指针更新到对象地址上去<br>      怎么判断是否发生移动, 通过着色指针<br>    空间换时间<br>      M0 , M1, Remapped</p><ol start="3"><li>升级了zgc, 大概每次过1 个月左右, 应用发生了OOM, 在内部的监控上面发现应用机器的RSS内存从12G 慢慢上涨到15G, 导致应用被操作系统kill了, 这个是在使用g1 的时候没有发生过的<br>3.1 如何解决zgc 导致应用发生了OOM<br>通过pmap 去查看堆外内存的占用<br>发现rss 内存占用变高, 导致进程被kill, 但是堆内的空间占用正常，通过pmap 查看java 内存映射有较多的64M 内存占用的问题, 分析得到glibc 在申请新的内存占用的时候, 非主分配的内存占用通过mmap申请, 其中64 位机器的申请虚拟内存位64M, 并且创建后不会被回收, 因此查看其他分配内存的策略, 采用jemalloc 去进行申请内存</li></ol><p>另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。<br>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance &#x3D; new Singleton(); 这段代码其实是分为三步执行：</p><ol><li>为 uniqueInstance 分配内存空间</li><li>初始化 uniqueInstance</li><li>将 uniqueInstance 指向分配的内存地址</li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。<br>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p><h2 id="依赖属性"><a href="#依赖属性" class="headerlink" title="依赖属性"></a>依赖属性</h2><p>synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReenTrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock 方法配合 try&#x2F;finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p><h2 id="功能对比"><a href="#功能对比" class="headerlink" title="功能对比"></a>功能对比</h2><h3 id="等待可中断"><a href="#等待可中断" class="headerlink" title="等待可中断"></a>等待可中断</h3><ul><li><strong>ReenTrantLock提供了一种能够中断等待锁的线程的机制</strong>，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li></ul><h3 id="可实现公平锁"><a href="#可实现公平锁" class="headerlink" title="可实现公平锁"></a>可实现公平锁</h3><ul><li><strong>ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</strong> ReenTrantLock默认情况是非公平的，可以通过 ReenTrantLock类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li></ul><h3 id="可实现选择性通知"><a href="#可实现选择性通知" class="headerlink" title="可实现选择性通知"></a>可实现选择性通知</h3><ul><li>synchronized关键字与wait()和notify&#x2F;notifyAll()方法相结合可以实现等待&#x2F;通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），<strong>线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify&#x2F;notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。<br>如果你想使用上述功能，那么选择ReenTrantLock是一个不错的选择。</li></ul><h2 id="ReentrantLock-和-ReentrantReadWriteLock"><a href="#ReentrantLock-和-ReentrantReadWriteLock" class="headerlink" title="ReentrantLock 和 ReentrantReadWriteLock"></a>ReentrantLock 和 ReentrantReadWriteLock</h2><p>ReentrantLock 和 synchronized 的区别在上面已经讲过了这里就不多做讲解。另外，需要注意的是：读写锁 ReentrantReadWriteLock 可以保证多个线程可以同时读，所以在读操作远大于写操作的时候，读写锁就非常有用了。</p><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>因此，在Java中可以使用synchronized来保证方法和代码块内的操作是原子性的。<br>在CPU和主存之间增加缓存，在多线程场景下就可能存在缓存一致性问题，也就是说，在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致。</p><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。<br>Java中的volatile关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用volatile来保证多线程操作时变量的可见性。<br>除了volatile，Java中的synchronized和final两个关键字也可以实现可见性。只不过实现方式不同，这里不再展开了。</p><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>在Java中，可以使用synchronized和volatile来保证多线程之间操作的有序性。实现方式有所区别：<br>volatile关键字会禁止指令重排。synchronized关键字保证同一时刻只允许一条线程操作。<br>好了，这里简单的介绍完了Java并发编程中解决原子性、可见性以及有序性可以使用的关键字。读者可能发现了，好像synchronized关键字是万能的，他可以同时满足以上三种特性，这其实也是很多人滥用synchronized的原因。<br>但是synchronized是比较影响性能的，虽然编译器提供了很多锁优化技术，但是也不建议过度使用。</p><h3 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h3><p>Java中的双亲委派模型是一种类加载机制，用于保证程序安全和稳定性。它是由启动类加载器（Bootstrap ClassLoader）、扩展类加载器（Extension ClassLoader）和应用程序类加载器（Application ClassLoader）组成的。<br>当一个类被加载时，Java虚拟机（JVM）首先会将该请求委派给父类加载器，如果父类加载器无法加载该类，那么会再委派给父类加载器的父类加载器，直到委派到最顶层的启动类加载器。<br>如果启动类加载器无法加载该类，那么会回到应用程序类加载器，它会尝试从自己的类路径中加载该类。如果应用程序类加载器还是无法加载该类，那么会回到扩展类加载器，它会尝试从扩展路径中加载该类。如果扩展类加载器也无法加载该类，那么最后会回到启动类加载器，它会尝试从JVM的核心类库中加载该类。<br>这种双亲委派模型保证了Java类的安全性和稳定性。因为父类加载器的加载机制是先加载自己的类路径下的类，只有在找不到该类时才会委派给自己的子类加载器。这样就避免了Java类被重复加载的问题，也避免了恶意代码的加载。<br>总结来说，Java双亲委派机制的加载顺序为：<br>当一个类加载器收到一个类加载请求时，它首先将该请求委派给其父类加载器。<br>如果父类加载器无法加载该类，它会将该请求委派给自己的父类加载器。<br>这个过程将一直持续到最顶层的启动类加载器。<br>如果启动类加载器也无法加载该类，那么它将回到应用程序类加载器，然后再回到扩展类加载器。<br>最后，如果所有的类加载器都无法加载该类，那么将会抛出ClassNotFoundException异常</p><h4 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h4><p>Java中的类加载过程分为3个步骤：加载、连接和初始化。下面我们来逐步了解它们的具体过程。<br>加载：类加载器首先会通过类的全限定名来查找并加载对应的类文件。在加载过程中，类文件中的静态变量、方法等信息都会被加载到JVM的方法区中，并且为类在方法区中创建一个Class对象。<br>连接：连接阶段又可以分为3个小阶段，分别是验证、准备和解析<br>2.1 验证：在这个阶段，类加载器会对类文件进行验证，以确保它们符合Java虚拟机规范，并且没有安全方面的问题。<br>2.2 准备：在准备阶段，类加载器会为类中的静态变量分配内存，并设置默认值（0或null），同时也会为静态变量关联上对应的符号引用（即指向该变量在常量池中的引用）。<br>2.3 解析：在解析阶段，类加载器会将类文件中的符号引用替换成直接引用，即将常量池中的符号引用指向具体的内存地址，这样类中的代码就可以直接使用这些变量或方法了。<br>初始化：在初始化阶段，类加载器会按照代码中的要求执行类的初始化，如执行静态代码块、初始化静态变量等。如果类的父类还没有被初始化，则会先初始化其父类。同时，在初始化阶段，JVM也会对类做一些必要的初始化检查，如检查是否存在抽象方法没有被实现等。<br>总结来说，Java类的加载过程分为三个阶段：加载、连接和初始化。在加载阶段，类文件会被加载到方法区中，并为类创建一个Class对象；在连接阶段，类文件会被验证、准备和解析；在初始化阶段，类的代码会按照要求被执行，同时也会进行一些必要的检查。</p>]]></content>
    
    
    <categories>
      
      <category>jvm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/08/22/web3/btc-market/"/>
    <url>/2023/08/22/web3/btc-market/</url>
    
    <content type="html"><![CDATA[<ol><li>token<br>  1.1 作用:<br>  1.2 过多 少? 后续激励, 分配</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/07/18/interview/mt/"/>
    <url>/2023/07/18/interview/mt/</url>
    
    <content type="html"><![CDATA[<ol><li>job</li><li>网关</li><li>serverless</li></ol><p>重点问网关<br>交叉面问配置中心</p><ol><li>有机器不可用怎么解决？？？？单点问题怎么解决</li><li>高并发、GC、如何排查GC、</li><li>大的请求体 隔离型问题。。。。 流量隔离、资源占用隔离、</li><li>插件化 （当前是没做的, 需要准备一下, 插件业务自己去写, 按照网关规范来做的）</li><li>业务的独立集群的划分,</li><li>实现层 用netty, 后端rpc 用rpc 框架 (http 单独)</li><li>配置中心整体架构(如何实现配置的秒级别更新)</li><li>大数据量的连接数压力</li><li>主从 -&gt; MGR 单元化 单元化 -&gt; MGR  -&gt; 主从</li><li>数组, 字符串. 给一个值 进行开根号</li></ol><p>1.1 BFF+sidecar<br>1.2 增强自身的可扩展性, 没有任何依赖, 出现问题的时候可以从本地复制文件, 直接copy 到已有的机器上去, 将已有的机器起来, 去进行承接流量<br>1.3 支持水平扩展</p><p>2.1 估算QPS的大小, 调整GC方式, 是yong gc 还是full GC, 还是被操作系统进行了OOM Killer 导致回收了<br>  2.1.1 CMS、G1、ZGC 三个之间的对比, 分别解决了什么问题, 怎么做到了提升<br>  12G的堆, 然后 5% 默认的话是600M, 调整到1.2G 新生代占比30%</p><p>  长轮训的时候每次带上2K大小的配置文件, 重新请求到服务端的压力为5W个客户端, 100 M &#x2F; 16台的 &#x3D; 6M 一次<br>  其中DB的配置文件5W个 变化3W 个, 每次变更文件差不多100 个 300 个批次, 3秒钟变更完成,</p><p>  长轮训请求时300次 每次请求的大小是 6M 单台, 一秒的话是</p><p>  每次拉去的时候配置文件大小为 10K 左右 缓存 -&gt; 磁盘 -&gt; DB<br>  300 次  -&gt; 单个大小为10K<br>  长轮训的带的信息为2K<br>  每个客户端携带的配置文件的个数为100个. groupId,dataId,profile,version。<br>    每次标记都从根roots出发<br>    CMS: (采用标记清除算法)<br>      初始标记(STW) -&gt; 并发标记 -&gt; 重新标记(STW) -&gt; 并发回收<br>      存在问题: 会产生内存碎片<br>    G1: (采用标记复制算法)<br>      不在将空间按照物理维度严格的划分为yong 区、old区, 将空间分割成多个大小区域相等的region,每个区域可能是属于yong 区, 也有可能是old区<br>      初始标记(STW) -&gt; 并发标记 -&gt; 最终标记(STW) -&gt; 删选回收(STW)<br>        删选回收会将一个region的复制及其移动<br>      存在问题: 删选回收中的STW 耗时和需要回收的对象大小成正比, 原因是G1 未能解决转移过程中准确定位对象地址的问题；<br>    ZGC: 初始标记 -&gt; 并发标记 -&gt; 重新标记 -&gt; 并发清理<br>      ZGC通过着色指针和读屏障技术，解决了转移过程中准确访问对象的问题<br>      通过染色指针将GC 信息放到了指针当中, 减少标记时的开销, 同时使用读屏障保证程序正在执行的时候, 可以准确的获取对象的状态</p><p>3.1 流程上杜绝, 自身进行限制, 对占用比较大的进行告警</p><p>4.1 实现了简单的插件化, 例如用户需要自定义配置限流参数, 跨域的配置. 对于一些需要复杂的插件化逻辑,<br>  例如加验签算法, 暂时没有.<br>  实现方式:<br>    做为一个脚本去进行运行,<br>    将自定义插件做为一个插件服务部署出来, 中间走RPC、接口调用,<br>  影响: 怕影响网关自身的性能, 要对占用的资源去进行把控</p><p>5.1 接入流程: 统一申请域名, 申请域名的时候说明场景, 将域名根据不同的类型分到不同的应用上去,<br>  如: 交易有关的,(第二级别) 对接银联的通道(专用集群)</p><p>6.1 机器节约了多少<br>  机器节约了30% 具体的是有一些应用专门哪来跑账务模型<br>8.1 针对请求过来很高的时候怎么去进行处理.<br>可能的瓶颈:<br> 从硬件到软件上去想, 硬件。网卡带宽 -&gt; 机器磁盘 -&gt; CPU 负载<br>  软件上 GC -&gt; 数据库<br>  内存(机器内存 + 堆上的内存)<br>  CPU 负载<br>  网络带宽<br>  数据库<br>  下游<br>  网络带宽 -&gt; 磁盘IO -&gt; CPU  -&gt; 数据库</p><p>配置中心<br>1.1 网络带宽怎么解决<br>1.2 磁盘IO  落磁盘的操作有哪些???<br>1.3 CPU 压力过高  是否有很多磁盘IO、GC 是否频繁<br>1.4 数据库 走缓存</p><p>单元化 做了哪些事情<br>8.1.1 请求接口异步化, 防止阻塞tomcat的线程资源<br>8.1.2 拉取数据<br>8.1.3 对于MGR 怎么去解决？？？<br>为什么要引入MGR. 对于配置中心来说, 高可靠、高可用是最重要的, DB 是配置中心的依赖, 为了保证DB 故障的时候配置中心仍然可以堆外可用, 同时公司内部的DB 主从切换是依赖于配置中心, 这个时候如何保证配置中心自身DB 的一个高可用,<br>方案1: 通过MHA 的通知. 具体流程如下:</p><ol><li>MHA 检测到主库异常, 选择新的主库, 通知发给配置中心</li><li>配置中心将DB的新的主库设置为主库, 由我们自身实现主从切换<br>问题: 切换过程是依赖于外部的MHA 事件检测, 主从数据在切换过程当中导致的数据可能会出现不一致,  例如在数据写到了主库上去, 但是发生了切换, 导致从库的数据没有.  配置中心对数据的一致性由更高的要求, 采用的 Paxos 算法, 实现了多主的复制, (在任意一个时刻, 只有一个提案会生效, 针对脑裂的时候, 就是不会有新的提案产生)<br>解决方案: oceanbase、mongoDB、MGR 支持分布式数据库, 主从切换</li><li>之前的数据库用的是mysql, 如果要迁移到mongoDB 的化要考虑做很大的改动, 原来放在mysql 的数据要迁移到mongo 上去。改动太大</li><li>oceanbase, 付费, 不考虑</li><li>使用mysql 的多主。客户端改动比较少, 可以去做到平滑的迁移<br>3.1 MGR<br>主要是利用了MGR 的故障检测和恢复、 自动故障转移能力、MGR的<br>带来的问题: 一致性延迟、复制冲突、部署和节点管理的复杂性<br>怎么解决的:<br>  一致性延迟, 当服务端收到通知后, 先去DB 里面去看一下配置是否存在, 如果不存在的化会定时一个时间轮探测一下, 100ms,300ms,500ms,1s 去DB 里面查找一下配置是否存在, 存在后再去通知客户端过来拉去<br>  复制冲突: 去避免复制冲突, 正常的时候, 只在一个节点上去进行写数据, 故障后才会转移到另外一个节点上去, 转移的顺序也是根据约定好的来的.<br>MGR 和 传统的MS 区别<br>  传统的主从复制是基于异步复制, 主库会把操作落到binlog 上去, binlog dump 线程会去通知从库, 将对应的binlog 内容同步给从库, 从库收到后写入到relay-log, 根据relay-log 在从库上进行响应的操作<br>  主从切换<br>  MHA 主从切换</li></ol><p>单元化:<br>  服务端下发机器列表的时候返回客户端本机房的信息</p><p>二面: 老板:</p><ol><li><p>最后的问题 抽象的问题???<br>1.1 你对自己怎么看, 有什么优势, 哪里做的不足</p></li><li><p>技术面<br>2.1 比较闷(性格)<br>说话可以慢慢说, 不需要着急, 把想表达的事情表达清楚<br>可以先想清楚后再去说</p></li><li><p>为什么要将tomcat换成netty<br>1.1 同步阻塞导致时间比较长, 需要对请求进行异步化处理<br>1.2 netty的解决方式<br>1.2.1 通过NIO 去实现异步非阻塞<br>1.2.2 基于事件驱动去进行处理, 收到请求后, 生成相应的事件放入事件队列, 然后通过eventLoop 去从事件中去获取事件, 并交给相应的handler 去进行处理<br>1.2.3 单线程处理, eventLoop 单线程去处理</p></li></ol><p>netty 使用nio 实现异步非阻塞,  通过selector选择非阻塞io, 使得一个线程可以同时处理多个请求 -&gt; event loop 再去调用对应的handler 去处理, 每个eventloop 是单线程去处理的<br>动态路由的功能, 相比较于netty<br>负载均衡的算法:</p><ol><li>随机</li><li>ShortestResponse<br>2.1 监听每个请求处理的时长, 将处理的时长放到cache 中<br>2.2 每次请求过来的时候,选择请求处理时长最短(无需考虑历史的平均耗时, 消除一些极端时间的影响)的进行转发,<br>  问题: response的时长不能代表后端服务的处理能力</li><li>RoundRobin</li><li>LeastActive(最少连接数)</li><li>ConsistentHash(一致性hash)</li><li>P2C<br>在可用的机器列表里面随机选择两个, 再在两个里边择优选择一个<br> 择优的根据:CPU、权重、延迟、客户端个数、用塞程度<br>大多数问技术<br>一面问的事情, 还是要继续准备</li></ol><p>多少多少数字(量化的数据要有理可依据, 数字继续准备好)<br>尽量去细节的事情.<br>GC 参数的调整. 主要是简历</p><p>前面问的问题继续准备一下</p><p>想清楚后去进行表达(逻辑性的.)<br>问题的重点在哪里, 不知道解决方案, 可以先说一下有哪些问题</p><p>题目(准备)</p><ol><li>产品是做什么的</li><li>角色的定位, 有多少人, 自己在里面做的定位是什么</li><li>为什么要自己的zk, 公司为什么不统一用公司的zk<br>  3.1 自己的ZK 除去存放机器的IP 信息, 还存放了到后端机器的路由的路由配置信息, 分组信息等信息<br>  3.2 自己的IP信息可以统一走注册中心过, 但是路由的配置中心是属于网关的专用数据<br>3.1 为什么不让服务去进行注册到注册到注册中心上去. 有这样的服务, 对于网关来说, 没有用到注册中心而已<br>  非java 语言怎么处理, 还有前端等应用<br>3.2 出现注册的状态不一样…… 怎么处理….. 从整体角度怎么去看待   防止单一节点故障<br>  3.2.1 每个服务的状态优先去保证自身服务处理的稳定性.？？？？？？<br>关于网关为什么后端IP节点的维护为什么不走注册中心, 反而要自己去进行维护</li></ol><p>3.3 CAP 网关的应该是侧着点在CP 还是 AP ZK 采用的是ZAB 协议<br>3.4 服务端如何去识别这个PATH 的流程<br>3.5 和nginx 对比. 为什么不考虑nginx<br>3.5.1 技术选型怎么考虑, 如果是你的话为什么不考虑nginx.<br>  公司主要的技术栈是用的java.  可配置性, 可扩展性, 使用Nginx 的话需维护lua脚本<br>  8583 协议转换 nginx 无法识别转换<br>3.5.2 nginx 性能考虑如何对比<br>  只是请求的路由转发,nginx 更好<br>3.5.3 路由权重怎么考虑. 怎么将请求转发到更优的可用机器上去<br>3.5.3.1. 如何根据用户的请求耗时去做请求转发机制<br>3.6. 异步化日志如何处理(CAT 封装, 为什么要做这个事情, 这个事情做了有什么好处, 线程出满了丢了怎么处理)<br>3.7 请求是异步来做的, 请求线程和回掉线程是否同样一个线程. 关于的CAT 的transaction 怎么串起来<br>3.8 serverless 思想, 适用于任务调度的场景(适用于场景做好match), 是否可以根据请求的流量去扩容机器来说<br>   当有100W个任务队列出来, 同时扩容怎么处理. 扩容机制是否需要去扩容(????????)<br>3.9 配置中心<br>  3.9.1 原理说清楚<br>  3.9.2 怎么去理解将请求转发到对应自己的机房上去<br>  3.9.3 DB 配置的批量变更怎么理解<br>  3.9.4 配置的信息是不是强一致的. (客户端的版本号怎么去处理的.)<br>  3.9.5 消除Full GC. Yong GC怎么去处理. G1 到zgc 具体的流程怎么去做了的()……………………..<br>  3.9.6 内部都用zgc<br>  3.9.7 问题排查(服务一直没有起来怎么去排查)<br>        3.9.7.1 工具的使用. jstack(thread dump) -&gt; gc(情况, CAT, 查看hprof 文件) -&gt;<br>        3.9.7.2 CPU高问题. 查看到CPU高的, 知道线程高的(火焰图)<br>3.10 个人的优缺点<br>  3.10.1 优点<br>  3.10.2 缺点</p><ol><li>自己在项目中的职责.</li></ol><p>网关:</p><ol><li>有机器不可用怎么解决？？？？单点问题怎么解决<br>  去中心化集群，网关的能力下沉到sdk sidecar (阿里怎么去处理)<br> BFF+sidecar<br> 自身的可扩展性. 强依赖属性</li><li>高并发、GC、如何排查GC、</li><li>每个请求的内存占用</li><li>估计实际需要占用的需要多大</li><li>预测每次GC的频率</li><li>full GC 通过MAT 查看大内存的占用情况<br>  yong gc 方式<br>  4.1 调整新生代的比列<br>  4.2 调整 MaxGCPauseMilis</li><li>ZGC 的<br>  堆外内存占用<br>  netty 堆外内存占用情况, 设置堆外内存的大小 MaxDirectMemorySize<br> CMS GC 算法<br> G1 GC 算法<br> ZGC GC 算法<br>  三者对比，改进了什么, 为什么要有新的算法出来</li><li>大的请求体 隔离型问题。。。。 流量隔离、资源占用隔离、<br>  3.1 一个body 较大的, 会有告警处理, 每次拿到所有的body 和 request 的大小, 当超过一定大小的时候会进行告警, 通知业务整改<br>  3.2 集群迁移. 每次申请域名的时候, 用户需要估计该域名的使用场景, 是否会进行占用过多的资源, 从物理上进行对资源的隔离<br>  3.3</li><li>插件化 （当前是没做的, 需要准备一下, 插件业务自己去写, 按照网关规范来做的）<br>4.1 可能遇到问题??? 资源占用的问题, 如何保证业务的资源不会去影响到网关的资源<br> 简单的插件或做了,<br> 但是复杂的插件没有</li></ol><p>业务的独立集群的划分,<br>美团 分组(group )  对应到虚拟域<br>美团网关: 配置放配置中心, DB 做为保底。<br>6. 实现层 用netty, 后端rpc 用rpc 框架 (http 单独)<br>网关节约了多少机器()</p><p>g1 到 zgc 为什么做, 怎么做, 做了效果</p><p>配置中心 推拉结合<br>大数据量 瓶颈  缓存穿透<br>长链接 连接数压力 MGR原理(主从, )  ::对比一下（MGR）<br>大概2100 个链接  </p><p>主体 简历</p><p>  数组 字符串<br>    给一个值 根号</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/07/17/interview/%E8%AF%A6%E7%BB%86%E6%95%B0%E6%8D%AE/"/>
    <url>/2023/07/17/interview/%E8%AF%A6%E7%BB%86%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<ol><li><p>FullGc消除, young gc 从2秒到10ms 怎么做到的<br>背景: 每次演练后, 通过CAT 的老年代明显的上涨, 再过1-2周, 会导致应用发生OOM<br>1.1 FullGC 怎么消除<br>1.1.1 增加jvm 的OOM 文件dump, -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;${DUMP_LOG_DIR}<br>1.1.2 主动去dump 文件 jmap -dump:live,format&#x3D;b,file&#x3D;test.hprof pid<br>1.1.3 将dump 下来的文件导入到MAT上<br>1.1.4 查看堆上的内存占用<br>1.1.5 发现有个对象占用特别高, 但是该对象也是需要常驻内存的, 该内存具体使用的是哪些客户端正在监听该配置文件, 每次配置推送的时候需要通过该对内存找到有哪些客户端正在使用该配置文件,从而将最新的版本好内容推送给客户端。<br>具体流程如下:</p></li><li><p>根据变更配置文件去找到对应的监听机器, 其中数据结构如下</p></li><li><p>行是ip, 列是ConfigMeta, value 是Cache&lt;Listener, Listener&gt;&gt;,<br>3.1 出发点是有哪些IP 用了这个配置文件, 因此key 是IP, value 是configMeta, 然后每个缓存用的是Listener<br>3.2 从机器出发, 机器的Ip 是固定,  当机器重启后, IP 出现了漂移, ip1在应用A 读取的配置是a,b,c 经过漂移后, ip1在应用B 下面读取的配置是e，f,g. 其中a,b,c 的数据不会被删除掉, 从而导致内存越用越多<br>3.3 更改数据结构, 将监听列表从table 换成了一个map, 换成从配置文件的角度出发, k 是configMeta, value 是cache<Listener>。 每个配置文件有哪些客户端正在使用,</p></li><li><p>如果解决yong gc 比较耗时比较高的问题<br>2.1 其中yong 区的比例是5<br>2.1.1  设置 MaxGCPauseMillis 到100ms<br>2.1.2 jdk1.8 默认的是新生代比列是5%, 调整G1NewSizePercent 的比列到30,<br>2.1.3 结果: 对上面设置了以后yong gc 时间还是在1秒左右<br>yong gc 的频率从原来的7几次降低到了3次, 然后此时yong gc 的频率下来了, 但是每次的时间从原来的 300 ms 变成了450ms左右</p></li><li><p>其中总的耗时仍然为1分钟1.5 秒左右</p></li><li><p>最后将g1 替换成了zgc<br>根据g1 的算法<br>G1 里面的yong gc采用标记-复制的算法<br>复制的时候用户线程和GC线程无法并行处理</p></li><li><p>并发标记:在用户线程运行的同时, GC 线程 从root 对象出发, 标记会并发的标记存活对象, 这个过程是和用户同时进行的</p></li><li><p>初始标记:<br>2.1 初始标记: 从root 对象出发, 标记所有root 对象(需要STW), 时间比较短, 由于root 对象比较少<br>2.2 并发标记: 再从root 对象到可直接到达的对象 有哪些对象可达, 其中应用线程和GC线程可以同时去处理<br>2.3 再标记: 在并发2.2 中过程中发生变化的对象, 需要STW</p></li><li><p>确定回收集<br>进行最后的一次标记, 标记哪些对象需要回收, 需要STW</p></li><li><p>删选回收<br>采用复制算法, 会进行存活对象的移动<br>在次过程是需要STW的, 这个过程中为什么耗时比较高?????? 复制过程的耗时与对象的存活数量以及对象的复杂度成正比, 并且是没办法和用户线程去并行处理的，这个过程如果进行和用户线程进行并行处理, 会导致指针无法确认对象的问题<br>1.1 并发标记在初始标记之前的目的: 并发标记是用户线程和GC线程可以同时进行的, 但是在并发标记的时候可能会有新的对象被分配和标记, 因此在并发标记完成后, 再进行准确的初始标记, 用来获得准确的对象, 目的是可以准确的利用并发标记的优势, 将第GC 对程序的影响, 提高回收的准确率<br>G1 是将整个堆的空间分成多个大小的内存区域, 每个内存区域即可以是yong 区的一部分, 也有可能是old 区的一部分,其中我们指定的是4M<br>2.5 最终考虑升级到 zgc<br> zgc 相比较于g1 的gc 方式, 有了完全的提升<br>2.6 带来影响CPU 负载会有上升<br>GC 算法</p></li><li><p>不过 G1 为了解决 CMS 并发清理导致内存碎片化的问题，使用了复制算法转移对象，这样如果在转移过程中 GC 线程和用户线程并行，会导致指针无法准确定位对象的问题</p></li><li><p>zgc: 采用内存分区，使用染色指针和读屏障解决了复制算法并发转移对象导致的指针无法准确定位对象的问题<br>染色指针: 每个对象的指针在存储时都包含了附加的信息，用于表示对象的状态，比如是否是可达对象、是否需要被回收等<br>读屏障: 在 ZGC 中，读屏障用于捕获并记录正在被并发标记的对象引用，以便在后续的并发标记阶段中正确地标记这些对象。读屏障能够保证并发标记的准确性，防止对象在标记过程中被移动或修改引用关系导致的错误标记。</p></li></ol><p>原来是把GC 的标记放在了对象头上去, zgc 是将GC 的标记放在了指针中<br>M0,M1, Remapped<br>mmap 地址映射<br>读屏障<br>对象引用指针<br>  : 之前: GC 的标记信息放在对象头上去<br>  : 之后: GC 的标记信息直接放在引用指针上去<br>ZGC 过程:<br>  标记 -&gt; 转移<br>  完全做到了和用户进程的并发去处理<br>    并发标记: 使用读屏障的并发标记, 访问对象时插入特殊的屏障来跟踪对象的引用关系<br>    并发整理:<br>    并发引用重定位: 使用并发引用重定位去更新引用对象, 对象移动的时候, 可以正确更新对象的引用</p><p>  具体实现: 通过着色指针和读屏障技术<br>    读屏障技术: 解决对象发生转移, 对象地址未及时更新的情况, 读屏障在对象发生转移后, 会将读出来的指针更新到对象地址上去<br>      怎么判断是否发生移动, 通过着色指针<br>    空间换时间<br>      M0 , M1, Remapped</p><ol start="3"><li>升级了zgc, 大概每次过1 个月左右, 应用发生了OOM, 在内部的监控上面发现应用机器的RSS内存从12G 慢慢上涨到15G, 导致应用被操作系统kill了, 这个是在使用g1 的时候没有发生过的<br>3.1 如何解决zgc 导致应用发生了OOM<br>通过pmap 去查看堆外内存的占用</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>算法</title>
    <link href="/2023/07/16/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2023/07/16/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><ol><li>确定组成部分<br>1.1 确定最后一步, 转化成子问题</li><li>转移方程<br>根据子问题定义直接得到<br>f(x) &#x3D; Min(f(x-2) + 1, f(x-5) + 1, f(x-7) + 1);</li><li>初始条件、和边界情况</li><li>计算顺序<br>f(0), f(1), f(2)</li></ol><h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1><ol><li>start + 1 &lt; end</li><li>mid &#x3D; start + (end - start) &#x2F; 2</li><li>A[mid] &#x3D;&#x3D;, &lt; , &gt; 和 target 之间的关系, 调整start 或者是end的位置</li><li>A[start] A[end] 和 target 之间的关系</li></ol><h2 id="first-position-或者是last-position"><a href="#first-position-或者是last-position" class="headerlink" title="first position 或者是last position"></a>first position 或者是last position</h2><p>rotated sorted array<br>ro<br>O(n) -&gt; O(log(n))<br>对于旋转排序的进行二分查找<br>在3 里面要判断A[start] A[mid] 和target 之间的关系<br>合并两个有序链表<br>两个有序数组合并后的中位数</p><h2 id="三步反转"><a href="#三步反转" class="headerlink" title="三步反转"></a>三步反转</h2><p>4 -&gt; 5 -&gt; 1 -&gt; 2 -&gt; 3<br>[4, 5] -&gt; [1, 2, 3]<br>[5, 4] -&gt; [1, 2, 3]<br>[1, 2, 3, 4, 5]</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/07/06/web3/test/"/>
    <url>/2023/07/06/web3/test/</url>
    
    <content type="html"><![CDATA[<p>通过钱包给中间地址转账</p><ol><li>获取中间地址 通过订单号进行维护关系</li><li>构造UTXO</li></ol><p>sell:    -&gt; 生成psbt, 前端签名<br>  {<br>    address: 卖方地址<br>    inscription_num: 铭文数量<br>    location: tx_hash:tx_index<br>    price_in_sats: 价格<br>  }<br>  生成的psbt 什么样子 怎么生成出来<br>  psbt 做了什么事情</p><p>tb1p9ruurvgtf5w2xxmdxhpzzrlz9xupfa0dhxjzze93pj7a03z967hs3vplw0<br>tb1p9ruurvgtf5w2xxmdxhpzzrlz9xupfa0dhxjzze93pj7a03z967hs3vplw0<br>生成卖方的一个psbt</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">  未签名交易</span><br><span class="hljs-template-variable">  输入数据</span><br><span class="hljs-template-variable">  输出数据</span><br><span class="hljs-template-variable">&#125;</span><br></code></pre></td></tr></table></figure><p>后端收到请求后，需要获取地址对应的可用来支付的UTXO以及卖单的PSBT数据构建完整的买卖psbt(构建psbt node 去做)，发送给前端</p><p>卖单的Psbt 从库中可以获取<br>如果获取可支付的UTXO, 如果索引UTXO 在索引上被铭刻了, 是不是不能用了??</p><ol><li>如何获取某个地址的公钥<br>中间地址的UTXO 买家的UTXO<br>UTXO 如果被铭刻了 不可以用。 找到可用的UTXO, 需要用到索引</li></ol><p>通过 getaddressinfo 获取公钥信息</p><ol><li>构造一个psbt, 包含特定的输入和输出, 不包含其他信息<br>  VIN<br> 加入uxto<br>PSBT<br>  input<br>  output<br>input 信息:<br>  {<br> 脚本<br> 公钥信息<br>  }</li><li>增加构建者的UTXO</li><li>增加卖方的UTXO</li><li>增加买方的UTXO</li></ol><p>pc_xie@bitcoin:~$ bitcoin-cli -rpcport&#x3D;8332 getrawtransaction “txId” true</p><p>bitcoin-cli -rpcwallet&#x3D;surawallet -rpcport&#x3D;8332 gettxout “tb1p9ruurvgtf5w2xxmdxhpzzrlz9xupfa0dhxjzze93pj7a03z967hs3vplw0” 1</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>基础概念</title>
    <link href="/2023/06/29/web3/btc%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/06/29/web3/btc%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<ol><li>UTXO:Unspent Transaction (TX) Output（未花费交易输出）</li><li>P2SH:Pay To Script Hash</li><li>P2PKH:Pay-To-PubKey Hash</li></ol><h1 id="UTXO"><a href="#UTXO" class="headerlink" title="UTXO"></a>UTXO</h1>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<br>  <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&quot;locktime&quot;</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-string">&quot;vin&quot;</span>: [<br>      &#123;<br>          <span class="hljs-comment">// 说明这个vin 是来源于哪一笔交易, 表明这比交易要花费的是属于哪一笔交易</span><br>          <span class="hljs-string">&quot;txid&quot;</span>: <span class="hljs-string">&quot;7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18&quot;</span>,<br>          <span class="hljs-comment">// 索引。一笔交易可能产生多个UTXO存放在数组中，该索引即为UTXO在数组中的下标。通过(txid, vout)就能检索到交易中的UTXO</span><br>          <span class="hljs-string">&quot;vout&quot;</span>: <span class="hljs-number">0</span>,<br>          <span class="hljs-comment">//解锁脚本，用于解锁(txid, vout)所指向的UTXO, 用于对vout 中的scriptPubKey进行解锁</span><br>          <span class="hljs-string">&quot;scriptSig&quot;</span>: <span class="hljs-string">&quot;3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf&quot;</span>,<br>          <span class="hljs-string">&quot;sequence&quot;</span>: <span class="hljs-number">4294967295</span><br>      &#125;<br>  ],<br>  <span class="hljs-string">&quot;vout&quot;</span>: [<br>      <span class="hljs-comment">// 0.015 去了公钥为 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 的地址</span><br>      &#123;<br>          <span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-number">0.015</span>,<br>          <span class="hljs-comment">// 通常称为锁定脚本，决定了谁可以花费这笔UTXO，只有提供了正确的解锁脚本才能解锁并花费该UTXO；</span><br>          <span class="hljs-string">&quot;scriptPubKey&quot;</span>: <span class="hljs-string">&quot;OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG&quot;</span><br>      &#125;,<br>      <span class="hljs-comment">// 0.0845 去了公钥为 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 的地址</span><br>      &#123;<br>          <span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-number">0.0845</span>,<br>          <span class="hljs-string">&quot;scriptPubKey&quot;</span>: <span class="hljs-string">&quot;OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG&quot;</span><br>      &#125;<br>  ]<br>&#125;<br><br>``` java<br>&#123;<br>    <span class="hljs-comment">// 说明这个vin 是来源于哪一笔交易, 表明这比交易要花费的是属于哪一笔交易</span><br>    <span class="hljs-string">&quot;txid&quot;</span>: <span class="hljs-string">&quot;7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18&quot;</span>,<br>    <span class="hljs-comment">// 索引。一笔交易可能产生多个UTXO存放在数组中，该索引即为UTXO在数组中的下标。通过(txid, vout)就能检索到交易中的UTXO</span><br>    <span class="hljs-string">&quot;vout&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-comment">//解锁脚本，用于解锁(txid, vout)所指向的UTXO, 用于对vout 中的scriptPubKey进行解锁</span><br>    <span class="hljs-string">&quot;scriptSig&quot;</span>: <span class="hljs-string">&quot;3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf&quot;</span>,<br>    <span class="hljs-string">&quot;sequence&quot;</span>: <span class="hljs-number">4294967295</span><br>&#125;<br>``` vin<br><br></code></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-string">&quot;vout&quot;</span>: [<br>    <span class="hljs-comment">// 0.015 去了公钥为 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 的地址</span><br>    &#123;<br>        <span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-number">0.015</span>,<br>        <span class="hljs-comment">// 通常称为锁定脚本，决定了谁可以花费这笔UTXO，只有提供了正确的解锁脚本才能解锁并花费该UTXO；</span><br>        <span class="hljs-string">&quot;scriptPubKey&quot;</span>: <span class="hljs-string">&quot;OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG&quot;</span><br>    &#125;,<br>    <span class="hljs-comment">// 0.0845 去了公钥为 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 的地址</span><br>    &#123;<br>        <span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-number">0.0845</span>,<br>        <span class="hljs-string">&quot;scriptPubKey&quot;</span>: <span class="hljs-string">&quot;OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG&quot;</span><br>    &#125;<br>]<br></code></pre></td></tr></table></figure><h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1><p>脚本决定了接收方可以如何花费收到的, BTC交易时的流程:发起交易时，发送方会在交易中放入一个叫作 “PubKey Script（又称锁定脚本）”的脚本。接收方（在日后花费时）需要生成一个 “签名脚本（又称解锁脚本）” ，是满足 PubKey 脚本的数据参数的集合。签名脚本在代码中又被叫作 “scriptSig”。</p><ol><li>锁定脚本(scriptPubKey)<br>  需要提供接受方的公钥地址 写入公钥的hash<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">OP_DUP OP_HASH160 <span class="hljs-tag">&lt;<span class="hljs-name">公钥哈希</span>&gt;</span> OP_EQUALVERIFY OP_CHECKSIG<br></code></pre></td></tr></table></figure></li><li>脚本解锁:<br>2.1 对 transactionId 采用hash 生成摘要D hash(tId)<br>2.2 通过私钥对 D 加密生成数字签名S E(privateKey, hash(tId)) &#x3D;》 S<br>2.3 将公钥和签名S写入到脚本中, 生成scriptSig, 进行广播 (publicKey,S)  &#x3D;&gt; 广播<br>2.4 广播验证流程:<br> 2.4.1 对解锁脚本中公钥进行hash, 确认和锁定脚本中的公钥hash是否相同<br> 2.4.2 对收到的交易hash生成出摘要D<br> 2.4.3 用公钥publicKey对签名S中获取摘要D, 判断和2.4.2 是否相同<br>2.5 针对2.1 生成<br>  2.5.1 signrawtransaction</li></ol><p>创建交易:调用 createrawtransaction 依赖于 signrawtransaction</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;签名&gt;</span> <span class="hljs-section">&lt;公钥&gt;</span><br></code></pre></td></tr></table></figure><h1 id="脚本类型"><a href="#脚本类型" class="headerlink" title="脚本类型"></a>脚本类型</h1><h2 id="Pay-to-ScriptHash-P2SH"><a href="#Pay-to-ScriptHash-P2SH" class="headerlink" title="Pay-to-ScriptHash (P2SH)"></a>Pay-to-ScriptHash (P2SH)</h2><h2 id="segwit"><a href="#segwit" class="headerlink" title="segwit"></a>segwit</h2><h2 id="MAST（默克尔抽象语法树）"><a href="#MAST（默克尔抽象语法树）" class="headerlink" title="MAST（默克尔抽象语法树）"></a>MAST（默克尔抽象语法树）</h2><h2 id="Schnorr-签名"><a href="#Schnorr-签名" class="headerlink" title="Schnorr 签名"></a>Schnorr 签名</h2><h2 id="比特币-Taproot"><a href="#比特币-Taproot" class="headerlink" title="比特币 Taproot"></a>比特币 Taproot</h2><p>commit<br>  创建了一个包含铭文内容的Taproot的输出<br>reveal<br>  消费由commit 创建的输出, 从而在链上揭示了铭文<br>如果不用两阶段的花, 信息会一直存储在交易的输出中, 只要这笔交易未消费, 那一直存在于UTXO中,  witeness 让铭文写入到链上, 但是没有在UXTO 模型中<br>铭刻是在输入的UTXO的第一个聪上进行, 铭文内容包含在input中</p><p>由于Taproot脚本的消费只能从已经存在的Taproot输出中进行，因此，铭文采用了两阶段的提交&#x2F;揭示流程。首先，在提交交易中，创建了一个承诺包含铭文内容的脚本的Taproot输出。然后，在揭示交易中，消费了由提交交易创建的输出，从而在链上揭示了铭文内容。<br>这种做法大大降低了对资源的消耗。如果不使用P2TR，见证信息会存储在交易的输出中。这样，只要这笔输出未被消费，见证信息就会一直存储在UTXO集中。相反，如果使用了P2TR，见证信息不会出现在提交阶段生成的交易中，因此它不会被写入UTXO集。只有当这笔UTXO被消费时，见证信息才会在揭示阶段的交易输入中出现。 P2TR让元数据能够写入比特币区块链，但却从未出现在UTXO集中。由于维护&#x2F;修改UTXO集需要更多的资源，因此这种做法可以节省大量资源。</p><p>铭刻是在其输入的UTXO对应的第一个聪上进行，铭文内容包含在显示交易的输入中。根据上文介绍的对于聪的流转、跟踪的介绍，这个被铭刻上特殊内容的聪可以被转移、购买、出售、丢失和恢复。需要注意的是，不可以重複铭刻，否则后面的铭文是无效的</p><p>在Commit交易中，创建了一个提交给包含铭文内容的脚本的taproot输出。其次，在reveal交易中，由commit交易创建的输出被花费，揭示链上的铭文内容</p><p>参考:<br><a href="https://aandds.com/blog/bitcoin-tx.html#0a3fd165">https://aandds.com/blog/bitcoin-tx.html#0a3fd165</a><br><a href="https://www.hellobtc.com/kp/du/07/4291.html">https://www.hellobtc.com/kp/du/07/4291.html</a><br><a href="https://101.132.169.39/article/5782">https://101.132.169.39/article/5782</a></p>]]></content>
    
    
    <categories>
      
      <category>btc</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ThreadLocal</title>
    <link href="/2023/06/14/jdk/threadLocal/"/>
    <url>/2023/06/14/jdk/threadLocal/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>提供了一个线程的局部变量, 通过get(), set() 方法访问线程自己的值, 实现线程之间的隔离</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>Thread 类有一个ThreadLocal.ThreadLocalMap 类型的变量threadLocals, 相当于每个线程都有自己的一个threadLocalMap, 其中threadLocalMap 是ThreadLocal的静态内部类, 通过自身内部的entry 来实现数据值的存储</p><h2 id="实现隔离原理"><a href="#实现隔离原理" class="headerlink" title="实现隔离原理"></a>实现隔离原理</h2><p>Thread 维护了一个threadLocals的局部变量, 当需要使用ThreadLocal去存储数据时, 首先获取到ThreadLocal实例, 并且ThreadLocal的实例作为key, 将要存储的value 值放入到当前线程的threadLocals的Entry 中, 当要获取值的时候, 通过ThreadLocal的实例作为key, 从当前线程的threadLocals中获取, 因为每个线程维护的是自己的threadLocals, 每个线程都有自己的变量, 不存在数据共享的问题, 实现了线程的隔离</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-comment">// 1. 获取当前线程</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">// 2. 获取当前线程的threadLocals对象</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-comment">// 3. 判断threadLocals对象是否初始化</span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 已初始化则直接设置值</span><br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 未初始化则将当前设置的值作为初始值进行初始化</span><br>        createMap(t, value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;<br>    <span class="hljs-keyword">return</span> t.threadLocals;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>    t.threadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>         e != <span class="hljs-literal">null</span>;<br>         e = tab[i = nextIndex(i, len)]) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br><br>        <span class="hljs-keyword">if</span> (k == key) &#123;<br>            e.value = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>            replaceStaleEntry(key, value, i);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//Entry 是 继承于WeakReference</span><br>    <span class="hljs-comment">// * 所有对ThreadLocalMap 变更的操作都是通过threadLocal 来进行的, 当threadLocal 对象无法使用的时候</span><br>    <span class="hljs-comment">// *  所以，当我们用不了key（ThreadLocal对象）的API也就无法从ThreadLocalMap里取出指定的数据。</span><br>    <span class="hljs-comment">// *  因此当ThreadLocal 所属于的对象被回收后, 也就没办法通过接口去获取到数据, 需要自动回收对应的Entry对象</span><br>    <span class="hljs-comment">// *</span><br>    <span class="hljs-comment">// *  如果是强引用的话, 就会出现内存泄漏</span><br>    <span class="hljs-comment">// *      Thread -&gt; ThreadLocal.ThreadLocalMap -&gt; Entry[] -&gt; Enrty -&gt; key（threadLocal对象）和value</span><br>    <span class="hljs-comment">// *         里面的关系都是强引用, 即使这个对象已经没有被使用了, ThreadLocal 仍然在内存中会存在</span><br>    <span class="hljs-comment">// *   Entry的key被设计为弱引用就是为了让程序自动的对访问不到的数据进行回收提醒，所以，在访问不到的数据被回收之前，</span><br>    <span class="hljs-comment">// *   内存泄漏确实是存在的，但是我们不用担心，就算我们不调用remove，ThreadLocalMap在内部的set，</span><br>    <span class="hljs-comment">// *   get和扩容时都会清理掉泄漏的Entry，内存泄漏完全没必要过于担心</span><br>    tab[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> ++size;<br>    <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>        rehash();<br>    &#125;<br></code></pre></td></tr></table></figure><ol><li>获取当前threadLocal 在数组中的位置, 从前往后去遍历entry数组<br>1.1 如果当前元素为空,则直接跳出循环，将需要设置的数据存储在当前Entry中。<br>1.2 如果当前遍历的位置的Entry不为空, 并且该Entry的key与目标key一致，则直接将需要设置的value覆盖掉该Entry的value即可（覆盖操作）。<br>1.3 如果当前遍历的位置的Entry不为空并且该Entry的key为null，说明当前的Entry是过期数据，此时执行replaceStaleEntry()替换过期数据</li><li>循环结束后，调用cleanSomeSlots()做一次启发式清理，清理数组中过期的数据。</li><li>如果清理后的Entry数量sz还是大于扩容阈值时则 执行rehash() 进行探测式清理以及判断是否需要扩容</li></ol><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 获取当前线程</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">//每个线程 都有一个自己的ThreadLocalMap, 也就是局部变量 threadLocals, 返回了ThreadLocal.ThreadLocalMap</span><br>    <span class="hljs-comment">//ThreadLocalMap里就保存着所有的ThreadLocal变量</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//ThreadLocalMap的key就是当前ThreadLocal对象实例，</span><br>        <span class="hljs-comment">//多个ThreadLocal变量都是放在这个map中的</span><br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//从map里取出来的值就是我们需要的这个ThreadLocal变量</span><br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="hljs-number">1</span>);<br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> table[i];<br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == key)<br>        <span class="hljs-comment">//如果找到key，直接返回</span><br>        <span class="hljs-keyword">return</span> e;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">//如果找不到，就会尝试清理，如果你总是访问存在的key，那么这个清理永远不会进来</span><br>        <span class="hljs-keyword">return</span> getEntryAfterMiss(key, i, e);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>jdk</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/04/07/interview/%E5%8F%AF%E8%83%BD%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2023/04/07/interview/%E5%8F%AF%E8%83%BD%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="请求连接池的参数设置有什么经验-举一些例子"><a href="#请求连接池的参数设置有什么经验-举一些例子" class="headerlink" title="请求连接池的参数设置有什么经验, 举一些例子"></a>请求连接池的参数设置有什么经验, 举一些例子</h1><p>Netty 常用参数介绍:</p><ol><li>ChannelOption.SO_BACKLOG：设置服务器端 TCP 连接的请求队列大小，用于控制 TCP 连接的并发数。使用场景：在高并发的场景中，可以适当增大 SO_BACKLOG 参数来处理大量的连接请求。</li><li>ChannelOption.SO_REUSEADDR：设置是否允许地址复用，即允许多个 Channel 绑定到同一个本地地址和端口。使用场景：在服务器重启后，允许快速重新绑定到之前使用的地址和端口，减少连接失败的概率。</li><li>ChannelOption.SO_KEEPALIVE：设置是否开启 TCP KeepAlive 功能，用于探测连接是否还存活。使用场景：在长连接场景中，可以通过开启 SO_KEEPALIVE 参数来检测长时间没有活动的连接并进行相应处理，如断开连接或重新连接。</li><li>ChannelOption.TCP_NODELAY：设置是否开启 Nagle 算法，用于控制 TCP 发送数据的延迟。使用场景：在需要实时性较高的场景中，可以通过关闭 Nagle 算法来减少数据发送的延迟，提高数据传输的实时性。</li><li>ChannelOption.SO_LINGER：设置 TCP 关闭时的行为，包括等待关闭的时间和关闭时是否立即发送未发送完的数据。使用场景：在关闭连接时，可以通过设置 SO_LINGER 参数来控制关闭的行为，如等待关闭的时间或是否立即发送未发送完的数据。</li><li>ChannelOption.CONNECT_TIMEOUT_MILLIS：设置连接超时时间，用于控制连接建立的超时时间。使用场景：在连接建立时，可以通过设置 CONNECT_TIMEOUT_MILLIS 参数来控制连接的超时时间，防止长时间等待连接建立而导致的性能问题。</li><li>ChannelOption.ALLOCATOR：设置 ByteBufAllocator，用于配置分配 ByteBuf 内存的方式和策略。使用场景：可以通过设置不同的 ByteBufAllocator 来优化内存分配和管理的性能和内存占用。</li></ol><h1 id="为什么要拆分集群-集群之间的区别仅仅是资源配置的不同"><a href="#为什么要拆分集群-集群之间的区别仅仅是资源配置的不同" class="headerlink" title="为什么要拆分集群, 集群之间的区别仅仅是资源配置的不同?"></a>为什么要拆分集群, 集群之间的区别仅仅是资源配置的不同?</h1><p>拆分集群是为了防止一些异常的后端应用影响到其他的应用，例如有个应用A 的后端处理时间很长, 然后此时A的请求量会很高, 此时会导致A应用占用系统的资源过多, 或者A 要去拉取一些比较大的文件, 同时A的请求量比较高</p><h1 id="如果请求链路中有很多异步处理逻辑-CAT的TrasactionId是怎么传递的"><a href="#如果请求链路中有很多异步处理逻辑-CAT的TrasactionId是怎么传递的" class="headerlink" title="如果请求链路中有很多异步处理逻辑, CAT的TrasactionId是怎么传递的"></a>如果请求链路中有很多异步处理逻辑, CAT的TrasactionId是怎么传递的</h1><p>threadLocal 中上下文去传递对象</p><h1 id="K8s动态扩缩容-现在业界有哪些产品-定时上报QPS-在流量突然变大的情况下会不会有延迟"><a href="#K8s动态扩缩容-现在业界有哪些产品-定时上报QPS-在流量突然变大的情况下会不会有延迟" class="headerlink" title="K8s动态扩缩容, 现在业界有哪些产品? 定时上报QPS, 在流量突然变大的情况下会不会有延迟?"></a>K8s动态扩缩容, 现在业界有哪些产品? 定时上报QPS, 在流量突然变大的情况下会不会有延迟?</h1><p>  会有延迟的,</p><h1 id="不同集群和业务类别的swagger是怎么统一管理的-在开源方案上的基础上有做什么开发"><a href="#不同集群和业务类别的swagger是怎么统一管理的-在开源方案上的基础上有做什么开发" class="headerlink" title="不同集群和业务类别的swagger是怎么统一管理的, 在开源方案上的基础上有做什么开发?"></a>不同集群和业务类别的swagger是怎么统一管理的, 在开源方案上的基础上有做什么开发?</h1><h1 id="不同机房的数据怎么同步的"><a href="#不同机房的数据怎么同步的" class="headerlink" title="不同机房的数据怎么同步的?"></a>不同机房的数据怎么同步的?</h1><p>  通过数据库来做的, 以及每台机器的一个定时同步机制</p><h1 id="配置文件的批量变更-如果失败了怎么回滚-怎么做到原子操作的"><a href="#配置文件的批量变更-如果失败了怎么回滚-怎么做到原子操作的" class="headerlink" title="配置文件的批量变更, 如果失败了怎么回滚? 怎么做到原子操作的"></a>配置文件的批量变更, 如果失败了怎么回滚? 怎么做到原子操作的</h1><ol><li>每条数据通过版本号去做原子保证, 用户在批量变更的时候, 需要带上对当前应配置文件的一个版本号, 然后基于该版本号再去做变更, 如果此时发生了发, 通过应用、配置文件、版本号组成的唯一性索引, 去保证配置变更的原子性, 如果批量变更的时候, 有一个失败了, 则会导致所有的数据操作都进行回滚. 用的是spring的一个事务机制<br>  在 Spring 中，默认情况下，当更新 MySQL 数据时抛出唯一性异常（如 DuplicateKeyException），Spring 的事务管理器会将当前的事务标记为失败，并触发事务回滚。这意味着在更新过程中发生唯一性异常时，之前在同一事务中执行的所有数据库操作将会被回滚，包括之前的插入、更新、删除等操作。</li></ol><p>Spring 的事务管理器使用了声明式事务的方式，可以通过在方法上添加 @Transactional 注解来实现事务的控制。在默认的配置下，当抛出 RuntimeException 及其子类异常时，事务会被回滚。而 DuplicateKeyException 是 Spring 的 DataAccessException 的子类，而 DataAccessException 又是 RuntimeException 的子类，因此当发生唯一性异常时，事务会被回滚。</p><h2 id="事务失效场景"><a href="#事务失效场景" class="headerlink" title="事务失效场景:"></a>事务失效场景:</h2><ol><li>方法未被公开调用：只有通过代理对象调用被 @Transactional 注解标注的方法，事务才会生效。如果在同一个类内部调用该方法，而不是通过代理对象调用，事务将会失效。</li><li>异常未被捕获：事务默认只会在捕获到 RuntimeException 及其子类异常时才会回滚。如果方法抛出了非运行时异常（如 Checked Exception），或者异常被捕获并处理了，事务将会继续提交，不会回滚。</li><li>类或方法未被 Spring 管理：只有被 Spring 管理的类或方法上添加了 @Transactional 注解，事务才会生效。如果类或方法没有被 Spring 管理（例如没有被注解标记或者没有在配置文件中进行了配置），事务将不会生效。</li><li>方法被 final 修饰：如果被 @Transactional 注解标记的方法被 final 修饰，事务也会失效，因为 Spring 使用动态代理生成代理对象来管理事务，而 final 方法无法被代理。</li><li>事务传播级别不匹配：如果调用了另一个事务传播级别不兼容的方法（例如一个事务传播级别为 REQUIRED 的方法调用了一个事务传播级别为 NOT_SUPPORTED 的方法），事务可能会失效。</li><li>方法没有抛出异常：事务默认只在方法抛出异常时才会回滚，如果方法没有抛出异常，事务将会继续提交。</li></ol><h3 id="事务的传播级别"><a href="#事务的传播级别" class="headerlink" title="事务的传播级别:"></a>事务的传播级别:</h3><ol><li>REQUIRED（默认）：如果当前存在事务，则加入当前事务，如果当前不存在事务，则创建一个新事务。这是最常用的传播级别，表示事务方法需要在一个事务中执行，如果当前不存在事务则创建一个新的事务，如果当前已存在事务则加入该事务。</li><li>SUPPORTS：如果当前存在事务，则加入当前事务，如果当前不存在事务，则以非事务方式执行。这种传播级别表示事务方法不强制要求在一个事务中执行，如果当前不存在事务则以非事务方式执行。</li><li>MANDATORY：如果当前存在事务，则加入当前事务，如果当前不存在事务，则抛出异常。这种传播级别表示事务方法必须在一个事务中执行，如果当前不存在事务则抛出异常。</li><li>REQUIRES_NEW：无论当前是否存在事务，都创建一个新事务并在新事务中执行。这种传播级别表示事务方法需要创建一个新的事务，并在该新事务中执行，如果当前存在事务则将当前事务挂起。</li><li>NOT_SUPPORTED：以非事务方式执行，如果当前存在事务，则将当前事务挂起。这种传播级别表示事务方法需要在非事务方式下执行，如果当前存在事务则将当前事务挂起。</li><li>NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。这种传播级别表示事务方法必须在非事务方式下执行，如果当前存在事务则抛出异常。</li><li>NESTED：如果当前存在事务，则在嵌套事务中执行，如果当前不存在事务，则创建一个新事务。这种传播级别表示事务方法需要在一个嵌套事务中执行，嵌套事务是当前事务的子事务，可以独立提交或回滚。</li></ol><h1 id="JVM的有什么调优的经验-Young-GC为什么之前会有5秒-5秒到10毫秒是因为什么优化"><a href="#JVM的有什么调优的经验-Young-GC为什么之前会有5秒-5秒到10毫秒是因为什么优化" class="headerlink" title="JVM的有什么调优的经验? Young GC为什么之前会有5秒? 5秒到10毫秒是因为什么优化?"></a>JVM的有什么调优的经验? Young GC为什么之前会有5秒? 5秒到10毫秒是因为什么优化?</h1><p>  1: 检查是否有重复对象的创建, 发现为了进行数据预热, 读取数据量过多<br>  2: 默认的g1 的yong区的比列配置是5%, 为了防止频繁的yong gc, 将比列调整到了30, 此时yong gc 的频率有下降了,<br>  3: g1 的垃圾回收方式，相比较于zgc，从而引入了zgc<br>    3.1:<br>    标记阶段，即从GC Roots集合开始，标记活跃对象；<br>    转移阶段，即把活跃对象复制到新的内存地址上；<br>    重定位阶段，因为转移导致对象的地址发生了变化，在重定位阶段，所有指向对象旧地址的指针都要调整到对象新的地址上。</p><p>下面以G1为例，通过G1中标记-复制算法过程（G1的Young GC和Mixed GC均采用该算法），分析G1停顿耗时的主要瓶颈。<br>G1的混合回收过程可以分为标记阶段、清理阶段和复制阶段。<br>标记阶段停顿分析<br>初始标记阶段：初始标记阶段是指从GC Roots出发标记全部直接子节点的过程，该阶段是STW的。由于GC Roots数量不多，通常该阶段耗时非常短。<br>并发标记阶段：并发标记阶段是指从GC Roots开始对堆中对象进行可达性分析，找出存活对象。该阶段是并发的，即应用线程和GC线程可以同时活动。并发标记耗时相对长很多，但因为不是STW，所以我们不太关心该阶段耗时的长短。<br>再标记阶段：重新标记那些在并发标记阶段发生变化的对象。该阶段是STW的。<br>清理阶段停顿分析<br>清理阶段清点出有存活对象的分区和没有存活对象的分区，该阶段不会清理垃圾对象，也不会执行存活对象的复制。该阶段是STW的。<br>复制阶段停顿分析<br><strong>复制算法中的转移阶段需要分配新内存和复制对象的成员变量。转移阶段是STW的，其中内存分配通常耗时非常短，但对象成员变量的复制耗时有可能较长，这是因为复制耗时与存活对象数量与对象复杂度成正比。对象越复杂，复制耗时越长</strong> 。<br>四个STW过程中，初始标记因为只标记GC Roots，耗时较短。再标记因为对象数少，耗时也较短。清理阶段因为内存分区数量少，耗时也较短。转移阶段要处理所有存活的对象，耗时会较长。因此，G1停顿时间的瓶颈主要是标记-复制中的转移阶段STW。为什么转移阶段不能和标记阶段一样并发执行呢？主要是G1未能解决转移过程中准确定位对象地址的问题**。<br>相比较于zgc，全程采用并发回收, 因此我们引入了zgc 去进行优化<br>ZGC通过着色指针和读屏障技术，解决了转移过程中准确访问对象的问题，实现了并发转移。大致原理描述如下：并发转移中“并发”意味着GC线程在转移对象的过程中，应用线程也在不停地访问对象。假设对象发生转移，但对象地址未及时更新，那么应用线程可能访问到旧地址，从而造成错误。而在ZGC中，应用线程访问对象将触发“读屏障”，如果发现对象被移动了，那么“读屏障”会把读出来的指针更新到对象的新地址上，这样应用线程始终访问的都是对象的新地址。那么，JVM是如何判断对象被移动过呢？就是利用对象引用的地址，即着色指针’</p><h1 id="配置中心的集成测试怎么实现的-有simulation环境吗"><a href="#配置中心的集成测试怎么实现的-有simulation环境吗" class="headerlink" title="配置中心的集成测试怎么实现的? 有simulation环境吗?"></a>配置中心的集成测试怎么实现的? 有simulation环境吗?</h1><p>是模拟用户的配置变更行为, 在生产上搭建了一套环境, 自己创建不同场景的配置读取, 变更, 对比是否收到推送的通知。</p><p>单例中 volatile 中保证可见性和防止重排序, 但是没办法保证原子性, 加上sychronzied 可以保证原子性<br>原子性体现在对象的创建是一个原子性的, 包含了对象的属性的初始化</p><p>volatile 可以防止对象创建重排序导致拿到的对象中属性没有完全初始化好。</p><ol><li>分配内存空间</li><li>将各个属性初始话0值</li><li>将对象的引用赋值给变量.<br>如果不加volatile的话, 在分配好内存空间后, 由于重排序, 将3放到了2 之前, 导致 另外一个线程拿到的对象是属性还未完全初始化的, 禁止重排序</li></ol><p>线程安全体现在:</p><ol><li>可见性</li><li>原子性</li><li>禁止重排序<br>volailte 相比较于synchronzed 没有保证原子性和互斥性<br>final 保证可见性</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>zgc</title>
    <link href="/2023/04/06/jvm/zgc/"/>
    <url>/2023/04/06/jvm/zgc/</url>
    
    <content type="html"><![CDATA[<h1 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h1><p>标记-复制算法应用在CMS新生代（ParNew是CMS默认的新生代垃圾回收器）和G1垃圾回收器中。标记-复制算法可以分为三个阶段：<br>标记阶段，即从GC Roots集合开始，标记活跃对象；<br>转移阶段，即把活跃对象复制到新的内存地址上；<br>重定位阶段，因为转移导致对象的地址发生了变化，在重定位阶段，所有指向对象旧地址的指针都要调整到对象新的地址上。<br>下面以G1为例，通过G1中标记-复制算法过程（G1的Young GC和Mixed GC均采用该算法），分析G1停顿耗时的主要瓶颈。G1垃圾回收周期如下图所示：<br><img src="/../img/jdk/g1.png" alt="g1"><br>G1的混合回收过程可以分为标记阶段、清理阶段和复制阶段。<br>标记阶段停顿分析<br>初始标记阶段：初始标记阶段是指从GC Roots出发标记全部直接子节点的过程，该阶段是STW的。由于GC Roots数量不多，通常该阶段耗时非常短。<br>并发标记阶段：并发标记阶段是指从GC Roots开始对堆中对象进行可达性分析，找出存活对象。该阶段是并发的，即应用线程和GC线程可以同时活动。并发标记耗时相对长很多，但因为不是STW，所以我们不太关心该阶段耗时的长短。<br>再标记阶段：重新标记那些在并发标记阶段发生变化的对象。该阶段是STW的。<br>清理阶段停顿分析<br>清理阶段清点出有存活对象的分区和没有存活对象的分区，该阶段不会清理垃圾对象，也不会执行存活对象的复制。该阶段是STW的。<br>复制阶段停顿分析</p><h2 id="g1-耗时长原因"><a href="#g1-耗时长原因" class="headerlink" title="g1 耗时长原因"></a>g1 耗时长原因</h2><p>复制算法中的转移阶段需要分配新内存和复制对象的成员变量。转移阶段是STW的，其中内存分配通常耗时非常短，但对象成员变量的复制耗时有可能较长，这是因为复制耗时与存活对象数量与对象复杂度成正比。对象越复杂，复制耗时越长。<br>四个STW过程中，初始标记因为只标记GC Roots，耗时较短。再标记因为对象数少，耗时也较短。清理阶段因为内存分区数量少，耗时也较短。转移阶段要处理所有存活的对象，耗时会较长。因此，G1停顿时间的瓶颈主要是标记-复制中的转移阶段STW。为什么转移阶段不能和标记阶段一样并发执行呢？主要是G1未能解决转移过程中准确定位对象地址的问题。</p><h1 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h1><p>与CMS中的ParNew和G1类似，ZGC也采用标记-复制算法，不过ZGC对该算法做了重大改进：ZGC在标记、转移和重定位阶段几乎都是并发的，这是ZGC实现停顿时间小于10ms目标的最关键原因。<br>ZGC只有三个STW阶段：初始标记，再标记，初始转移。其中，初始标记和初始转移分别都只需要扫描所有GC Roots，其处理时间和GC Roots的数量成正比，一般情况耗时非常短；再标记阶段STW时间很短，最多1ms，超过1ms则再次进入并发标记阶段。即，ZGC几乎所有暂停都只依赖于GC Roots集合大小，停顿时间不会随着堆的大小或者活跃对象的大小而增加。与ZGC对比，G1的转移阶段完全STW的，且停顿时间随存活对象的大小增加而增加。<br><img src="/../img/jdk/zgc.png" alt="zgc"></p><h2 id="zgc-如何实现并发转移的复制"><a href="#zgc-如何实现并发转移的复制" class="headerlink" title="zgc 如何实现并发转移的复制"></a>zgc 如何实现并发转移的复制</h2><p>ZGC通过着色指针和读屏障技术，解决了转移过程中准确访问对象的问题，实现了并发转移。大致原理描述如下：并发转移中“并发”意味着GC线程在转移对象的过程中，应用线程也在不停地访问对象。假设对象发生转移，但对象地址未及时更新，那么应用线程可能访问到旧地址，从而造成错误。<code>而在ZGC中，应用线程访问对象将触发“读屏障”，如果发现对象被移动了，那么“读屏障”会把读出来的指针更新到对象的新地址上，这样应用线程始终访问的都是对象的新地址。那么，JVM是如何判断对象被移动过呢？就是利用对象引用的地址，即着色指针&#39;</code>。下面介绍着色指针和读屏障技术细节。</p>]]></content>
    
    
    <categories>
      
      <category>jvm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>netty 常见面试</title>
    <link href="/2023/04/03/netty/netty_interview/"/>
    <url>/2023/04/03/netty/netty_interview/</url>
    
    <content type="html"><![CDATA[<ol><li>Netty 的线程模型是什么？</li><li>Netty 的 ByteBuf 是什么？有什么作用？</li><li>Netty 的事件模型是什么？</li><li>Netty 的消息编解码器是什么？如何自定义编解码器？</li><li>Netty 的心跳机制是什么？如何实现？</li><li>Netty 如何处理粘包和拆包问题？</li><li>Netty 中的 ChannelHandler 是什么？有哪些常用的 ChannelHandler？</li><li>Netty 的异步处理机制是什么？有哪些常用的异步操作？</li></ol><h1 id="Netty-的线程模型是什么"><a href="#Netty-的线程模型是什么" class="headerlink" title="Netty 的线程模型是什么"></a>Netty 的线程模型是什么</h1><p>Netty 的线程模型是一个基于多线程的异步事件驱动模型。Netty 的线程模型有以下两个核心组件：<br>EventLoopGroup：用于管理所有的 EventLoop。可以看做是一个线程池，其中的每一个线程都负责处理一个或多个 Channel 的所有 I&#x2F;O 事件。<br>EventLoop：用于处理一个 Channel 的所有 I&#x2F;O 事件。每个 Channel 都会被分配一个 EventLoop，这个 Channel 的所有 I&#x2F;O 事件都会由这个 EventLoop 处理。<br>Netty 的线程模型中有以下两种不同的 EventLoopGroup 实现：<br>NioEventLoopGroup：基于 Java NIO 的实现。在 Linux 和 Mac OS X 系统上使用 epoll 作为事件驱动的方式，在 Windows 系统上使用 select 作为事件驱动的方式。</p><h2 id="EventLoopGroup"><a href="#EventLoopGroup" class="headerlink" title="EventLoopGroup"></a>EventLoopGroup</h2><p>Netty的EventLoopGroup是一组EventLoop的集合，每个EventLoop维护着一个Selector和一个线程。EventLoopGroup是一个工厂，可以创建新的EventLoop实例，可以配置它们的线程模型，将Channel注册到选择器上，并在I&#x2F;O事件发生时分配事件处理任务。<br>EventLoopGroup有两种实现：MultithreadEventLoopGroup和NioEventLoopGroup。MultithreadEventLoopGroup是一个抽象类，继承了EventExecutorGroup，提供了多线程执行器和事件循环功能。NioEventLoopGroup是MultithreadEventLoopGroup的具体实现，使用Java NIO库提供的多路复用选择器来监听网络I&#x2F;O事件，并将事件分配给注册到相应Channel的EventLoop线程处理。<br>在启动Netty应用程序时，通常会创建一个EventLoopGroup用于服务端监听传入的客户端连接请求，一个EventLoopGroup用于客户端向远程服务器发起连接请求。一旦连接建立，就会在一个或多个EventLoop实例中处理来自对端的消息。通过使用多个线程和多个EventLoop实例，Netty可以实现高性能、高并发的网络应用程序。</p><h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h2><p>在 Netty 中，EventLoop 是处理所有 I&#x2F;O 事件和请求的核心组件。它是一个处理事件的循环，每个事件循环都与一个线程相关联，并负责处理该线程中的所有事件。<br>EventLoop 线程模型采用单线程模型，一个 EventLoop 可以处理多个连接的 I&#x2F;O 事件，由于每个 EventLoop 都是单线程处理的，因此无需担心线程同步的问题。另外，EventLoop 线程与 Selector 线程是不同的，Selector 线程只是处理网络请求的 TCP 连接，并将它们注册到相应的 EventLoop 线程上。</p><h1 id="Netty-的-ByteBuf-是什么"><a href="#Netty-的-ByteBuf-是什么" class="headerlink" title="Netty 的 ByteBuf 是什么"></a>Netty 的 ByteBuf 是什么</h1><p>Netty 的 ByteBuf 是 Netty 网络通信框架中提供的字节缓冲区，是一个优化过的字节容器，比 JDK 标准库中的 ByteBuffer 更加高效，主要有以下特点：<br>支持高效的读写操作：ByteBuf 提供了一系列高效的读写操作，如 getXXX() 和 setXXX() 方法，使用起来比 JDK 的 ByteBuffer 更加简洁和方便。<br>支持动态扩容：ByteBuf 可以自动扩容，用户无需手动分配内存或扩容。<br>支持分片和复合：ByteBuf 支持将一个大的缓冲区分成多个小的缓冲区，以及将多个小的缓冲区合并成一个大的缓冲区，提高了内存使用效率。<br>可以自动释放：ByteBuf 支持引用计数机制，可以自动释放，避免了内存泄露问题。<br>由于 Netty 中网络通信数据都是通过 ByteBuf 进行传输的，因此在使用 Netty 进行网络编程时，需要掌握 ByteBuf 的使用方式，以提高网络通信的效率和性能。</p><h2 id="解决了什么问题"><a href="#解决了什么问题" class="headerlink" title="解决了什么问题"></a>解决了什么问题</h2><ol><li>零拷贝：ByteBuf 采用了基于读写索引的设计，底层通过 byte[] 数组和 ByteBuffer 实现，可以在不进行内存拷贝的情况下实现数据读写。</li><li>内存池：Netty 的 ByteBuf 使用了对象池（Object Pool）技术，通过对缓冲区的重用，减少了垃圾回收对应用程序的影响，提高了内存使用效率。</li><li>引用计数：ByteBuf 使用了引用计数技术来跟踪缓冲区的使用情况，从而能够在缓冲区不再被使用时及时地释放它的内存。</li><li>可扩展性：ByteBuf 可以实现内存分配的灵活性和可扩展性，可以动态地调整内存池大小和使用的内存分配算法，从而满足不同应用场景下的需求。</li></ol><h3 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h3><p>创建和销毁对象而带来的性能开销。Netty 中内存分配主要由 PooledByteBufAllocator 类来实现，它会根据内存大小的不同使用不同的内存池，以达到更高的内存使用效率和更低的内存分配成本。<br>内存回收主要通过引用计数的方式实现。每个 ByteBuf 都有一个计数器，当一个 ByteBuf 被分配时，计数器的初始值为 1，每当有一个新的 ByteBuf 引用该对象时，计数器加 1，反之则减 1。当计数器的值为 0 时，该 ByteBuf 会被释放并回收其内存。<br>此外，Netty 还支持一种称为 “池化” 的内存回收机制，即在池化的 ByteBuf 中，当计数器减为 0 时，并不是立即释放内存，而是将该 ByteBuf 放入池中，以便下次可以直接从池中获取该 ByteBuf，避免了频繁的内存分配和回收，提高了性能。<br>总之，Netty 的内存管理机制通过池化技术和引用计数的方式，有效地降低了内存分配和回收的成本，提高了系统的性能和可靠性。</p><h1 id="Netty-的事件模型是什么"><a href="#Netty-的事件模型是什么" class="headerlink" title="Netty 的事件模型是什么"></a>Netty 的事件模型是什么</h1><p>Netty 的事件模型基于 Reactor 模式，使用了一组多线程的核心组件：EventLoop、EventLoopGroup、Channel、ChannelPipeline 和 ChannelHandler 等，来支持网络通信应用的开发。整个事件模型由三部分组成：<br>EventLoop 和 EventLoopGroup：EventLoop 是一个处理事件的线程，负责执行注册到它上面的任务，如注册、绑定、读写 IO 等操作。EventLoopGroup 包含一组 EventLoop，用于管理它们的生命周期以及分配给 Channel 的 EventLoop。<br>Channel 和 ChannelPipeline：Channel 代表一个可以进行读写操作的通道，它可以关联一个 EventLoop 来处理 IO 事件。ChannelPipeline 是一个处理 IO 事件的拦截器链，用于定义 Channel 处理 IO 事件的顺序和流程。<br>ChannelHandler：ChannelHandler 是 ChannelPipeline 中的处理器，负责处理通道中的各种 IO 事件，例如读取数据、写数据、打开通道、关闭通道等等。通过添加不同的 ChannelHandler，可以实现对通道的不同操作处理，也可以将多个 ChannelHandler 组合成复杂的业务逻辑处理链。</p><h1 id="Netty-的消息编解码器是什么？如何自定义编解码器"><a href="#Netty-的消息编解码器是什么？如何自定义编解码器" class="headerlink" title="Netty 的消息编解码器是什么？如何自定义编解码器"></a>Netty 的消息编解码器是什么？如何自定义编解码器</h1><p>Netty 提供了许多预定义的消息编解码器，如 StringDecoder、StringEncoder、ByteToMessageDecoder、MessageToByteEncoder 等。这些编解码器可以方便地对二进制或文本数据进行编解码。<br>同时，Netty 也提供了自定义编解码器的方法。通常情况下，我们需要实现自定义的编解码器，可以继承 ByteToMessageDecoder 或 MessageToByteEncoder 等抽象类并实现其中的抽象方法。<br>在使用的时候，我们可以通过 pipeline 对象将编解码器添加到 Netty channel 中, ch.pipeline.addLast();</p><h1 id="Netty-的心跳机制是什么？如何实现"><a href="#Netty-的心跳机制是什么？如何实现" class="headerlink" title="Netty 的心跳机制是什么？如何实现"></a>Netty 的心跳机制是什么？如何实现</h1><p>在网络通信中，客户端和服务端需要保持长时间的连接，但是有时候网络环境不稳定，连接可能会在没有通信的情况下中断。为了解决这个问题，Netty提供了心跳机制，定期发送心跳消息来检测连接是否正常。<br>Netty的心跳机制通过IdleStateHandler实现。该类可以检测连接的空闲时间，当连接在指定时间内没有读取或写入数据时，就会触发相应的事件，如IdleStateEvent.READER_IDLE_STATE_EVENT、IdleStateEvent.WRITER_IDLE_STATE_EVENT和IdleStateEvent.ALL_IDLE_STATE_EVENT。可以通过覆盖userEventTriggered方法来处理这些事件，例如关闭连接或发送心跳消息</p><h1 id="Netty-如何处理粘包和拆包问题"><a href="#Netty-如何处理粘包和拆包问题" class="headerlink" title="Netty 如何处理粘包和拆包问题"></a>Netty 如何处理粘包和拆包问题</h1><p>Netty 是一个基于 NIO 的框架，它并不会自动处理 TCP 的粘包和拆包问题，这需要开发者自行实现。下面是几种常见的解决方案：</p><ol><li>消息定长：如果发送的消息固定长度，可以在消息头中添加消息长度信息，接收端在读取数据时按照消息长度读取数据即可。</li><li>特殊分隔符：在消息之间添加特定的分隔符，接收端通过分隔符识别出每个消息。</li><li>消息长度前缀：在消息头中添加消息长度信息，接收端先读取消息长度，再根据消息长度读取消息内容。</li><li>自定义协议：自定义协议中包含了消息类型、消息长度、消息体等信息，接收端可以根据协议解析出消息。<br>在 Netty 中，可以通过自定义解码器来处理粘包和拆包问题。例如，可以实现一个解码器，继承 LengthFieldBasedFrameDecoder 类，并指定消息的长度信息的位置和长度，这样在接收到数据时，就可以根据长度信息将消息正确地拆分出来。另外，Netty 也提供了一些内置的解码器，例如 DelimiterBasedFrameDecoder 和 FixedLengthFrameDecoder，可以用来处理特定的分隔符和定长消息的情况。</li></ol><h1 id="Netty-中的-ChannelHandler-是什么？有哪些常用的-ChannelHandler"><a href="#Netty-中的-ChannelHandler-是什么？有哪些常用的-ChannelHandler" class="headerlink" title="Netty 中的 ChannelHandler 是什么？有哪些常用的 ChannelHandler"></a>Netty 中的 ChannelHandler 是什么？有哪些常用的 ChannelHandler</h1><p>在 Netty 中，ChannelHandler 是处理网络事件的基本构件。它负责处理来自 I&#x2F;O 操作和状态更改的通知，例如连接的建立、数据读取、数据写入等等。通过添加或移除 ChannelHandler，我们可以自定义处理流程，以满足具体的业务需求。<br>以下是 Netty 中一些常用的 ChannelHandler：</p><ol><li>ChannelInboundHandler：用于处理入站数据的 ChannelHandler，例如读取客户端的请求数据或响应服务端的数据。</li><li>ChannelOutboundHandler：用于处理出站数据的 ChannelHandler，例如发送请求数据到服务端或响应客户端的数据。</li><li>ChannelDuplexHandler：同时实现了 ChannelInboundHandler 和 ChannelOutboundHandler 接口的 ChannelHandler，可以同时处理入站和出站数据。</li><li>SimpleChannelInboundHandler：ChannelInboundHandler 的一个简单实现，它自动释放处理完的数据，减少了开发人员的工作量。</li><li>IdleStateHandler：实现心跳机制的 ChannelHandler，可以检测连接的空闲状态并发送心跳包。</li><li>LengthFieldBasedFrameDecoder 和 LengthFieldPrepender：用于解决粘包和拆包问题的 ChannelHandler，可以根据自定义的协议格式进行数据的解析和封装。</li><li>LoggingHandler：用于打印日志的 ChannelHandler，可以方便地跟踪和调试网络事件的处理流程。<br>Netty 中的 ChannelHandler 是什么？有哪些常用的 ChannelHandler</li></ol><h1 id="netty-如何解决jdk的空转问题"><a href="#netty-如何解决jdk的空转问题" class="headerlink" title="netty 如何解决jdk的空转问题"></a>netty 如何解决jdk的空转问题</h1><p>Netty 通过定时器的方式来解决 NIO 的空转问题。当某个通道在一段时间内没有事件发生时，Netty 会关闭这个通道，然后在稍后重新创建这个通道，这样可以避免空转导致的资源浪费。<br>具体来说，Netty 的解决方案是通过实现一个 IdleStateHandler 类来实现定时器。当一个通道的读或写操作空转了一定的时间，IdleStateHandler 就会触发一个事件，然后我们可以在事件处理方法中关闭这个通道或者执行其他操作。<br>总的来说，Netty 通过定时器来检测空转的通道并主动关闭它们，避免了 NIO 的空转问题，提高了系统的性能。</p>]]></content>
    
    
    <categories>
      
      <category>netty</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP 协议</title>
    <link href="/2023/04/01/tcp/tcp_basic/"/>
    <url>/2023/04/01/tcp/tcp_basic/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a>TCP和UDP区别</h1><p>TCP 是面向连接的，具有可靠性的。<br>TCP 保证可靠性:</p><ol><li>序列号和确认号机制：每个TCP报文段都包含一个序列号和一个确认号,通过序列号和确认号机制，TCP可以保证数据的传输顺序和完整性，防止数据丢失或重复。</li><li>确认机制：接收方在成功接收到数据后，会向发送方发送一个确认消息，通知发送方数据已经接收成功。如果发送方没有收到确认消息，就会重传数据，以确保数据能够到达接收方。</li><li>超时重传机制：TCP会设置一个超时时间，如果在超时时间内没有收到确认消息，就会重传数据。重传的次数是有限制的，以避免无限制的重传造成网络拥堵。</li><li>滑动窗口机制：TCP会维护一个滑动窗口，用于限制发送方发送数据的速度。滑动窗口的大小会动态调整，以适应网络的情况。</li><li>流量控制和拥塞控制：TCP会根据网络的情况来调整发送数据的速率，以避免网络拥塞和数据丢失。流量控制和拥塞控制是TCP保证可靠性的重要手段，它们可以使TCP在不同的网络环境中都能够保持良好的性能</li></ol><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>TCP（Transmission Control Protocol）使用滑动窗口机制来进行可靠的数据传输和流量控制。滑动窗口是发送方和接收方之间的一个动态窗口范围，用于管理数据的传输和确认。<br>窗口大小: 无须等待确认应答, 而可以继续发送传输数据的最大值<br>滑动窗口的原理如下：</p><ol><li>发送窗口（Sending Window）：<br>1.1 发送方维护一个发送窗口，它是一个连续的字节序列，表示发送方已发送但还未得到确认的数据。<br>1.2 发送方根据接收方的确认来动态调整发送窗口的大小和位置。<br>1.3 可用窗口: 未发送但是总大小在接收方处理能力范围内的数据</li><li>接收窗口（Receiving Window）：<br>2.1 接收方维护一个接收窗口，表示接收方可以接收的数据范围。<br>2.2 接收方根据接收到的数据来动态调整接收窗口的大小和位置。</li><li>滑动窗口的操作：<br>3.1 发送方根据接收方发送的确认序号确定可以发送的数据范围，并将数据发送到发送窗口内的字节序列。<br>3.2 接收方收到数据后，确认并发送确认序号给发送方，表示接收方期望接收的下一个字节的序号。<br>3.3 发送方接收到确认后，将发送窗口向前滑动，丢弃已经确认的数据，为新的数据腾出空间。<br>3.4 如果发送方没有收到确认，发送窗口不会滑动，数据会被重传。</li></ol><p>滑动窗口的好处是可以实现流量控制和可靠性传输。通过动态调整发送和接收窗口的大小，发送方可以根据接收方的处理能力来控制发送的速率，避免过载。同时，接收方通过确认序号告知发送方已经成功接收的数据，如果发送方没有收到确认，可以进行重传以确保数据的可靠传输</p><h3 id="如何去解决死锁问题"><a href="#如何去解决死锁问题" class="headerlink" title="如何去解决死锁问题"></a>如何去解决死锁问题</h3><p>死锁问题解释: 服务端告诉客户端此时窗口大小为0，等过了一段时间后，自己有能力去处理了，告诉客户端的时候，由于网络问题，该报文丢失了，咋处理<br>解决办法:</p><ol><li>当客户端收到服务端的零窗口通知后，启动一个持续计时器</li><li>持续计时器到期后，发送一个零窗口探测报文进行探测，探测对方对方的窗口</li><li>如果对方的窗口值还是0，又重新启动持续计时器，不为0，则进行发送数据</li></ol><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>TCP（Transmission Control Protocol）拥塞控制是TCP协议的一个重要机制，用于在网络拥塞时控制数据的发送速率，以避免网络拥塞的发生或进一步恶化。TCP拥塞控制的主要目标是合理分配网络带宽，保持网络的稳定性和公平性, TCP拥塞控制使用以下几个算法和机制:</p><ol><li>慢启动（Slow Start）：当建立一个新连接或网络出现拥塞时，TCP协议会采用慢启动算法，逐渐增加发送方的窗口大小，以控制发送速度和网络负载。</li><li>拥塞避免（Congestion Avoidance）：在慢启动过程中，当拥塞窗口大小达到一定值时，TCP协议会进入拥塞避免阶段，采用线性或指数增加的方式逐渐增加发送方的窗口大小，以避免网络拥塞。</li><li>快速重传（Fast Retransmit）：当接收方收到失序数据或接收缓冲区满时，会发送重复确认消息（Duplicated Acknowledgement）。发送方在接收到一定数量的重复确认消息后，会判断当前数据包丢失并立即重传，以提高数据传输效率和可靠性。</li><li>快速恢复（Fast Recovery）：当发送方接收到一定数量的重复确认消息后，进入快速恢复阶段。在快速恢复阶段，发送方不再采用慢启动算法，而是将拥塞窗口的大小设置为当前窗口大小的一半，以避免网络拥塞。</li></ol><h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><p><a href="https://juejin.cn/post/6844903958624878606">https://juejin.cn/post/6844903958624878606</a><br>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。<br>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。<br>进行三次握手：<br>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 SYN_SEND 状态。<br>其中SYN&#x3D;1，初始序号seq&#x3D;x，SYN&#x3D;1的报文段不能携带数据，但要消耗掉一个序号。<br>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_RCVD 的状态。<br>在确认报文段中SYN&#x3D;1，ACK&#x3D;1，确认号ack&#x3D;x+1，初始序号seq&#x3D;y。<br>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。<br>确认报文段ACK&#x3D;1，确认号ack&#x3D;y+1，序号seq&#x3D;x+1（初始为seq&#x3D;x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。<br>发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并发回下一个SYN的另一端执行被动打开（passive open）。<br>在socket编程中，客户端执行connect()时，将触发三次握手。<br><img src="/../img/tcp/tcp_start_connection.png" alt="三次握手"></p><h2 id="为什么需要三次握手，两次不行吗？"><a href="#为什么需要三次握手，两次不行吗？" class="headerlink" title="为什么需要三次握手，两次不行吗？"></a>为什么需要三次握手，两次不行吗？</h2><p>三次握手的目的是为了确认ISN(初始化序列号)<br>假设使用两次握手，</p><ol><li>客户端发出一个第一个报文，但是因为网络原因，需要很久才到，此时由于超时重传，客户端重新发送了建立连接的请求</li><li>当服务端收到重发过来的建立连接后，对他进行响应</li><li>客户端发送数据</li><li>过了一段时间 第一个建立连接请求到了服务端，服务端进行响应，建立了连接，等待客户端发送数据</li><li>此时客户端不会认为需要发送数据，也不会发出数据</li></ol><p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p><h2 id="半连接队列"><a href="#半连接队列" class="headerlink" title="半连接队列"></a>半连接队列</h2><p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。<br>当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。<br>这里在补充一点关于SYN-ACK 重传次数的问题：<br>服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。<br>注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s……</p><h2 id="ISN-Initial-Sequence-Number-是固定的吗？"><a href="#ISN-Initial-Sequence-Number-是固定的吗？" class="headerlink" title="ISN(Initial Sequence Number)是固定的吗？"></a>ISN(Initial Sequence Number)是固定的吗？</h2><p>当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN。ISN可以看作是一个32比特的计数器，每4ms加1 。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。<br>三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。</p><h2 id="三次握手过程中可以携带数据吗？"><a href="#三次握手过程中可以携带数据吗？" class="headerlink" title="三次握手过程中可以携带数据吗？"></a>三次握手过程中可以携带数据吗？</h2><p>其实第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据<br>为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。<br>也就是说，第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。</p><h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><p>建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。<br>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。<br>刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p><p>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。<br>即发出连接释放报文段（FIN&#x3D;1，序号seq&#x3D;u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。<br>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。<br>即服务端收到连接释放报文段后即发出确认报文段（ACK&#x3D;1，确认号ack&#x3D;u+1，序号seq&#x3D;v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。<br>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。<br>即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN&#x3D;1，ACK&#x3D;1，序号seq&#x3D;w，确认号ack&#x3D;u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。<br>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过2MSL(2个报文最大生存周期)以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。其中2MSL 默认值为4分钟,<br>即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK&#x3D;1，seq&#x3D;u+1，ack&#x3D;w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</p><p>收到一个FIN只意味着在这一方向上没有数据流动。客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。<br><img src="/../img/tcp/tcp_finish_connection.png" alt="四次挥手"></p><h2 id="挥手为什么需要四次？"><a href="#挥手为什么需要四次？" class="headerlink" title="挥手为什么需要四次？"></a>挥手为什么需要四次？</h2><p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，”你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。</p><h2 id="2MSL等待状态"><a href="#2MSL等待状态" class="headerlink" title="2MSL等待状态"></a>2MSL等待状态</h2><p>默认为2分钟(120秒)<br>TIME_WAIT状态也成为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。<br>对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。<br>这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在2MSL结束后才能再被使用。</p><h2 id="四次挥手释放连接时，等待2MSL的意义"><a href="#四次挥手释放连接时，等待2MSL的意义" class="headerlink" title="四次挥手释放连接时，等待2MSL的意义?"></a>四次挥手释放连接时，等待2MSL的意义?</h2><p>MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。<br>两个理由：</p><ol><li>保证客户端发送的最后一个ACK报文段能够到达服务端。<br>为了保证客户端发送的最后一个ACK报文段能够到达服务器，需要等待一段时间，通常是2倍的最大报文段生存时间（2MSL），这段时间内，服务器会保留相关连接的信息，以便在此期间内收到任何滞留在网络中的报文。如果服务器在这段时间内没有收到任何滞留报文，则可以关闭连接。这样做的目的是为了避免在后续建立新的连接时发生混淆，同时也确保了连接的正常关闭。<br>1.1. 假设客户端发送完ACK后不去等待直接进行关闭如果客户端在发送完ACK后不等待直接进行关闭，那么在网络原因等情况下，最后一个ACK报文段可能会丢失，导致服务器无法收到客户端发送的FIN-ACK的确认报文，从而无法正常进入关闭连接状态。此时，服务器会超时重传FIN-ACK报文，而客户端却已经关闭了连接。此时，服务器会收到客户端发送的RST报文，导致连接异常关闭。另外，如果客户端在2MSL时间内重新发送了一个新的连接请求，而这个连接请求的端口与之前的连接相同，服务器可能会收到之前连接的滞留报文，从而导致混淆。因此，2MSL的等待时间可以避免这种混淆的发生，保证连接的正常关闭。</li><li>防止“已失效的连接请求报文段”出现在本连接中。<br>客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</li></ol><h2 id="为什么TIME-WAIT状态需要经过2MSL才能返回到CLOSE状态？"><a href="#为什么TIME-WAIT状态需要经过2MSL才能返回到CLOSE状态？" class="headerlink" title="为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？"></a>为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？</h2><p>理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p><h2 id="TCP-的KeepAlive"><a href="#TCP-的KeepAlive" class="headerlink" title="TCP 的KeepAlive"></a>TCP 的KeepAlive</h2><p>如果一个时间段内没有任何连接的相关活动, TCP 保活机制就会启动, 每隔一定的时间间隔, 发送一个探测报文, 如果连续几个探测报文都没有得到响应, 则认为当前的连接已经死亡</p><h1 id="常见参数"><a href="#常见参数" class="headerlink" title="常见参数"></a>常见参数</h1><p>存放路径: &#x2F;Proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;</p>]]></content>
    
    
    <categories>
      
      <category>tcp</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库面试</title>
    <link href="/2023/03/10/mysql/mysql_interview/"/>
    <url>/2023/03/10/mysql/mysql_interview/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h1><h2 id="事物特性"><a href="#事物特性" class="headerlink" title="事物特性"></a>事物特性</h2><ol><li><strong>原子性</strong>（<code>Atomicity</code>）: 事务是一个原子操作单位，要么全部执行成功，要么全部回滚到事务开始前的状态。如果事务中的任何一个操作失败，整个事务都会被回滚，不会对数据库造成影响。</li><li><strong>一致性</strong>（<code>Consistency</code>）事务执行前后，数据库从一个一致的状态转变到另一个一致的状态。在事务开始之前和结束之后，数据库必须满足定义的完整性约束。</li><li><strong>隔离性</strong>（<code>Isolation</code>）： 事务的执行是相互隔离的，即每个事务的操作在逻辑上是独立的，不会互相干扰。事务之间的执行是并发的，但是对于每个事务来说，它感觉不到其他事务的存在。</li><li><strong>持久性</strong>（<code>Durability</code>）： 一旦事务提交，其所做的修改将永久保存在数据库中，即使发生系统故障或重新启动，也不会丢失已提交的事务的数据。</li></ol><h2 id="事物并发带来的问题"><a href="#事物并发带来的问题" class="headerlink" title="事物并发带来的问题"></a>事物并发带来的问题</h2><h3 id="脏读（Dirty-read）"><a href="#脏读（Dirty-read）" class="headerlink" title="脏读（Dirty read）"></a>脏读（Dirty read）</h3><p>一个事务读取到了另一个事务未提交的数据，导致读取到不一致或无效的数据。<br>例如：事务 1 读取某表中的数据 A&#x3D;20，事务 1 修改 A&#x3D;A-1，事务 2 读取到 A &#x3D; 19,事务 1 回滚导致对 A 的修改并为提交到数据库， A 的值还是 20。</p><h3 id="不可重复读（Unrepeatable-read）"><a href="#不可重复读（Unrepeatable-read）" class="headerlink" title="不可重复读（Unrepeatable read）"></a>不可重复读（Unrepeatable read）</h3><p>在同一个事务中，多次读取同一数据可能得到不同的结果。这是因为其他并发事务在事务执行期间修改了该数据<br>例如：事务 1 读取某表中的数据 A&#x3D;20，事务 2 也读取 A&#x3D;20，事务 1 修改 A&#x3D;A-1，事务 2 再次读取 A &#x3D;19，此时读取的结果和第一次读取的结果不同。</p><h3 id="幻读（Phantom-read）"><a href="#幻读（Phantom-read）" class="headerlink" title="幻读（Phantom read）"></a>幻读（Phantom read）</h3><p>在同一个事务中，多次查询同一个范围的数据，结果集中的行数可能不一致。这是因为其他并发事务在事务执行期间新增或删除了符合查询条件的数据。<br>例如：事务 2 读取某个范围的数据，事务 1 在这个范围插入了新的数据，事务 1 再次读取这个范围的数据发现相比于第一次读取的结果多了新的数据。</p><h3 id="丢失更新（Lost-Update）"><a href="#丢失更新（Lost-Update）" class="headerlink" title="丢失更新（Lost Update）"></a>丢失更新（Lost Update）</h3><p>多个事务同时更新同一行数据时，可能会发生数据覆盖的情况。最后提交的事务会覆盖之前提交的事务所做的修改，导致部分更新操作丢失。</p><h3 id="不可重复读和幻读有什么区别？"><a href="#不可重复读和幻读有什么区别？" class="headerlink" title="不可重复读和幻读有什么区别？"></a>不可重复读和幻读有什么区别？</h3><ul><li>不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改；</li><li>幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。<br>幻读其实可以看作是不可重复读的一种特殊情况，单独把区分幻读的原因主要是解决幻读和不可重复读的方案不一样。<br>举个例子：执行 <code>delete</code> 和 <code>update</code> 操作的时候，可以直接对记录加锁，保证事务安全。而执行 <code>insert</code> 操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行 <code>insert</code> 操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读。</li></ul><h2 id="事物隔离级别"><a href="#事物隔离级别" class="headerlink" title="事物隔离级别"></a>事物隔离级别</h2><p>事务隔离级别目的: 事务隔离级别是指多个并发事务之间的隔离程度。不同的隔离级别提供了不同的数据一致性和并发性保证。事务隔离级别主要解决以下问题：</p><ul><li>脏读（Dirty Read）：一个事务读取到了另一个未提交事务的数据。隔离级别通过保证事务的读取操作只能读取到已经提交的数据来解决脏读问题。</li><li>不可重复读（Non-repeatable Read）：一个事务在多次读取同一数据时，得到了不同的结果。隔离级别通过锁定读取的数据，防止其他事务对其进行修改来解决不可重复读问题。</li><li>幻读（Phantom Read）：一个事务在多次查询同一范围的数据时，得到了不同数量的记录。隔离级别通过锁定查询的范围，防止其他事务对该范围内的数据进行插入或删除来解决幻读问题。</li><li>丢失更新（Lost Update）：多个并发事务同时修改同一数据时，最后的修改可能会被覆盖，从而导致部分更新丢失。隔离级别通过锁定数据的写操作，保证事务之间的互斥性，避免丢失更新问题。</li></ul><p>SQL 标准定义了四个隔离级别：</p><ul><li><strong>READ-UNCOMMITTED(读取未提交)</strong> ： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li><strong>READ-COMMITTED(读取已提交)</strong> ： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li><strong>REPEATABLE-READ(可重复读)</strong> ： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><strong>SERIALIZABLE(可串行化)</strong> ： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li></ul><hr><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">READ-UNCOMMITTED</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">READ-COMMITTED</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">REPEATABLE-READ</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">SERIALIZABLE</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看，MySQL 8.0 该命令改为<code>SELECT @@transaction_isolation;</code></p><h1 id="B树和B-树共同点和区别"><a href="#B树和B-树共同点和区别" class="headerlink" title="B树和B+树共同点和区别"></a>B树和B+树共同点和区别</h1><p><img src="/../img/mysql/indexDataStruct.png" alt="数据结构"></p><h2 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h2><ol><li>根节点的儿子数的范围是[2,M]。</li><li>每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 &#x3D; 关键字的数量 +1，k 的取值范围为[ceil(M&#x2F;2) (向下取整), M]。</li><li>叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为[ceil(M&#x2F;2)(向下取整), M]。</li><li>假设中间节点节点的关键字为：Key[1], Key[2], …, Key[k-1]，且关键字按照升序排序，即 Key[i]</li></ol><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol><li>B+ 树的中间节点并不直接存储数据</li><li>B+树 所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。</li><li>有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 &#x3D; 关键字数，而 B 树中，孩子数量 &#x3D; 关键字数 +1。</li></ol><h1 id="创建索引条件"><a href="#创建索引条件" class="headerlink" title="创建索引条件"></a>创建索引条件</h1><p><img src="/../img/mysql/index_principle.png" alt="索引使用条件"></p><h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><ol><li>字段的数值有唯一性的限制，比如用户名<br>  索引本身可以起到约束的作用，比如唯一索引、主键索引都是可以起到唯一性约束的，因此在我们的数据表中，如果某个字段是唯一性的，就可以直接创建唯一性索引，或者主键索引。</li><li>频繁作为 WHERE 查询条件的字段，尤其在数据表大的情况下<br>  在数据量大的情况下，某个字段在 SQL 查询的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。创建普通索引就可以大幅提升数据查询的效率</li><li>需要经常 GROUP BY 和 ORDER BY 的列<br>  实际上多个单列索引在多条件查询时只会生效一个索引（MySQL 会选择其中一个限制最严格的作为索引），所以在多条件联合查询的时候最好创建联合索引</li><li>UPDATE、DELETE 的 WHERE 条件列，一般也需要创建索引<br>  原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护</li><li>DISTINCT 字段需要创建索引</li></ol><h2 id="无需创建索引"><a href="#无需创建索引" class="headerlink" title="无需创建索引"></a>无需创建索引</h2><ol><li>WHERE 条件（包括 GROUP BY、ORDER BY）里用不到的字段不需要创建索引</li><li>如果表记录太少</li><li>字段中如果有大量重复数据，也不用创建索引，比如性别字段</li><li>频繁更新的字段不一定要创建索引</li></ol><h2 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h2><ol><li>如果索引进行了表达式计算，则会失效</li><li>如果对索引使用函数，也会造成失效</li><li>在 WHERE 子句中，如果在 OR 前的条件列进行了索引，而在 OR 后的条件列没有进行索引，那么索引会失效。<br>  EXPLAIN SELECT comment_id, user_id, comment_text FROM product_comment WHERE comment_id &#x3D; 900001 OR comment_text &#x3D; ‘462eed7ac6e791292a79’</li><li>当我们使用 LIKE 进行模糊查询的时候，前面不能是 %<br>like “xxx%” 不一定会走索引, 索引优化器会根据走索引和全表扫描去进行匹配, 索引的选择本质上就是离散性的不同表述</li><li>索引列尽量设置为 NOT NULL 约束。可以将字符串的空值设置为’’,int 类型的值设置为0</li><li>我们在使用联合索引的时候要注意最左原则<br>  mysql 会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like) 就停止匹配<br>  最左原则也就是需要从左到右的使用索引中的字段，一条 SQL 语句可以只使用联合索引的一部分，但是需要从最左侧开始，否则就会失效。我在讲联合索引的时候举过索引失效的例子。</li></ol><h2 id="使用B-树原因"><a href="#使用B-树原因" class="headerlink" title="使用B+树原因"></a>使用B+树原因</h2><ol><li>高效的查找性能：B+树是一种高效的平衡树结构，具有非常高效的查找性能。它的平均查找时间复杂度为O(logN)，能够快速地定位到目标数据的位置。</li><li>高效的范围查询：B+树是一种有序树结构，能够非常高效地支持范围查询操作。它可以快速地找到满足条件的起始位置和结束位置，从而快速地定位到需要查询的数据。</li><li>内存友好：B+树的内部节点只存储索引信息，而不存储具体的数据，因此它的内存占用比较小。此外，B+树的叶子节点是顺序存储的，能够利用操作系统的预读特性，从而更加高效地利用内存。</li><li>支持高效的插入和删除：B+树的平衡特性使得它支持高效的插入和删除操作。对于插入操作，B+树只需要在叶子节点上插入新的数据即可。对于删除操作，B+树只需要删除叶子节点上的数据即可。</li></ol><h2 id="什么是数据库回表，如何去减少回表"><a href="#什么是数据库回表，如何去减少回表" class="headerlink" title="什么是数据库回表，如何去减少回表"></a>什么是数据库回表，如何去减少回表</h2><p>数据库回表是指在查询操作中，如果需要返回的列不在索引列中，就需要到主键索引或数据页中读取对应的数据行，这个过程就称为回表。回表操作会增加I&#x2F;O的开销和数据库的负载，对数据库性能产生负面影响。<br>为了减少回表操作，可以采取以下措施：</p><ol><li>使用覆盖索引：覆盖索引是指索引中包含了查询需要返回的所有列，不需要回表操作即可返回查询结果。使用覆盖索引可以避免回表操作，提高查询性能。</li><li>合理设计索引：合理的索引设计可以使得查询所需的列尽可能地包含在索引中，从而减少回表操作的次数。需要注意的是，索引也需要消耗存储空间和额外的维护成本，因此需要权衡索引数量、索引列数和索引覆盖范围等因素。</li><li>使用查询缓存：查询缓存是指在查询结果被写入磁盘前，将查询结果缓存到内存中，下一次查询同样的结果时可以直接从缓存中获取，避免回表操作。需要注意的是，查询缓存可能会占用大量的内存空间，且对于数据更新比较频繁的数据库效果不佳。</li><li>优化查询语句：尽可能地将查询条件放在索引列上，从而减少回表操作的次数。可以使用EXPLAIN语句来分析查询语句的执行计划，查看是否存在回表操作，从而优化查询语句。</li></ol><h2 id="索引下推，什么是索引下推"><a href="#索引下推，什么是索引下推" class="headerlink" title="索引下推，什么是索引下推"></a>索引下推，什么是索引下推</h2><p>索引下推（Index Condition Pushdown）是指在查询操作中，将查询条件下推到存储引擎层，让存储引擎在执行索引扫描的同时，过滤掉不符合条件的数据行，从而减少回表操作和减少扫描的数据量，提高查询性能。<br>在索引下推中，查询条件的过滤工作是在存储引擎层完成的。存储引擎根据查询条件和索引的结构，判断哪些索引键值能够满足查询条件，然后只读取这些索引键值对应的数据行，从而避免了回表操作和不必要的数据扫描。<br>例如，假设有一张名为employee的表，其中包含id、name、age和gender四个字段，其中id是主键，name上建有一个B+树索引。如果执行以下查询语句：<br>sql<br>Copy code<br>SELECT * FROM employee WHERE name &#x3D; ‘Tom’ AND age &gt; 25;<br>在没有索引下推的情况下，MySQL会先使用name索引扫描表中所有满足name&#x3D;’Tom’条件的数据行，然后再过滤掉不满足age &gt; 25的数据行，最后返回满足条件的数据行，这个过程中需要进行回表操作。<br>而在使用了索引下推的情况下，MySQL会将age &gt; 25的条件下推到存储引擎层，只读取满足name &#x3D; ‘Tom’和age &gt; 25两个条件的数据行，从而避免了回表操作和不必要的数据扫描。<br>需要注意的是，索引下推只对某些特定类型的查询有效，如WHERE条件中包含AND、OR、IN等逻辑操作符的查询语句。对于一些简单的查询语句，如WHERE条件只包含一个条件的查询语句，索引下推可能会降低查询性能。</p><h2 id="索引优化查询"><a href="#索引优化查询" class="headerlink" title="索引优化查询"></a>索引优化查询</h2><p>如果创建了联合索引(a,b,c) 在where 查询的时候 where c &#x3D; “1” and b &#x3D; “2” and a &#x3D; “3” 的时候相比较于完全没有索引, 有了一定的优化, 也是会用到了索引的功能, 其中优化器会尝试使用索引来进行读取数据, 优化器选择会选择分析sql 语句和数据库, 选择一个执行成本最低, 性能最优的方案</p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/interview/interview/"/>
    <url>/2023/03/06/interview/interview/</url>
    
    <content type="html"><![CDATA[<h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><p>我叫谢鹏程, 我研究生毕业于电子科技大学 计算机科学与技术专业，我一直从事于基础架构的相关工作, 目前在汇付天下中间价部门担任高级开发工程师的角色, 负责API 平台的开发与维护，主要致力于API平台的高可用、稳定性以及易用性的提升，我上一份工作是在携程框架架构研发部担任高级开发工程师，主要致力于公司的配置中心的高可用、稳定性以及易用性的提升</p><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><pre><code class="hljs">1. 配置中心的架构    配置中心总共由2个人进行维护, 我是里面的主要开发, 主要负责配置中心的性能、稳定性、以及易用性等提升. 在高可用上, 我们对对接用户的控台、客户端请求过来的服务端以及需要用户引入的客户端上都进行了相关的修改,     1. 降低了DB的变更压力, 大规模配置变更期间, 通过对数据库查询进行批量化操作, 降低了DB的压力    2. 保护系统的连接资源, 通过对tomcat 的 请求进行异步化处理, 防止由于极端情况下, 由于tomcat 线程在处理业务逻辑时, 业务请求处理时间高, 导致tomcat 无法接受请求处理    3. 为了进行自身核心逻辑的保护, 将一些边缘的逻辑进行弱依赖处理, 例如由于一些审计日志的行为, 将主流程进行bolck    4. 针对来源方的不同级别, 分配不同的资源去进行处理, 例如我们的来源方有DB 的主从切换, 业务的restAPI 等等, 针对不同的需求, 进行限流, 并且分配不同的线程去进行处理         1.1 配置中心由控制平面, 服务端, 客户端, 以及mysql数据库四部分组成, 用户可以通过restAPI 和 前端部分在控制平面上对数据进行变更, 客户端是需要用户主动去引入, 将配置文件拉取过去, 服务端的作用是负责接收控台变更的通知, 然后再将变更的配置文件通知给正在使用配置文件的客户端, 从而实现将配置文件热更新到用户的进程中去, 客户端和服务端之间会有长轮训请求在那里, 每个服务端的进程里面同时起了一个eureka, 用于服务端直接节点的相互注册. 数据库在里面起的作用是对配置文件的一个持久化. 具体的流程是 用户在控制平面对配置文件进行变更, 然后控制平面将配置文件的元信息(环境 + 应用名 + 文件名) 广播http 请求的通知给所有的服务端节点。服务端收到请求后, 会去找哪些客户端监听了对应的配置文件. 然后将最新的版本号下发给客户端, 客户端收到新的版本号后,再向服务端拉取配置文件内容    我在里面主要承担配置中心的稳定性以及易用性上的提升.    1. 配置文件的批量话操作和对读取数据的预热, 降低了配置文件中DB 被击穿, 导致DB 网络IO大, 从而降低了配置文件的一个延时    2. 优化了YONG GC: 我们使用的GC方式是G1, 尝试通过提升年轻代的比例和 增加MaxGCPauseMillis 去对yong gc 进行优化, 将yong gc 从2秒优化到了500ms, 再通过将 G1 替换成zgc, 将gc 时间降低到了10ms    3. 优化了FULL GC, 通过jmap dump 内存的文件, 再通过MAT 去分析内存的占用情况,     4. 优化了堆外内存的占用. 通过pmap 查看操作系统中内存的占用情况    5. 提升了稳定性2. API 网关上提升了性能    2.1 网关是由控制平面, 服务端, zk, mysql, redis 数据库四部分组成的,</code></pre><h1 id="java-基础"><a href="#java-基础" class="headerlink" title="java 基础"></a>java 基础</h1><h2 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>大体上, HashMap 是一个数组, 数组每一个元素是个单向链表, 数组是HashMap 的主体， 链表是为了解决hash碰撞存在的， 其中解决hash碰撞是通过拉链法去解决冲突, 在jdk1.8后在解决冲突的时候引入了红黑树，其中当链表中的长度大于8的时候，将链表转换成红黑树</p><h5 id="解决hash-冲突方法"><a href="#解决hash-冲突方法" class="headerlink" title="解决hash 冲突方法"></a>解决hash 冲突方法</h5><p>开放地址法<br>拉链法</p><h5 id="put"><a href="#put" class="headerlink" title="put"></a>put</h5><p><strong>对putVal方法添加元素的分析如下：</strong></p><ul><li>①如果定位到的数组位置没有元素 就直接插入。</li><li>②如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果key不相同，就判断p是否是一个树节点，如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)。</li></ul><p>ps:下图有一个小问题，来自 <a href="https://github.com/Snailclimb/JavaGuide/issues/608">issue#608</a>指出：直接覆盖之后应该就会 return，不会有后续操作。参考 JDK8 HashMap.java 658 行。</p><p><img src="/img/jdk/hashMap_put.png" alt="put方法"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">                   <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;<br>    <span class="hljs-comment">// table未初始化或者长度为0，进行扩容</span><br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        n = (tab = resize()).length;<br>    <span class="hljs-comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>        tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>    <span class="hljs-comment">// 桶中已经存在元素</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                <span class="hljs-comment">// 将第一个元素赋值给e，用e来记录</span><br>                e = p;<br>        <span class="hljs-comment">// hash值不相等，即key不相等；为红黑树结点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>            <span class="hljs-comment">// 放入树中</span><br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br>        <span class="hljs-comment">// 为链表结点</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 在链表最末插入结点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-comment">// 到达链表的尾部</span><br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// 在尾部插入新结点</span><br>                    p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">// 结点数量达到阈值，转化为红黑树</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-comment">// 跳出循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span><br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-comment">// 相等，跳出循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span><br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 记录e的value</span><br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>            <span class="hljs-comment">// onlyIfAbsent为false或者旧值为null</span><br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                <span class="hljs-comment">//用新值替换旧值</span><br>                e.value = value;<br>            <span class="hljs-comment">// 访问后回调</span><br>            afterNodeAccess(e);<br>            <span class="hljs-comment">// 返回旧值</span><br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 结构性修改</span><br>    ++modCount;<br>    <span class="hljs-comment">// 实际大小大于阈值则扩容</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    <span class="hljs-comment">// 插入后回调</span><br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="get"><a href="#get" class="headerlink" title="get"></a>get</h5><h4 id="非线程安全"><a href="#非线程安全" class="headerlink" title="非线程安全"></a>非线程安全</h4><p>原子性: 一个操作是否属于不可分割的<br>可见性:一个线程对变量的操作对于另外一个线程是可见的<br>线程A 去进行判断数组中是否存在元素的时候, 线程B 去对值进行修改, 以及两个线程在往链表中插入的时候<br>有序性:代码的执行顺序和语句顺序是一致的</p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p><a href="https://blog.csdn.net/qq_31709249/article/details/106952137">参照链接1</a><br><a href="https://developer.aliyun.com/article/984814">参照链接2</a><br>通过synchronzed, Node 变量value的volatile 以及CAS 去保证安全性<br>其中synchronize锁的粒度为桶中头结点（包括链表Node结点，包装红黑树的TreeBin结),transient volatile Node&lt;K,V&gt;[] table;<br>① 如果数组未没初始化，则先去初始化<br>② 如果对应的桶中的元素为空，那就新建一个链表节点，然后利用CAS操作将其放到桶中的位置。这个过程是在③前面的，我们知道，扩容过程中，每个桶位置迁移节点结束后，会将这个节点设置为ForwardingNode，所以这种情况下，你尽管放，放了以后，扩容的线程总会遍历到这个节点，然后将这个节点迁移到新数组中<br>③ 如果有线程在扩容，那就先去帮助扩容，扩容结束后，再重新put。<br>④ 最后，如果当前桶中已经有元素了，那就用synchronized锁住当前桶中的节点，然后在桶中插入元素，插入的时候，要么插入到链表中，要么插入到红黑树中。我们发现，这里的锁粒度是很小的，就锁住一个桶，不像JDK1.7中的ConcurrentHashMap，是分段锁，锁住很多的桶，所以并发效率更高。<br>⑤ 插入结束后，如果是插入到链表中，那去看看链表的长度有没有超过长度阈值8，如果超过了，就要将链表转换成红黑树。<br>⑥ 最后，让size加一（这里其实是用baseCount来记录长度的，而且处理的时候很复杂，继续看下面）。</p><h4 id="更新size中的addCount"><a href="#更新size中的addCount" class="headerlink" title="更新size中的addCount"></a>更新size中的addCount</h4><p>建立一个CounterCell类型的数组counterCells,每个线程生成一个随机数,用随机数去当线程的hash码, 用来对应到counterCells数组中的位置, 把要更新的值放在CounterCell的value上, 最后同步到baseCount, 获取到一个总的个数</p><h5 id="高并发下如何保证addCount的值的正确性"><a href="#高并发下如何保证addCount的值的正确性" class="headerlink" title="高并发下如何保证addCount的值的正确性"></a>高并发下如何保证addCount的值的正确性</h5><h4 id="扩容过程"><a href="#扩容过程" class="headerlink" title="扩容过程"></a>扩容过程</h4><p>实现了并发迁移的过程<br>每个线程承担不小于 16 个桶中的元素的扩容，然后从右向左划分 16 个桶给当前线程去迁移，每当开始迁移一个桶中的元素的时候，线程会锁住当前槽中列表的头元素，扩容完成后会将这个桶中的节点设置为ForwardingNode。假设这时候正好有 get请求过来会仍旧在旧的列表中访问，如果是插入、修改、删除、合并、compute 等操作时遇到 ForwardingNode，就表示正在扩容，那当前线程会一起扩容，扩容结束后再做元素的更新操作</p><h4 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h4><p>get 的时候普通链表是不需要去进行加锁, value 是通过volatile去进行修饰的, 保证可见性</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><h4 id="ArrayLists"><a href="#ArrayLists" class="headerlink" title="ArrayLists"></a>ArrayLists</h4><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><h2 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h2><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="jvm的内存模型"><a href="#jvm的内存模型" class="headerlink" title="jvm的内存模型"></a>jvm的内存模型</h3><p><a href="http://localhost:4000/2022/12/14/jvm/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98/">jvm 内存模型</a><br><strong>线程私有的：</strong></p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul><p><strong>线程共享的：</strong></p><ul><li>堆</li><li>方法区(metaspace)</li><li>直接内存 (非运行时数据区的一部分)</li></ul><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器是当前线程所执行的字节码的行号指示器。他通过通过改变计数器的值来选取下一条需要执行的字节码指令，其中分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。<br>其中每个线程都是有一个程序计数器的，<br>另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器, 因此这部分空间占用的每个线程私有的，也是唯一不会发生OOM的</p><h4 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h4><p>（除去native 方法）java 方法的调用都是通过虚拟机栈来实现的，每次方法的调用时数据的传递都是通过栈进行传递，每个方法开始调用对应入栈，接受后都是对应到出栈。其中每个帧栈上拥有的数据有局部便量表、操作数栈、动态连接等<br><strong>局部变量表</strong> 主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。<br><strong>操作数栈</strong> 主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。<br>栈空间虽然不是无限的，但一般正常调用的情况下是不会出现问题的。不过，如果函数调用陷入无限循环的话，就会导致栈中被压入太多栈帧而占用太多空间，导致栈空间过深。那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 <code>StackOverFlowError</code> 错误。<br>栈中国可能会出现两种错误：</p><ul><li><strong><code>StackOverFlowError</code>：</strong> 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 <code>StackOverFlowError</code> 错误。</li><li><strong><code>OutOfMemoryError</code>：</strong> 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常。</li></ul><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法被执行的时候，本地方法创建的帧栈，用于本地方法存的局部便量表、操作数栈、等信息<br>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 <code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code> 两种错误。</p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域。<strong>几乎所有的对象实例以及数组都在这里分配内存。</strong><br>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。<br>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p><ol><li>新生代内存(Young Generation) 又可以分为Eden区和Survivor 区</li><li>老生代(Old Generation)</li><li>metaspace 区<br>堆这里最容易出现的就是 <code>OutOfMemoryError</code> 错误，并且出现这种错误之后的表现形式还会有几种，比如：</li><li><strong><code>java.lang.OutOfMemoryError: GC Overhead Limit Exceeded</code></strong> ： 当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</li><li><strong><code>java.lang.OutOfMemoryError: Java heap space</code></strong> :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。</li></ol><h4 id="方法区（MetaSpace-永久代）"><a href="#方法区（MetaSpace-永久代）" class="headerlink" title="方法区（MetaSpace 永久代）"></a>方法区（MetaSpace 永久代）</h4><p>方法区是各个线程共享的区域，其中存放的数据有类的信息、方法信息、常量、静态变量等等。</p><blockquote><p>当元空间溢出时会得到如下错误： <code>java.lang.OutOfMemoryError: MetaSpace</code></p></blockquote><p>可以通过 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小</p><h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p>Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 <strong>常量池表(Constant Pool Table)</strong> 。<br>字面量是源代码中的固定值的表示法，即通过字面我们就能知道其值的含义。字面量包括整数、浮点数和字符串字面量，符号引用包括类符号引用、字段符号引用、方法符号引用和接口方法符号引用。<br>常量池表会在类加载后存放到方法区的运行时常量池中。<br>运行时常量池的功能类似于传统编程语言的符号表，尽管它包含了比典型符号表更广泛的数据。<br>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 错误。</p><h5 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h5><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在堆中创建字符串对象”ab“</span><br><span class="hljs-comment">// 将字符串对象”ab“的引用保存在字符串常量池中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">aa</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br><span class="hljs-comment">// 直接返回字符串常量池中字符串对象”ab“的引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>System.out.println(aa==bb);<span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>HotSpot 虚拟机中字符串常量池的实现是 <code>src/hotspot/share/classfile/stringTable.cpp</code> ,<code>StringTable</code> 本质上就是一个<code>HashSet&lt;String&gt;</code> ,容量为 <code>StringTableSize</code>（可以通过 <code>-XX:StringTableSize</code> 参数来设置）。<br><strong><code>StringTable</code> 中保存的是字符串对象的引用，字符串对象的引用指向堆中的字符串对象。</strong><br>JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。<br><strong>JDK 1.7 为什么要将字符串常量池移动到堆中？</strong><br>主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。</p><h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><h4 id="Step1-类加载检查"><a href="#Step1-类加载检查" class="headerlink" title="Step1:类加载检查"></a>Step1:类加载检查</h4><p>虚拟机遇到一条 new 指令时，先去检查指令在常量池中能否找到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程(双亲委派)。</p><h4 id="Step2-分配内存"><a href="#Step2-分配内存" class="headerlink" title="Step2:分配内存"></a>Step2:分配内存</h4><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。<strong>分配内存的方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种。<br><strong>内存分配的两种方式</strong> （补充内容，需要掌握）：</p><ul><li>指针碰撞 ：<ul><li>适用场合 ：堆内存规整（即没有内存碎片）的情况下。</li><li>原理 ：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li><li>使用该分配方式的 GC 收集器：Serial, ParNew</li></ul></li><li>空闲列表 ：<ul><li>适用场合 ： 堆内存不规整的情况下。</li><li>原理 ：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。</li><li>使用该分配方式的 GC 收集器：CMS<br>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的。<br><strong>内存分配并发问题（补充内容，需要掌握）</strong><br>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</li></ul></li><li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li><li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li></ul><h4 id="Step3-初始化零值"><a href="#Step3-初始化零值" class="headerlink" title="Step3:初始化零值"></a>Step3:初始化零值</h4><p>内存分配完成后，虚拟机需要将分配到的内存空间都进行初始化（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><h4 id="Step4-设置对象头"><a href="#Step4-设置对象头" class="headerlink" title="Step4:设置对象头"></a>Step4:设置对象头</h4><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><h4 id="Step5-执行-init-方法"><a href="#Step5-执行-init-方法" class="headerlink" title="Step5:执行 init 方法"></a>Step5:执行 init 方法</h4><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。<br><strong>Hotspot 虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。<br><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。<br><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：<strong>使用句柄</strong>、<strong>直接指针</strong>。</p><h4 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h4><p>如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。<br><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/jvm/access-location-of-object-handle.png" alt="对象的访问定位-使用句柄"></p><h4 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h4><p>如果使用直接指针访问，reference 中存储的直接就是对象的地址。<br><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/jvm/access-location-of-object-handle-direct-pointer.png" alt="对象的访问定位-直接指针"><br>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。<br>HotSpot 虚拟机主要使用的就是这种方式来进行对象访问。</p><h3 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h3><p>Java中的双亲委派模型是一种类加载机制，用于保证程序安全和稳定性。它是由启动类加载器（Bootstrap ClassLoader）、扩展类加载器（Extension ClassLoader）和应用程序类加载器（Application ClassLoader）组成的。<br>当一个类被加载时，Java虚拟机（JVM）首先会将该请求委派给父类加载器，如果父类加载器无法加载该类，那么会再委派给父类加载器的父类加载器，直到委派到最顶层的启动类加载器。<br>如果启动类加载器无法加载该类，那么会回到应用程序类加载器，它会尝试从自己的类路径中加载该类。如果应用程序类加载器还是无法加载该类，那么会回到扩展类加载器，它会尝试从扩展路径中加载该类。如果扩展类加载器也无法加载该类，那么最后会回到启动类加载器，它会尝试从JVM的核心类库中加载该类。<br>这种双亲委派模型保证了Java类的安全性和稳定性。因为父类加载器的加载机制是先加载自己的类路径下的类，只有在找不到该类时才会委派给自己的子类加载器。这样就避免了Java类被重复加载的问题，也避免了恶意代码的加载。<br>总结来说，Java双亲委派机制的加载顺序为：<br>当一个类加载器收到一个类加载请求时，它首先将该请求委派给其父类加载器。<br>如果父类加载器无法加载该类，它会将该请求委派给自己的父类加载器。<br>这个过程将一直持续到最顶层的启动类加载器。<br>如果启动类加载器也无法加载该类，那么它将回到应用程序类加载器，然后再回到扩展类加载器。<br>最后，如果所有的类加载器都无法加载该类，那么将会抛出ClassNotFoundException异常</p><h4 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h4><p>Java中的类加载过程分为3个步骤：加载、连接和初始化。下面我们来逐步了解它们的具体过程。<br>加载：类加载器首先会通过类的全限定名来查找并加载对应的类文件。在加载过程中，类文件中的静态变量、方法等信息都会被加载到JVM的方法区中，并且为类在方法区中创建一个Class对象。<br>连接：连接阶段又可以分为3个小阶段，分别是验证、准备和解析<br>2.1 验证：在这个阶段，类加载器会对类文件进行验证，以确保它们符合Java虚拟机规范，并且没有安全方面的问题。<br>2.2 准备：在准备阶段，类加载器会为类中的静态变量分配内存，并设置默认值（0或null），同时也会为静态变量关联上对应的符号引用（即指向该变量在常量池中的引用）。<br>2.3 解析：在解析阶段，类加载器会将类文件中的符号引用替换成直接引用，即将常量池中的符号引用指向具体的内存地址，这样类中的代码就可以直接使用这些变量或方法了。<br>初始化：在初始化阶段，类加载器会按照代码中的要求执行类的初始化，如执行静态代码块、初始化静态变量等。如果类的父类还没有被初始化，则会先初始化其父类。同时，在初始化阶段，JVM也会对类做一些必要的初始化检查，如检查是否存在抽象方法没有被实现等。<br>总结来说，Java类的加载过程分为三个阶段：加载、连接和初始化。在加载阶段，类文件会被加载到方法区中，并为类创建一个Class对象；在连接阶段，类文件会被验证、准备和解析；在初始化阶段，类的代码会按照要求被执行，同时也会进行一些必要的检查。</p><h2 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h2><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>索引</title>
    <link href="/2022/12/26/mysql/index/"/>
    <url>/2022/12/26/mysql/index/</url>
    
    <content type="html"><![CDATA[<blockquote><p>感谢<a href="https://github.com/WT-AHA">WT-AHA</a>对本文的完善，相关 PR：<a href="https://github.com/Snailclimb/JavaGuide/pull/1648">https://github.com/Snailclimb/JavaGuide/pull/1648</a> 。</p></blockquote><p>但凡经历过几场面试的小伙伴，应该都清楚，数据库索引这个知识点在面试中出现的频率高到离谱。</p><p>除了对于准备面试来说非常重要之外，善用索引对 SQL 的性能提升非常明显，是一个性价比较高的 SQL 优化手段。</p><h2 id="索引介绍"><a href="#索引介绍" class="headerlink" title="索引介绍"></a>索引介绍</h2><p><strong>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</strong></p><p>索引的作用就相当于书的目录。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p><p>索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了 B+树作为索引结构。</p><h2 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h2><p><strong>优点</strong> ：</p><ul><li>使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。</li><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li></ul><p><strong>缺点</strong> ：</p><ul><li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li><li>索引需要使用物理文件存储，也会耗费一定空间。</li></ul><p>但是，<strong>使用索引一定能提高查询性能吗?</strong></p><p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。</p><h2 id="索引的底层数据结构"><a href="#索引的底层数据结构" class="headerlink" title="索引的底层数据结构"></a>索引的底层数据结构</h2><h3 id="Hash-表"><a href="#Hash-表" class="headerlink" title="Hash 表"></a>Hash 表</h3><p>哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O（1））。</p><p><strong>为何能够通过 key 快速取出 value 呢？</strong> 原因在于 <strong>哈希算法</strong>（也叫散列算法）。通过哈希算法，我们可以快速找到 key 对应的 index，找到了 index 也就找到了对应的 value。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">hash = hashfunc(key)<br>index = hash % array_size<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210513092328171.png"></p><p>但是！哈希算法有个 <strong>Hash 冲突</strong> 问题，也就是说多个不同的 key 最后得到的 index 相同。通常情况下，我们常用的解决办法是 <strong>链地址法</strong>。链地址法就是将哈希冲突数据存放在链表中。就比如 JDK1.8 之前 <code>HashMap</code> 就是通过链地址法来解决哈希冲突的。不过，JDK1.8 以后<code>HashMap</code>为了减少链表过长的时候搜索时间过长引入了红黑树。</p><p><img src="https://img-blog.csdnimg.cn/20210513092224836.png"></p><p>为了减少 Hash 冲突的发生，一个好的哈希函数应该“均匀地”将数据分布在整个可能的哈希值集合中。</p><p>既然哈希表这么快，<strong>为什么 MySQL 没有使用其作为索引的数据结构呢？</strong> 主要是因为 Hash 索引不支持顺序和范围查询。假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。并且，每次 IO 只能取一个。</p><p>试想一种情况:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">SELECT * FROM tb1 WHERE id &lt; <span class="hljs-number">500</span>;<br></code></pre></td></tr></table></figure><p>在这种范围查询中，优势非常大，直接遍历比 500 小的叶子节点就够了。而 Hash 索引是根据 hash 算法来定位的，难不成还要把 1 - 499 的数据，每个都进行一次 hash 计算来定位吗?这就是 Hash 最大的缺点了。</p><h3 id="B-树-amp-B-树"><a href="#B-树-amp-B-树" class="headerlink" title="B 树&amp; B+树"></a>B 树&amp; B+树</h3><p>B 树也称 B-树,全称为 <strong>多路平衡查找树</strong> ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 <code>Balanced</code> （平衡）的意思。</p><p>目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。</p><p><strong>B 树&amp; B+树两者有何异同呢？</strong></p><ul><li>B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li><li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li><li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li></ul><p>在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。（下面的内容整理自《Java 工程师修炼之道》）</p><blockquote><p>MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“<strong>非聚簇索引（非聚集索引）</strong>”。</p><p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“<strong>聚簇索引（聚集索引）</strong>”，而其余的索引都作为 <strong>辅助索引</strong> ，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p></blockquote><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><h3 id="主键索引-Primary-Key"><a href="#主键索引-Primary-Key" class="headerlink" title="主键索引(Primary Key)"></a>主键索引(Primary Key)</h3><p>数据表的主键列使用的就是主键索引。</p><p>一张数据表有只能有一个主键，并且主键不能为 null，不能重复。</p><p>在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在 null 值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/open-source-project/cluster-index.png"></p><h3 id="二级索引-辅助索引"><a href="#二级索引-辅助索引" class="headerlink" title="二级索引(辅助索引)"></a>二级索引(辅助索引)</h3><p><strong>二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。</strong></p><p>唯一索引，普通索引，前缀索引等索引属于二级索引。</p><p>PS: 不懂的同学可以暂存疑，慢慢往下看，后面会有答案的，也可以自行搜索。</p><ol><li><strong>唯一索引(Unique Key)</strong> ：唯一索引也是一种约束。<strong>唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。</strong> 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li><li><strong>普通索引(Index)</strong> ：<strong>普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</strong></li><li><strong>前缀索引(Prefix)</strong> ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小，<br>因为只取前几个字符。</li><li><strong>全文索引(Full Text)</strong> ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</li></ol><p>二级索引:</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/open-source-project/no-cluster-index.png"></p><h2 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h2><h3 id="聚簇索引（聚集索引）"><a href="#聚簇索引（聚集索引）" class="headerlink" title="聚簇索引（聚集索引）"></a>聚簇索引（聚集索引）</h3><h4 id="聚簇索引介绍"><a href="#聚簇索引介绍" class="headerlink" title="聚簇索引介绍"></a>聚簇索引介绍</h4><p><strong>聚簇索引即索引结构和数据一起存放的索引，并不是一种单独的索引类型。InnoDB 中的主键索引就属于聚簇索引。</strong></p><p>在 MySQL 中，InnoDB 引擎的表的 <code>.ibd</code>文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p><h4 id="聚簇索引的优缺点"><a href="#聚簇索引的优缺点" class="headerlink" title="聚簇索引的优缺点"></a>聚簇索引的优缺点</h4><p><strong>优点</strong> ：</p><ul><li><strong>查询速度非常快</strong> ：聚簇索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引， 聚簇索引少了一次读取数据的 IO 操作。</li><li><strong>对排序查找和范围查找优化</strong> ：聚簇索引对于主键的排序查找和范围查找速度非常快。</li></ul><p><strong>缺点</strong> ：</p><ul><li><strong>依赖于有序的数据</strong> ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li><li><strong>更新代价大</strong> ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。</li></ul><h3 id="非聚簇索引（非聚集索引）"><a href="#非聚簇索引（非聚集索引）" class="headerlink" title="非聚簇索引（非聚集索引）"></a>非聚簇索引（非聚集索引）</h3><h4 id="非聚簇索引介绍"><a href="#非聚簇索引介绍" class="headerlink" title="非聚簇索引介绍"></a>非聚簇索引介绍</h4><p><strong>非聚簇索引即索引结构和数据分开存放的索引，并不是一种单独的索引类型。二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引</strong></p><p>非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</p><h4 id="非聚簇索引的优缺点"><a href="#非聚簇索引的优缺点" class="headerlink" title="非聚簇索引的优缺点"></a>非聚簇索引的优缺点</h4><p><strong>优点</strong> ：</p><p>更新代价比聚簇索引要小 。非聚簇索引的更新代价就没有聚簇索引那么大了，非聚簇索引的叶子节点是不存放数据的</p><p><strong>缺点</strong> ：</p><ul><li><strong>依赖于有序的数据</strong> ：跟聚簇索引一样，非聚簇索引也依赖于有序的数据</li><li><strong>可能会二次查询(回表)</strong> ：这应该是非聚簇索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li></ul><p>这是 MySQL 的表的文件截图:</p><p><img src="https://img-blog.csdnimg.cn/20210420165311654.png"></p><p>聚簇索引和非聚簇索引:</p><p><img src="https://img-blog.csdnimg.cn/20210420165326946.png"></p><h4 id="非聚簇索引一定回表查询吗-覆盖索引"><a href="#非聚簇索引一定回表查询吗-覆盖索引" class="headerlink" title="非聚簇索引一定回表查询吗(覆盖索引)?"></a>非聚簇索引一定回表查询吗(覆盖索引)?</h4><p><strong>非聚簇索引不一定回表查询。</strong></p><p>试想一种情况，用户准备使用 SQL 查询用户名，而用户名字段正好建立了索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;guang19&#x27;</span>;<br></code></pre></td></tr></table></figure><p>那么这个索引的 key 本身就是 name，查到对应的 name 直接返回就行了，无需回表查询。</p><p>即使是 MYISAM 也是这样，虽然 MYISAM 的主键索引确实需要回表，因为它的主键索引的叶子节点存放的是指针。但是！<strong>如果 SQL 查的就是主键呢?</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>主键索引本身的 key 就是主键，查到返回就行了。这种情况就称之为覆盖索引了。</p><h2 id="覆盖索引和联合索引"><a href="#覆盖索引和联合索引" class="headerlink" title="覆盖索引和联合索引"></a>覆盖索引和联合索引</h2><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p><p><strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。</strong></p><blockquote><p>如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。</p><p>再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引，<br>那么直接根据这个索引就可以查到数据，也无需回表。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210420165341868.png" alt="覆盖索引"></p><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>使用表中的多个字段创建索引，就是 <strong>联合索引</strong>，也叫 <strong>组合索引</strong> 或 <strong>复合索引</strong>。</p><h3 id="最左前缀匹配原则"><a href="#最左前缀匹配原则" class="headerlink" title="最左前缀匹配原则"></a>最左前缀匹配原则</h3><p>最左前缀匹配原则指的是，在使用联合索引时，<strong>MySQL</strong> 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询，如 <strong><code>&gt;</code><strong>、</strong><code>&lt;</code><strong>、</strong><code>between</code></strong> 和 <strong><code>以%开头的like查询</code></strong> 等条件，才会停止匹配。</p><p>所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。</p><h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><p><strong>索引下推（Index Condition Pushdown）</strong> 是 <strong>MySQL 5.6</strong> 版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。</p><h2 id="正确使用索引的一些建议"><a href="#正确使用索引的一些建议" class="headerlink" title="正确使用索引的一些建议"></a>正确使用索引的一些建议</h2><h3 id="选择合适的字段创建索引"><a href="#选择合适的字段创建索引" class="headerlink" title="选择合适的字段创建索引"></a>选择合适的字段创建索引</h3><ul><li><strong>不为 NULL 的字段</strong> ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。</li><li><strong>被频繁查询的字段</strong> ：我们创建索引的字段应该是查询操作非常频繁的字段。</li><li><strong>被作为条件查询的字段</strong> ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</li><li><strong>频繁需要排序的字段</strong> ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</li><li><strong>被经常频繁用于连接的字段</strong> ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</li></ul><h3 id="被频繁更新的字段应该慎重建立索引"><a href="#被频繁更新的字段应该慎重建立索引" class="headerlink" title="被频繁更新的字段应该慎重建立索引"></a>被频繁更新的字段应该慎重建立索引</h3><p>虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p><h3 id="尽可能的考虑建立联合索引而不是单列索引"><a href="#尽可能的考虑建立联合索引而不是单列索引" class="headerlink" title="尽可能的考虑建立联合索引而不是单列索引"></a>尽可能的考虑建立联合索引而不是单列索引</h3><p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p><h3 id="注意避免冗余索引"><a href="#注意避免冗余索引" class="headerlink" title="注意避免冗余索引"></a>注意避免冗余索引</h3><p>冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p><h3 id="考虑在字符串类型的字段上使用前缀索引代替普通索引"><a href="#考虑在字符串类型的字段上使用前缀索引代替普通索引" class="headerlink" title="考虑在字符串类型的字段上使用前缀索引代替普通索引"></a>考虑在字符串类型的字段上使用前缀索引代替普通索引</h3><p>前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。</p><h3 id="避免索引失效"><a href="#避免索引失效" class="headerlink" title="避免索引失效"></a>避免索引失效</h3><p>索引失效也是慢查询的主要原因之一，常见的导致索引失效的情况有下面这些：</p><ul><li>使用 <code>SELECT *</code> 进行查询;</li><li>创建了组合索引，但查询条件未准守最左匹配原则;</li><li>在索引列上进行计算、函数、类型转换等操作;</li><li>以 % 开头的 LIKE 查询比如 <code>like &#39;%abc&#39;;</code>;</li><li>查询条件中使用 or，且 or 的前后条件中有一个列没有索引，涉及的索引都不会被使用到;</li><li>发生<a href="https://javaguide.cn/database/mysql/index-invalidation-caused-by-implicit-conversion.html">隐式转换</a>;</li><li>……</li></ul><h3 id="删除长期未使用的索引"><a href="#删除长期未使用的索引" class="headerlink" title="删除长期未使用的索引"></a>删除长期未使用的索引</h3><p>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 schema_unused_indexes 视图来查询哪些索引从未被使用</p><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p>多表连接的进行创建索引:</p><ol><li>对where条件的列创建索引</li><li>对用于连接的字段创建索引, 并且该字段在多表中类型需要保持一致</li><li>区分度高的列作为索引</li></ol><h3 id="索引各个场景"><a href="#索引各个场景" class="headerlink" title="索引各个场景"></a>索引各个场景</h3><p>有5个字段 a,b,c,d,e,f,g,h<br>(a,b,c) 是一个联合索引, (d,e)是一个联合索引</p><ol><li>创建联合索引(a,b,c)<br>符合最左匹配原则 走索引<br>explain select * from not_dice.testPerson where a &#x3D; “1”;<br>索引<br>explain select * from not_dice.testPerson where b &#x3D; “1”;<br>全表<br>explain select * from not_dice.testPerson where c &#x3D; “1”;<br>全表<br>explain select * from not_dice.testPerson where a &#x3D; “1” and b &#x3D; “1”;<br>索引<br>explain select * from not_dice.testPerson where b &#x3D; “1” and a &#x3D; “1”;<br>索引<br>explain select * from not_dice.testPerson where a &#x3D; “1” and c &#x3D; “1”;<br>索引下推<br>explain select * from not_dice.testPerson where c &#x3D; “1” and a &#x3D; “1”;<br>索引<br>explain SELECT * FROM not_dice.testPerson where  c  &#x3D; “1” and b &#x3D; “1”;<br>进行全表扫描了<br>explain select * from not_dice.testPerson where a &#x3D; “1” and b &#x3D; “1” and c &#x3D; “1”;<br>索引<br>explain select * from not_dice.testPerson where b &#x3D; “1” and a &#x3D; “1” and c &#x3D; “1”;<br>索引<br>explain select * from not_dice.testPerson where c &#x3D; “1” and b &#x3D; “1” and a &#x3D; “1”;<br>索引<br>explain select * from not_dice.testPerson where a &#x3D; “1” and c &#x3D; “1” and b &#x3D; “1”;<br>索引</li></ol><p>explain select * from not_dice.testPerson where a &#x3D; “1” and c &#x3D; “1” and b &#x3D; “1” and d &#x3D; “1”;<br>索引</p><p>explain select * from not_dice.testPerson where c &#x3D; “1” and b &#x3D; “1” and d &#x3D; “1”;<br>走d_f的索引<br>explain select * from not_dice.testPerson where c &#x3D; “1” and b &#x3D; “1” and f &#x3D; “1”;<br>全表</p><p><a href="https://cloud.tencent.com/developer/article/2334796">https://cloud.tencent.com/developer/article/2334796</a></p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GC算法</title>
    <link href="/2022/12/14/jvm/GC%20%E7%AE%97%E6%B3%95/"/>
    <url>/2022/12/14/jvm/GC%20%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>如果没有特殊说明，都是针对的是 HotSpot 虚拟机。</p><p>本文基于《深入理解 Java 虚拟机：JVM 高级特性与最佳实践》进行总结补充。</p><p>常见面试题 ：</p><ul><li>如何判断对象是否死亡（两种方法）。</li><li>简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。</li><li>如何判断一个常量是废弃常量</li><li>如何判断一个类是无用的类</li><li>垃圾收集有哪些算法，各自的特点？</li><li>HotSpot 为什么要分为新生代和老年代？</li><li>常见的垃圾回收器有哪些？</li><li>介绍一下 CMS,G1 收集器。</li><li>Minor Gc 和 Full GC 有什么不同呢？</li></ul></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当需要排查各种内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。</p><h2 id="堆空间的基本结构"><a href="#堆空间的基本结构" class="headerlink" title="堆空间的基本结构"></a>堆空间的基本结构</h2><p>Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 <strong>堆</strong> 内存中对象的分配与回收。</p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。</p><p>从垃圾回收的角度来说，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆被划分为了几个不同的区域，这样我们就可以根据各个区域的特点选择合适的垃圾收集算法。</p><p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p><ol><li>新生代内存(Young Generation)</li><li>老生代(Old Generation)</li><li>永久代(Permanent Generation)</li></ol><p>下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。</p><p><img src="/./img/jdk/jvm/hotspot-heap-structure.png" alt="hotspot-heap-structure"></p><p><strong>JDK 8 版本之后 PermGen(永久) 已被 Metaspace(元空间) 取代，元空间使用的是直接内存</strong> 。</p><p>关于堆空间结构更详细的介绍，可以回过头看看 <a href="./memory-area.md">Java 内存区域详解</a> 这篇文章。</p><h2 id="内存分配和回收原则"><a href="#内存分配和回收原则" class="headerlink" title="内存分配和回收原则"></a>内存分配和回收原则</h2><h3 id="对象优先在-Eden-区分配"><a href="#对象优先在-Eden-区分配" class="headerlink" title="对象优先在 Eden 区分配"></a>对象优先在 Eden 区分配</h3><p>大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。下面我们来进行实际测试以下。</p><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GCTest</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">byte</span>[] allocation1, allocation2;<br>allocation1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">30900</span>*<span class="hljs-number">1024</span>];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过以下方式运行：<br><img src="/./img/jdk/jvm/25178350.png"></p><p>添加的参数：<code>-XX:+PrintGCDetails</code><br><img src="/./img/jdk/jvm/run-with-PrintGCDetails.png"></p><p>运行结果 (红色字体描述有误，应该是对应于 JDK1.7 的永久代)：</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-26/28954286.jpg"></p><p>从上图我们可以看出 Eden 区内存几乎已经被分配完全（即使程序什么也不做，新生代也会使用 2000 多 k 内存）。</p><p>假如我们再为 <code>allocation2</code> 分配内存会出现什么情况呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">allocation2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">900</span>*<span class="hljs-number">1024</span>];<br></code></pre></td></tr></table></figure><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-26/28128785.jpg"></p><p>给 <code>allocation2</code> 分配内存的时候 Eden 区内存几乎已经被分配完了</p><p>当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。GC 期间虚拟机又发现 <code>allocation1</code> 无法存入 Survivor 空间，所以只好通过 <strong>分配担保机制</strong> 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放 <code>allocation1</code>，所以不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 Eden 区的话，还是会在 Eden 区分配内存。可以执行如下代码验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GCTest</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">byte</span>[] allocation1, allocation2,allocation3,allocation4,allocation5;<br>allocation1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">32000</span>*<span class="hljs-number">1024</span>];<br>allocation2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1000</span>*<span class="hljs-number">1024</span>];<br>allocation3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1000</span>*<span class="hljs-number">1024</span>];<br>allocation4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1000</span>*<span class="hljs-number">1024</span>];<br>allocation5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1000</span>*<span class="hljs-number">1024</span>];<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。</p><p>大对象直接进入老年代主要是为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p><h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</p><p>大部分情况，对象都会首先在 Eden 区域分配。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)。</p><p>对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><blockquote><p>修正（<a href="https://github.com/Snailclimb/JavaGuide/issues/552">issue552</a>）：“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的 50% 时（默认值是 50%，可以通过 <code>-XX:TargetSurvivorRatio=percent</code> 来设置，参见 <a href="https://github.com/Snailclimb/JavaGuide/issues/1199">issue1199</a> ），取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。</p><p>jdk8 官方文档引用 ：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a> 。</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/image-20210523201742303.png"></p><p><strong>动态年龄计算的代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">uint <span class="hljs-title">ageTable::compute_tenuring_threshold</span><span class="hljs-params">(<span class="hljs-type">size_t</span> survivor_capacity)</span> </span>&#123;<br><span class="hljs-comment">//survivor_capacity是survivor空间的大小</span><br><span class="hljs-type">size_t</span> desired_survivor_size = (<span class="hljs-type">size_t</span>)((((<span class="hljs-type">double</span>)survivor_capacity)*TargetSurvivorRatio)/<span class="hljs-number">100</span>);<br><span class="hljs-type">size_t</span> total = <span class="hljs-number">0</span>;<br>uint age = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (age &lt; table_size) &#123;<br><span class="hljs-comment">//sizes数组是每个年龄段对象大小</span><br>total += sizes[age];<br><span class="hljs-keyword">if</span> (total &gt; desired_survivor_size) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>age++;<br>&#125;<br>uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;<br>...<br>&#125;<br><br></code></pre></td></tr></table></figure><p>额外补充说明(<a href="https://github.com/Snailclimb/JavaGuide/issues/672">issue672</a>)：<strong>关于默认的晋升年龄是 15，这个说法的来源大部分都是《深入理解 Java 虚拟机》这本书。</strong><br>如果你去 Oracle 的官网阅读<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">相关的虚拟机参数</a>，你会发现<code>-XX:MaxTenuringThreshold=threshold</code>这里有个说明</p><p><strong>Sets the maximum tenuring threshold for use in adaptive GC sizing. The largest value is 15. The default value is 15 for the parallel (throughput) collector, and 6 for the CMS collector.默认晋升年龄并不都是 15，这个是要区分垃圾收集器的，CMS 就是 6.</strong></p></blockquote><h3 id="主要进行-gc-的区域"><a href="#主要进行-gc-的区域" class="headerlink" title="主要进行 gc 的区域"></a>主要进行 gc 的区域</h3><p>周志明先生在《深入理解 Java 虚拟机》第二版中 P92 如是写道：</p><blockquote><p><del><em>“老年代 GC（Major GC&#x2F;Full GC），指发生在老年代的 GC……”</em></del></p></blockquote><p>上面的说法已经在《深入理解 Java 虚拟机》第三版中被改正过来了。感谢 R 大的回答：</p><p><img src="/./img/jdk/jvm/rf-hotspot-vm-gc.png"></p><p><strong>总结：</strong></p><p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p><p>部分收集 (Partial GC)：</p><ul><li>新生代收集（Minor GC &#x2F; Young GC）：只对新生代进行垃圾收集；</li><li>老年代收集（Major GC &#x2F; Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li><li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li></ul><p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p><h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。</p><p>《深入理解 Java 虚拟机》第三章对于空间分配担保的描述如下：</p><blockquote><p>JDK 6 Update 24 之前，在发生 Minor GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。如果不成立，则虚拟机会先查看 <code>-XX:HandlePromotionFailure</code> 参数的设置值是否允许担保失败(Handle Promotion Failure);如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的;如果小于，或者 <code>-XX: HandlePromotionFailure</code> 设置不允许冒险，那这时就要改为进行一次 Full GC。</p><p>JDK 6 Update 24 之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。</p></blockquote><h2 id="死亡对象判断方法"><a href="#死亡对象判断方法" class="headerlink" title="死亡对象判断方法"></a>死亡对象判断方法</h2><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）。</p><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>给对象中添加一个引用计数器：</p><ul><li>每当有一个地方引用它，计数器就加 1；</li><li>当引用失效，计数器就减 1；</li><li>任何时候计数器为 0 的对象就是不可能再被使用的。</li></ul><p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</strong></p><p>所谓对象之间的相互引用问题，如下面代码所示：除了对象 <code>objA</code> 和 <code>objB</code> 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReferenceCountingGc</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ReferenceCountingGc</span> <span class="hljs-variable">objA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceCountingGc</span>();<br>        <span class="hljs-type">ReferenceCountingGc</span> <span class="hljs-variable">objB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceCountingGc</span>();<br>        objA.instance = objB;<br>        objB.instance = objA;<br>        objA = <span class="hljs-literal">null</span>;<br>        objB = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p><p>下图中的 <code>Object 6 ~ Object 10</code> 之间虽有引用关系，但它们到 GC Roots 不可达，因此为需要被回收的对象。</p><p><img src="/./img/jdk/jvm/jvm-gc-roots.png" alt="可达性分析算法"></p><p><strong>哪些对象可以作为 GC Roots 呢？</strong></p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>本地方法栈(Native 方法)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li></ul><p><strong>对象可以被回收，就代表一定会被回收吗？</strong></p><p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 <code>finalize</code> 方法。当对象没有覆盖 <code>finalize</code> 方法，或 <code>finalize</code> 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p><p>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p><blockquote><p><code>Object</code> 类中的 <code>finalize</code> 方法一直被认为是一个糟糕的设计，成为了 Java 语言的负担，影响了 Java 语言的安全和 GC 的性能。JDK9 版本及后续版本中各个类中的 <code>finalize</code> 方法会被逐渐弃用移除。忘掉它的存在吧！</p><p>参考：</p><ul><li><a href="https://openjdk.java.net/jeps/421">JEP 421: Deprecate Finalization for Removal</a></li><li><a href="https://mp.weixin.qq.com/s/LW-paZAMD08DP_3-XCUxmg">是时候忘掉 finalize 方法了</a></li></ul></blockquote><h3 id="引用类型总结"><a href="#引用类型总结" class="headerlink" title="引用类型总结"></a>引用类型总结</h3><p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。</p><p>JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。</p><p>JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p><p><strong>1．强引用（StrongReference）</strong></p><p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p><p><strong>2．软引用（SoftReference）</strong></p><p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><p><strong>3．弱引用（WeakReference）</strong></p><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><p><strong>4．虚引用（PhantomReference）</strong></p><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p><p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p><h3 id="如何判断一个常量是废弃常量？"><a href="#如何判断一个常量是废弃常量？" class="headerlink" title="如何判断一个常量是废弃常量？"></a>如何判断一个常量是废弃常量？</h3><p>运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？</p><p><del><strong>JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</strong></del></p><blockquote><p><strong>🐛 修正（参见：<a href="https://github.com/Snailclimb/JavaGuide/issues/747">issue747</a>，<a href="https://blog.csdn.net/q5706503/article/details/84640762">reference</a>）</strong> ：</p><ol><li><strong>JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代</strong></li><li><strong>JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代</strong> 。</li><li><strong>JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</strong></li></ol></blockquote><p>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了。</p><h3 id="如何判断一个类是无用的类"><a href="#如何判断一个类是无用的类" class="headerlink" title="如何判断一个类是无用的类"></a>如何判断一个类是无用的类</h3><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p><ol><li><strong>效率问题</strong></li><li><strong>空间问题（标记清除后会产生大量不连续的碎片）</strong></li></ol><p><img src="/./img/jdk/jvm/mark-and-sweep-garbage-collection-algorithm.png"></p><h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><p>为了解决效率问题，“标记-复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p><p><img src="/./img/jdk/jvm/copying-garbage-collection-algorithm.png" alt="复制算法"></p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p><p><img src="/./img/jdk/jvm/mark-and-compact-garbage-collection-algorithm.png" alt="标记-整理算法 "></p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p><strong>比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</strong></p><p><strong>延伸面试问题：</strong> HotSpot 为什么要分为新生代和老年代？</p><p>根据上面的对分代收集算法的介绍回答。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></p><p>虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，<strong>我们能做的就是根据具体应用场景选择适合自己的垃圾收集器</strong>。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的 HotSpot 虚拟机就不会实现那么多不同的垃圾收集器了。</p><h3 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h3><p>Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="/./img/jdk/jvm/serial-garbage-collector.png" alt=" Serial 收集器 "></p><p>虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p><p>但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它<strong>简单而高效（与其他收集器的单线程相比）</strong>。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。</p><h3 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h3><p><strong>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</strong></p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="/./img/jdk/jvm/parnew-garbage-collector.png" alt="ParNew 收集器 "></p><p>它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p><p><strong>并行和并发概念补充：</strong></p><ul><li><p><strong>并行（Parallel）</strong> ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</p></li><li><p><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。</p></li></ul><h3 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h3><p>Parallel Scavenge 收集器也是使用标记-复制算法的多线程收集器，它看上去几乎和 ParNew 都一样。 <strong>那么它有什么特别之处呢？</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ruby">-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+UseParallelGC</span><br><br>    使用 Parallel 收集器+ 老年代串行<br><br>-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+UseParallelOldGC</span><br><br>    使用 Parallel 收集器+ 老年代并行<br><br></code></pre></td></tr></table></figure><p><strong>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</strong> Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="/./img/jdk/jvm/parallel-scavenge-garbage-collector.png" alt="Parallel Scavenge 收集器 "></p><p><strong>这是 JDK1.8 默认收集器</strong></p><p>使用 <code>java -XX:+PrintCommandLineFlags -version</code> 命令查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">-XX:InitialHeapSize=262921408 -XX:MaxHeapSize=4206742528 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC<br>java version <span class="hljs-string">&quot;1.8.0_211&quot;</span><br>Java(TM) SE Runtime Environment (build 1.8.0_211-b12)<br>Java HotSpot(TM) 64-Bit Server VM (build 25.211-b12, mixed mode)<br></code></pre></td></tr></table></figure><p>JDK1.8 默认使用的是 Parallel Scavenge + Parallel Old，如果指定了-XX:+UseParallelGC 参数，则默认指定了-XX:+UseParallelOldGC，可以使用-XX:-UseParallelOldGC 来禁用该功能</p><h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h3><p><strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p><h3 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h3><p><strong>Parallel Scavenge 收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p><h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong></p><p><strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p><p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p><ul><li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li><li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li><li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短, 重新标记的目的是补充标记遗漏的准确性, 主要标记在并发标记后, 重新标记前, 变为可达的对象, 其中在并发标记中产生的不可达对象是在下一个回收周期中被处理</li><li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li></ul><p>浮动垃圾的影响:<br>    导致内存利用率降低<br>    浮动垃圾变多, 老年代碎片化严重, 从而导致更多的Minor GC, 最终导致full GC<br>    原因是因为GC 回收算法是标记清除的, 产生碎片化严重, 影响大对象的分配</p><p><img src="/./img/jdk/jvm/cms-garbage-collector.png" alt="CMS 垃圾收集器 "></p><p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p><ul><li><strong>对 CPU 资源敏感；</strong><br>  并发标记和并发清除的时候需要额外的CPU资源</li><li><strong>无法处理浮动垃圾；</strong><br>  在并发标记的过程中, GC线程和用户线程同时工作, 应用线程可能会在标记以后, 继续分配出来的对象为不可达对象, 但是新产生的不可达对象不会在当前的GC周期中被回收</li><li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong><br>  可能导致老年代碎片化</li></ul><h3 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h3><p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</strong></p><p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：</p><ul><li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li><li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li><li><strong>空间整合</strong>：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li><li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li></ul><p>G1 收集器的运作大致分为以下几个步骤：</p><ul><li><strong>初始标记</strong><br>标记从GC Roots 出发的可达对象 需要进行STW</li><li><strong>并发标记</strong><br>标记整个堆中的存活对象, 不会进行STW</li><li><strong>最终标记</strong><br>完成并发标记, 并且处理在并发标记期间导致应用对象的变化, 需要进行STW</li><li><strong>筛选回收</strong><br>确定进行回收, 并根据收集的数据区域进行回收</li><li><strong>拷贝回收</strong><br>将存活的对象从回收区拷贝到新的区块, 方便进行回收</li></ul><p>特点:<br>    region 管理, 每个区域可能是Eden 区, 也可能是Survivor区, 也可能是old区<br>    并发标记和整理, 支持并发标记, 降低了STW<br>    可预测的停顿时间<br>    优先回收: 维护一个优先队列, 根据各个区域回收的价值(回收成本和收益) 决定哪些要优先回收<br>G1 怎么解决浮动垃圾:<br>    将对分割成多个region, 更加灵活的去管理和回收内存, 降低浮动垃圾的影响<br>    垃圾回收的时候, 可以进行并发标记和整理, 最大限度的降低程序的停顿</p><p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p><h3 id="ZGC-收集器"><a href="#ZGC-收集器" class="headerlink" title="ZGC 收集器"></a>ZGC 收集器</h3><p>与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进。</p><p>在 ZGC 中出现 Stop The World 的情况会更少！</p><p>详情可以看 ： <a href="https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html">《新一代垃圾回收器 ZGC 的探索与实践》</a></p><h3 id="G1-和-ZGC"><a href="#G1-和-ZGC" class="headerlink" title="G1 和 ZGC"></a>G1 和 ZGC</h3><h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><p>标记-复制算法应用在CMS新生代（ParNew是CMS默认的新生代垃圾回收器）和G1垃圾回收器中。标记-复制算法可以分为三个阶段：</p><ol><li>标记阶段，即从GC Roots集合开始，标记活跃对象；</li><li>转移阶段，即把活跃对象复制到新的内存地址上；</li><li>重定位阶段，因为<strong>转移导致对象的地址发生了变化，在重定位阶段，所有指向对象旧地址的指针都要调整到对象新的地址上</strong> 需要复制。<br>下面以G1为例，通过G1中标记-复制算法过程（G1的Young GC和Mixed GC均采用该算法），分析G1停顿耗时的主要瓶颈。G1垃圾回收周期如下图所示：<br><img src="/./img/jdk/jvm/g1-garbage-collector.png" alt="g1"><br>G1的混合回收过程可以分为标记阶段、清理阶段和复制阶段。<br>1.1. 标记阶段停顿分析<br>1.1.1. 初始标记阶段：初始标记阶段是指从GC Roots出发标记全部直接子节点的过程，该阶段是STW的。由于GC Roots数量不多，通常该阶段耗时非常短。<br>1.1.2. 并发标记阶段：并发标记阶段是指从GC Roots开始对堆中对象进行可达性分析，找出存活对象。该阶段是并发的，即应用线程和GC线程可以同时活动。并发标记耗时相对长很多，但因为不是STW，所以我们不太关心该阶段耗时的长短。<br>1.1.3. 再标记阶段：重新标记那些在并发标记阶段发生变化的对象。该阶段是STW的。<br>清理阶段停顿分析<br>1.1.4. 清理阶段清点出有存活对象的分区和没有存活对象的分区，该阶段不会清理垃圾对象，也不会执行存活对象的复制。该阶段是STW的。<br>复制阶段停顿分析</li></ol><h5 id="g1-耗时长原因"><a href="#g1-耗时长原因" class="headerlink" title="g1 耗时长原因"></a>g1 耗时长原因</h5><p>复制算法中的转移阶段需要分配新内存和复制对象的成员变量。转移阶段是STW的，其中内存分配通常耗时非常短，但对象成员变量的复制耗时有可能较长，这是因为复制耗时与存活对象数量与对象复杂度成正比。对象越复杂，复制耗时越长。<br>四个STW过程中，初始标记因为只标记GC Roots，耗时较短。再标记因为对象数少，耗时也较短。清理阶段因为内存分区数量少，耗时也较短。<strong>转移阶段要处理所有存活的对象，耗时会较长。因此，G1停顿时间的瓶颈主要是标记-复制中的转移阶段STW。为什么转移阶段不能和标记阶段一样并发执行呢？主要是G1未能解决转移过程中准确定位对象地址的问题</strong>。</p><h4 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h4><p>与CMS中的ParNew和G1类似，ZGC也采用标记-复制算法，不过ZGC对该算法做了重大改进：ZGC在标记、转移和重定位阶段几乎都是并发的，这是ZGC实现停顿时间小于10ms目标的最关键原因。<br>ZGC只有三个STW阶段：初始标记，再标记，初始转移。其中，初始标记和初始转移分别都只需要扫描所有GC Roots，其处理时间和GC Roots的数量成正比，一般情况耗时非常短；再标记阶段STW时间很短，最多1ms，超过1ms则再次进入并发标记阶段。即，ZGC几乎所有暂停都只依赖于GC Roots集合大小，停顿时间不会随着堆的大小或者活跃对象的大小而增加。与ZGC对比，G1的转移阶段完全STW的，且停顿时间随存活对象的大小增加而增加。<br><img src="/./img/jdk/jvm/zgc.png" alt="zgc"></p><h2 id="zgc-如何实现并发转移的复制"><a href="#zgc-如何实现并发转移的复制" class="headerlink" title="zgc 如何实现并发转移的复制"></a>zgc 如何实现并发转移的复制</h2><p>ZGC通过着色指针和读屏障技术，解决了转移过程中准确访问对象的问题，实现了并发转移。大致原理描述如下：并发转移中“并发”意味着GC线程在转移对象的过程中，应用线程也在不停地访问对象。假设对象发生转移，但对象地址未及时更新，那么应用线程可能访问到旧地址，从而造成错误。<code>而在ZGC中，应用线程访问对象将触发“读屏障”，如果发现对象被移动了，那么“读屏障”会把读出来的指针更新到对象的新地址上，这样应用线程始终访问的都是对象的新地址。那么，JVM是如何判断对象被移动过呢？就是利用对象引用的地址，即着色指针&#39;</code>。下面介绍着色指针和读屏障技术细节。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版》</li><li><a href="https://my.oschina.net/hosee/blog/644618">https://my.oschina.net/hosee/blog/644618</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>jvm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>虚拟机内存</title>
    <link href="/2022/12/14/jvm/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98/"/>
    <url>/2022/12/14/jvm/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p>如果没有特殊说明，都是针对的是 HotSpot 虚拟机。</p><p>本文基于《深入理解 Java 虚拟机：JVM 高级特性与最佳实践》进行总结补充。</p><p>常见面试题 ：</p><ul><li>介绍下 Java 内存区域（运行时数据区）</li><li>Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）</li><li>对象的访问定位的两种方式（句柄和直接指针两种方式）</li></ul></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像 C&#x2F;C++程序开发程序员这样为每一个 new 操作去写对应的 delete&#x2F;free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。</p><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK 1.8 和之前的版本略有不同，下面会介绍到。</p><p><strong>JDK 1.8 之前</strong> ：</p><p><img src="/./img/jdk/jvm/java-runtime-data-areas-jdk1.7.png" alt="Java 运行时数据区域（JDK1.8 之前）"></p><p><strong>JDK 1.8 之后</strong> ：</p><p><img src="/./img/jdk/jvm/java-runtime-data-areas-jdk1.8.png" alt="Java 运行时数据区域（JDK1.8 之后）"></p><p><strong>线程私有的：</strong></p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul><p><strong>线程共享的：</strong></p><ul><li>堆</li><li>方法区</li><li>直接内存 (非运行时数据区的一部分)</li></ul><p>Java 虚拟机规范对于运行时数据区域的规定是相当宽松的。以堆为例：堆可以是连续空间，也可以不连续。堆的大小可以固定，也可以在运行时按需扩展 。虚拟机实现者可以使用任何垃圾回收算法管理堆，甚至完全不进行垃圾收集也是可以的。</p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</p><p>另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>从上面的介绍中我们知道了程序计数器主要有两个作用：</p><ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ul><p>⚠️ 注意 ：程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p><h3 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h3><p>与程序计数器一样，Java 虚拟机栈（后文简称栈）也是线程私有的，它的生命周期和线程相同，随着线程的创建而创建，随着线程的死亡而死亡。</p><p>栈绝对算的上是 JVM 运行时数据区域的一个核心，除了一些 Native 方法调用是通过本地方法栈实现的(后面会提到)，其他所有的 Java 方法调用都是通过栈来实现的（也需要和其他运行时数据区域比如程序计数器配合）。</p><p>方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。</p><p>栈由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。和数据结构上的栈类似，两者都是先进后出的数据结构，只支持出栈和入栈两种操作。</p><p><img src="/./img/jdk/jvm/stack-area.png" alt="Java 虚拟机栈"></p><p><strong>局部变量表</strong> 主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p><p><img src="/./img/jdk/jvm/local-variables-table.png" alt="局部变量表"></p><p><strong>操作数栈</strong> 主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。</p><p><strong>动态链接</strong> 主要服务一个方法需要调用其他方法的场景。在 Java 源文件被编译成字节码文件时，所有的变量和方法引用都作为符号引用（Symbilic Reference）保存在 Class 文件的常量池里。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用。</p><p><img src="/./img/jdk/jvm/jvmimage-20220331175738692.png"></p><p>栈空间虽然不是无限的，但一般正常调用的情况下是不会出现问题的。不过，如果函数调用陷入无限循环的话，就会导致栈中被压入太多栈帧而占用太多空间，导致栈空间过深。那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 <code>StackOverFlowError</code> 错误。</p><p>Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。也就是说， <strong>栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。</strong></p><p>除了 <code>StackOverFlowError</code> 错误之外，栈还可能会出现<code>OutOfMemoryError</code>错误，这是因为如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常。</p><p>简单总结一下程序运行中栈可能会出现两种错误：</p><ul><li><strong><code>StackOverFlowError</code>：</strong> 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 <code>StackOverFlowError</code> 错误。</li><li><strong><code>OutOfMemoryError</code>：</strong> 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常。</li></ul><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p><p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p><p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 <code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code> 两种错误。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p><p>Java 世界中“几乎”所有的对象都在堆中分配，但是，随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。</p><p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p><ol><li>新生代内存(Young Generation)</li><li>老生代(Old Generation)</li><li>永久代(Permanent Generation)</li></ol><p>下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。</p><p><img src="/./img/jdk/jvm/hotspot-heap-structure.png" alt="hotspot-heap-structure"></p><p><strong>JDK 8 版本之后 PermGen(永久) 已被 Metaspace(元空间) 取代，元空间使用的是直接内存</strong> （我会在方法区这部分内容详细介绍到）。</p><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><blockquote><p><strong>🐛 修正（参见：<a href="https://github.com/Snailclimb/JavaGuide/issues/552">issue552</a>）</strong> ：“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。</p><p><strong>动态年龄计算的代码如下</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">uint <span class="hljs-title">ageTable::compute_tenuring_threshold</span><span class="hljs-params">(<span class="hljs-type">size_t</span> survivor_capacity)</span> </span>&#123;<br><span class="hljs-comment">//survivor_capacity是survivor空间的大小</span><br><span class="hljs-type">size_t</span> desired_survivor_size = (<span class="hljs-type">size_t</span>)((((<span class="hljs-type">double</span>) survivor_capacity)*TargetSurvivorRatio)/<span class="hljs-number">100</span>);<br><span class="hljs-type">size_t</span> total = <span class="hljs-number">0</span>;<br>uint age = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (age &lt; table_size) &#123;<br>total += sizes[age];<span class="hljs-comment">//sizes数组是每个年龄段对象大小</span><br><span class="hljs-keyword">if</span> (total &gt; desired_survivor_size) <span class="hljs-keyword">break</span>;<br>age++;<br>&#125;<br>uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;<br>...<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>堆这里最容易出现的就是 <code>OutOfMemoryError</code> 错误，并且出现这种错误之后的表现形式还会有几种，比如：</p><ol><li><strong><code>java.lang.OutOfMemoryError: GC Overhead Limit Exceeded</code></strong> ： 当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</li><li><strong><code>java.lang.OutOfMemoryError: Java heap space</code></strong> :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过<code>-Xmx</code>参数配置，若没有特别配置，将会使用默认值，详见：<a href="https://stackoverflow.com/questions/28272923/default-xmxsize-in-java-8-max-heap-size">Default Java 8 max heap size</a>)</li></ol><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。</p><p>《Java虚拟机规范》只是规定了有方法区这么个概念和它的作用，方法区到底要如何实现那就是虚拟机自己要考虑的事情了。也就是说，在不同的虚拟机实现上，方法区的实现是不同的。</p><p>当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。</p><p><strong>方法区和永久代以及元空间是什么关系呢？</strong> 方法区和永久代以及元空间的关系很像 Java 中接口和类的关系，类实现了接口，这里的类就可以看作是永久代和元空间，接口可以看作是方法区，也就是说永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。</p><p><img src="/./img/jdk/jvm/method-area-implementation.png" alt="HotSpot 虚拟机方法区的两种实现"></p><p><strong>为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</strong></p><p>下图来自《深入理解 Java 虚拟机》第 3 版 2.2.5</p><p><img src="/./img/jdk/jvm/20210425134508117.png"></p><p>1、整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</p><blockquote><p>当元空间溢出时会得到如下错误： <code>java.lang.OutOfMemoryError: MetaSpace</code></p></blockquote><p>你可以使用 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。<code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</p><p>2、元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 <code>MaxPermSize</code> 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。</p><p>3、在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。</p><p><strong>方法区常用参数有哪些？</strong></p><p>JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">-XX:PermSize=N <span class="hljs-comment">//方法区 (永久代) 初始大小</span><br>-XX:MaxPermSize=N <span class="hljs-comment">//方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span><br></code></pre></td></tr></table></figure><p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</p><p>JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。下面是一些常用参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">-XX:MetaspaceSize=N <span class="hljs-comment">//设置 Metaspace 的初始（和最小大小）</span><br>-XX:MaxMetaspaceSize=N <span class="hljs-comment">//设置 Metaspace 的最大大小</span><br></code></pre></td></tr></table></figure><p>与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 <strong>常量池表(Constant Pool Table)</strong> 。</p><p>字面量是源代码中的固定值的表示法，即通过字面我们就能知道其值的含义。字面量包括整数、浮点数和字符串字面量，符号引用包括类符号引用、字段符号引用、方法符号引用和接口方法符号引用。</p><p>常量池表会在类加载后存放到方法区的运行时常量池中。</p><p>运行时常量池的功能类似于传统编程语言的符号表，尽管它包含了比典型符号表更广泛的数据。</p><p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 错误。</p><h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在堆中创建字符串对象”ab“</span><br><span class="hljs-comment">// 将字符串对象”ab“的引用保存在字符串常量池中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">aa</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br><span class="hljs-comment">// 直接返回字符串常量池中字符串对象”ab“的引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>System.out.println(aa==bb);<span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>HotSpot 虚拟机中字符串常量池的实现是 <code>src/hotspot/share/classfile/stringTable.cpp</code> ,<code>StringTable</code> 本质上就是一个<code>HashSet&lt;String&gt;</code> ,容量为 <code>StringTableSize</code>（可以通过 <code>-XX:StringTableSize</code> 参数来设置）。</p><p><strong><code>StringTable</code> 中保存的是字符串对象的引用，字符串对象的引用指向堆中的字符串对象。</strong></p><p>JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。</p><p><img src="/./img/jdk/jvm/method-area-jdk1.6.png" alt="method-area-jdk1.6"></p><p><img src="/./img/jdk/jvm/method-area-jdk1.7.png" alt="method-area-jdk1.7"></p><p><strong>JDK 1.7 为什么要将字符串常量池移动到堆中？</strong></p><p>主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。</p><p>相关问题：<a href="https://www.zhihu.com/question/57109429/answer/151717241">JVM 常量池中存储的是对象还是引用呢？ - RednaxelaFX - 知乎</a></p><p>最后再来分享一段周志明老师在<a href="https://github.com/fenixsoft/jvm_book">《深入理解 Java 虚拟机（第 3 版）》样例代码&amp;勘误</a> Github 仓库的 <a href="https://github.com/fenixsoft/jvm_book/issues/112">issue#112</a> 中说过的话：</p><blockquote><p><strong>运行时常量池、方法区、字符串常量池这些都是不随虚拟机实现而改变的逻辑概念，是公共且抽象的，Metaspace、Heap 是与具体某种虚拟机实现相关的物理概念，是私有且具体的。</strong></p></blockquote><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。</p><p>JDK1.4 中新加入的 <strong>NIO(New Input&#x2F;Output) 类</strong>，引入了一种基于<strong>通道（Channel）</strong>与<strong>缓存区（Buffer）</strong>的 I&#x2F;O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为<strong>避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</p><p>本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p><h2 id="HotSpot-虚拟机对象探秘"><a href="#HotSpot-虚拟机对象探秘" class="headerlink" title="HotSpot 虚拟机对象探秘"></a>HotSpot 虚拟机对象探秘</h2><p>通过上面的介绍我们大概知道了虚拟机的内存情况，下面我们来详细的了解一下 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。</p><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>Java 对象的创建过程我建议最好是能默写出来，并且要掌握每一步在做什么。</p><h4 id="Step1-类加载检查"><a href="#Step1-类加载检查" class="headerlink" title="Step1:类加载检查"></a>Step1:类加载检查</h4><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><h4 id="Step2-分配内存"><a href="#Step2-分配内存" class="headerlink" title="Step2:分配内存"></a>Step2:分配内存</h4><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p><p><strong>内存分配的两种方式</strong> （补充内容，需要掌握）：</p><ul><li>指针碰撞 ：<ul><li>适用场合 ：堆内存规整（即没有内存碎片）的情况下。</li><li>原理 ：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li><li>使用该分配方式的 GC 收集器：Serial, ParNew</li></ul></li><li>空闲列表 ：<ul><li>适用场合 ： 堆内存不规整的情况下。</li><li>原理 ：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。</li><li>使用该分配方式的 GC 收集器：CMS</li></ul></li></ul><p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的。</p><p><strong>内存分配并发问题（补充内容，需要掌握）</strong></p><p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p><ul><li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li><li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li></ul><h4 id="Step3-初始化零值"><a href="#Step3-初始化零值" class="headerlink" title="Step3:初始化零值"></a>Step3:初始化零值</h4><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><h4 id="Step4-设置对象头"><a href="#Step4-设置对象头" class="headerlink" title="Step4:设置对象头"></a>Step4:设置对象头</h4><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><h4 id="Step5-执行-init-方法"><a href="#Step5-执行-init-方法" class="headerlink" title="Step5:执行 init 方法"></a>Step5:执行 init 方法</h4><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p><p><strong>Hotspot 虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p><p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：<strong>使用句柄</strong>、<strong>直接指针</strong>。</p><h4 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h4><p>如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。</p><p><img src="/./img/jdk/jvm/access-location-of-object-handle.png" alt="对象的访问定位-使用句柄"></p><h4 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h4><p>如果使用直接指针访问，reference 中存储的直接就是对象的地址。</p><p><img src="/./img/jdk/jvm/access-location-of-object-handle-direct-pointer.png" alt="对象的访问定位-直接指针"></p><p>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p><p>HotSpot 虚拟机主要使用的就是这种方式来进行对象访问。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版》</li><li>《自己动手写 Java 虚拟机》</li><li>Chapter 2. The Structure of the Java Virtual Machine：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html</a></li><li>JVM 栈帧内部结构-动态链接：<a href="https://chenxitag.com/archives/368">https://chenxitag.com/archives/368</a></li><li>Java 中 new String(“字面量”) 中 “字面量” 是何时进入字符串常量池的? - 木女孩的回答 - 知乎： <a href="https://www.zhihu.com/question/55994121/answer/147296098">https://www.zhihu.com/question/55994121/answer/147296098</a></li><li>JVM 常量池中存储的是对象还是引用呢？ - RednaxelaFX 的回答 - 知乎： <a href="https://www.zhihu.com/question/57109429/answer/151717241">https://www.zhihu.com/question/57109429/answer/151717241</a></li><li><a href="http://www.pointsoftware.ch/en/under-the-hood-runtime-data-areas-javas-memory-model/">http://www.pointsoftware.ch/en/under-the-hood-runtime-data-areas-javas-memory-model/</a></li><li><a href="https://dzone.com/articles/jvm-permgen-%E2%80%93-where-art-thou">https://dzone.com/articles/jvm-permgen-%E2%80%93-where-art-thou</a></li><li><a href="https://stackoverflow.com/questions/9095748/method-area-and-permgen">https://stackoverflow.com/questions/9095748/method-area-and-permgen</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>jvm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面试</title>
    <link href="/2022/12/14/mysql/mysql/"/>
    <url>/2022/12/14/mysql/mysql/</url>
    
    <content type="html"><![CDATA[<h1 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h1><h2 id="事物特性"><a href="#事物特性" class="headerlink" title="事物特性"></a>事物特性</h2><ol><li><strong>原子性</strong>（<code>Atomicity</code>） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li><strong>一致性</strong>（<code>Consistency</code>）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li><li><strong>隔离性</strong>（<code>Isolation</code>）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li><strong>持久性</strong>（<code>Durability</code>）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ol><h2 id="事物并发带来的问题"><a href="#事物并发带来的问题" class="headerlink" title="事物并发带来的问题"></a>事物并发带来的问题</h2><h3 id="脏读（Dirty-read）"><a href="#脏读（Dirty-read）" class="headerlink" title="脏读（Dirty read）"></a>脏读（Dirty read）</h3><p>一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。</p><p>例如：事务 1 读取某表中的数据 A&#x3D;20，事务 1 修改 A&#x3D;A-1，事务 2 读取到 A &#x3D; 19,事务 1 回滚导致对 A 的修改并为提交到数据库， A 的值还是 20。</p><h3 id="丢失修改（Lost-to-modify）"><a href="#丢失修改（Lost-to-modify）" class="headerlink" title="丢失修改（Lost to modify）"></a>丢失修改（Lost to modify）</h3><p>在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。<br>例如：事务 1 读取某表中的数据 A&#x3D;20，事务 2 也读取 A&#x3D;20，事务 1 先修改 A&#x3D;A-1，事务 2 后来也修改 A&#x3D;A-1，最终结果 A&#x3D;19，事务 1 的修改被丢失。</p><h3 id="不可重复读（Unrepeatable-read）"><a href="#不可重复读（Unrepeatable-read）" class="headerlink" title="不可重复读（Unrepeatable read）"></a>不可重复读（Unrepeatable read）</h3><p>指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p><p>例如：事务 1 读取某表中的数据 A&#x3D;20，事务 2 也读取 A&#x3D;20，事务 1 修改 A&#x3D;A-1，事务 2 再次读取 A &#x3D;19，此时读取的结果和第一次读取的结果不同。</p><h3 id="幻读（Phantom-read）"><a href="#幻读（Phantom-read）" class="headerlink" title="幻读（Phantom read）"></a>幻读（Phantom read）</h3><p>幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。<br>例如：事务 2 读取某个范围的数据，事务 1 在这个范围插入了新的数据，事务 1 再次读取这个范围的数据发现相比于第一次读取的结果多了新的数据。</p><h3 id="不可重复读和幻读有什么区别？"><a href="#不可重复读和幻读有什么区别？" class="headerlink" title="不可重复读和幻读有什么区别？"></a>不可重复读和幻读有什么区别？</h3><ul><li>不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改；</li><li>幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。<br>幻读其实可以看作是不可重复读的一种特殊情况，单独把区分幻读的原因主要是解决幻读和不可重复读的方案不一样。<br>举个例子：执行 <code>delete</code> 和 <code>update</code> 操作的时候，可以直接对记录加锁，保证事务安全。而执行 <code>insert</code> 操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行 <code>insert</code> 操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读。</li></ul><h2 id="事物隔离级别"><a href="#事物隔离级别" class="headerlink" title="事物隔离级别"></a>事物隔离级别</h2><p>SQL 标准定义了四个隔离级别：</p><ul><li><strong>READ-UNCOMMITTED(读取未提交)</strong> ： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li><strong>READ-COMMITTED(读取已提交)</strong> ： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li><strong>REPEATABLE-READ(可重复读)</strong> ： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><strong>SERIALIZABLE(可串行化)</strong> ： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li></ul><hr><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">READ-UNCOMMITTED</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">READ-COMMITTED</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">REPEATABLE-READ</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">SERIALIZABLE</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看，MySQL 8.0 该命令改为<code>SELECT @@transaction_isolation;</code></p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="索引介绍"><a href="#索引介绍" class="headerlink" title="索引介绍"></a>索引介绍</h2><p><strong>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</strong></p><p>索引的作用就相当于书的目录。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p><p>索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了 B+树作为索引结构。</p><h2 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h2><p><strong>优点</strong> ：</p><ul><li>使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。</li><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li></ul><p><strong>缺点</strong> ：</p><ul><li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li><li>索引需要使用物理文件存储，也会耗费一定空间。</li></ul><p>但是，<strong>使用索引一定能提高查询性能吗?</strong></p><p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。</p><h2 id="索引的底层数据结构"><a href="#索引的底层数据结构" class="headerlink" title="索引的底层数据结构"></a>索引的底层数据结构</h2><h3 id="Hash-表"><a href="#Hash-表" class="headerlink" title="Hash 表"></a>Hash 表</h3><p>哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O（1））。</p><p><strong>为何能够通过 key 快速取出 value 呢？</strong> 原因在于 <strong>哈希算法</strong>（也叫散列算法）。通过哈希算法，我们可以快速找到 key 对应的 index，找到了 index 也就找到了对应的 value。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">hash = hashfunc(key)<br>index = hash % array_size<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210513092328171.png"></p><p>但是！哈希算法有个 <strong>Hash 冲突</strong> 问题，也就是说多个不同的 key 最后得到的 index 相同。通常情况下，我们常用的解决办法是 <strong>链地址法</strong>。链地址法就是将哈希冲突数据存放在链表中。就比如 JDK1.8 之前 <code>HashMap</code> 就是通过链地址法来解决哈希冲突的。不过，JDK1.8 以后<code>HashMap</code>为了减少链表过长的时候搜索时间过长引入了红黑树。</p><p><img src="https://img-blog.csdnimg.cn/20210513092224836.png"></p><p>为了减少 Hash 冲突的发生，一个好的哈希函数应该“均匀地”将数据分布在整个可能的哈希值集合中。</p><p>既然哈希表这么快，<strong>为什么 MySQL 没有使用其作为索引的数据结构呢？</strong> 主要是因为 Hash 索引不支持顺序和范围查询。假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。并且，每次 IO 只能取一个。</p><p>试想一种情况:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">SELECT * FROM tb1 WHERE id &lt; <span class="hljs-number">500</span>;<br></code></pre></td></tr></table></figure><p>在这种范围查询中，优势非常大，直接遍历比 500 小的叶子节点就够了。而 Hash 索引是根据 hash 算法来定位的，难不成还要把 1 - 499 的数据，每个都进行一次 hash 计算来定位吗?这就是 Hash 最大的缺点了。</p><h3 id="B-树-amp-B-树"><a href="#B-树-amp-B-树" class="headerlink" title="B 树&amp; B+树"></a>B 树&amp; B+树</h3><p>B 树也称 B-树,全称为 <strong>多路平衡查找树</strong> ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 <code>Balanced</code> （平衡）的意思。</p><p>目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。</p><p><strong>B 树&amp; B+树两者有何异同呢？</strong></p><ul><li>B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li><li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li><li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li></ul><p>在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。（下面的内容整理自《Java 工程师修炼之道》）</p><blockquote><p>MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“<strong>非聚簇索引（非聚集索引）</strong>”。</p><p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“<strong>聚簇索引（聚集索引）</strong>”，而其余的索引都作为 <strong>辅助索引</strong> ，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p></blockquote><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><h3 id="主键索引-Primary-Key"><a href="#主键索引-Primary-Key" class="headerlink" title="主键索引(Primary Key)"></a>主键索引(Primary Key)</h3><p>数据表的主键列使用的就是主键索引。</p><p>一张数据表有只能有一个主键，并且主键不能为 null，不能重复。</p><p>在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在 null 值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/open-source-project/cluster-index.png"></p><h3 id="二级索引-辅助索引"><a href="#二级索引-辅助索引" class="headerlink" title="二级索引(辅助索引)"></a>二级索引(辅助索引)</h3><p><strong>二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。</strong></p><p>唯一索引，普通索引，前缀索引等索引属于二级索引。</p><p>PS: 不懂的同学可以暂存疑，慢慢往下看，后面会有答案的，也可以自行搜索。</p><ol><li><strong>唯一索引(Unique Key)</strong> ：唯一索引也是一种约束。<strong>唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。</strong> 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li><li><strong>普通索引(Index)</strong> ：<strong>普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</strong></li><li><strong>前缀索引(Prefix)</strong> ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小，<br>因为只取前几个字符。</li><li><strong>全文索引(Full Text)</strong> ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</li></ol><p>二级索引:</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/open-source-project/no-cluster-index.png"></p><h2 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h2><h3 id="聚簇索引（聚集索引）"><a href="#聚簇索引（聚集索引）" class="headerlink" title="聚簇索引（聚集索引）"></a>聚簇索引（聚集索引）</h3><h4 id="聚簇索引介绍"><a href="#聚簇索引介绍" class="headerlink" title="聚簇索引介绍"></a>聚簇索引介绍</h4><p><strong>聚簇索引即索引结构和数据一起存放的索引，并不是一种单独的索引类型。InnoDB 中的主键索引就属于聚簇索引。</strong></p><p>在 MySQL 中，InnoDB 引擎的表的 <code>.ibd</code>文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p><h4 id="聚簇索引的优缺点"><a href="#聚簇索引的优缺点" class="headerlink" title="聚簇索引的优缺点"></a>聚簇索引的优缺点</h4><p><strong>优点</strong> ：</p><ul><li><strong>查询速度非常快</strong> ：聚簇索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引， 聚簇索引少了一次读取数据的 IO 操作。</li><li><strong>对排序查找和范围查找优化</strong> ：聚簇索引对于主键的排序查找和范围查找速度非常快。</li></ul><p><strong>缺点</strong> ：</p><ul><li><strong>依赖于有序的数据</strong> ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li><li><strong>更新代价大</strong> ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。</li></ul><h3 id="非聚簇索引（非聚集索引）"><a href="#非聚簇索引（非聚集索引）" class="headerlink" title="非聚簇索引（非聚集索引）"></a>非聚簇索引（非聚集索引）</h3><h4 id="非聚簇索引介绍"><a href="#非聚簇索引介绍" class="headerlink" title="非聚簇索引介绍"></a>非聚簇索引介绍</h4><p><strong>非聚簇索引即索引结构和数据分开存放的索引，并不是一种单独的索引类型。二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引</strong></p><p>非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</p><h4 id="非聚簇索引的优缺点"><a href="#非聚簇索引的优缺点" class="headerlink" title="非聚簇索引的优缺点"></a>非聚簇索引的优缺点</h4><p><strong>优点</strong> ：</p><p>更新代价比聚簇索引要小 。非聚簇索引的更新代价就没有聚簇索引那么大了，非聚簇索引的叶子节点是不存放数据的</p><p><strong>缺点</strong> ：</p><ul><li><strong>依赖于有序的数据</strong> ：跟聚簇索引一样，非聚簇索引也依赖于有序的数据</li><li><strong>可能会二次查询(回表)</strong> ：这应该是非聚簇索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li></ul><p>这是 MySQL 的表的文件截图:</p><p><img src="https://img-blog.csdnimg.cn/20210420165311654.png"></p><p>聚簇索引和非聚簇索引:</p><p><img src="https://img-blog.csdnimg.cn/20210420165326946.png"></p><h4 id="非聚簇索引一定回表查询吗-覆盖索引"><a href="#非聚簇索引一定回表查询吗-覆盖索引" class="headerlink" title="非聚簇索引一定回表查询吗(覆盖索引)?"></a>非聚簇索引一定回表查询吗(覆盖索引)?</h4><p><strong>非聚簇索引不一定回表查询。</strong></p><p>试想一种情况，用户准备使用 SQL 查询用户名，而用户名字段正好建立了索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;guang19&#x27;</span>;<br></code></pre></td></tr></table></figure><p>那么这个索引的 key 本身就是 name，查到对应的 name 直接返回就行了，无需回表查询。</p><p>即使是 MYISAM 也是这样，虽然 MYISAM 的主键索引确实需要回表，因为它的主键索引的叶子节点存放的是指针。但是！<strong>如果 SQL 查的就是主键呢?</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>主键索引本身的 key 就是主键，查到返回就行了。这种情况就称之为覆盖索引了。</p><h2 id="覆盖索引和联合索引"><a href="#覆盖索引和联合索引" class="headerlink" title="覆盖索引和联合索引"></a>覆盖索引和联合索引</h2><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p><p><strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。</strong></p><blockquote><p>如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。</p><p>再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引，<br>那么直接根据这个索引就可以查到数据，也无需回表。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210420165341868.png" alt="覆盖索引"></p><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>使用表中的多个字段创建索引，就是 <strong>联合索引</strong>，也叫 <strong>组合索引</strong> 或 <strong>复合索引</strong>。</p><h3 id="最左前缀匹配原则"><a href="#最左前缀匹配原则" class="headerlink" title="最左前缀匹配原则"></a>最左前缀匹配原则</h3><p>最左前缀匹配原则指的是，在使用联合索引时，<strong>MySQL</strong> 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询，如 <strong><code>&gt;</code><strong>、</strong><code>&lt;</code><strong>、</strong><code>between</code></strong> 和 <strong><code>以%开头的like查询</code></strong> 等条件，才会停止匹配。</p><p>所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。</p><h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><p><strong>索引下推（Index Condition Pushdown）</strong> 是 <strong>MySQL 5.6</strong> 版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。</p><h2 id="正确使用索引的一些建议"><a href="#正确使用索引的一些建议" class="headerlink" title="正确使用索引的一些建议"></a>正确使用索引的一些建议</h2><h3 id="选择合适的字段创建索引"><a href="#选择合适的字段创建索引" class="headerlink" title="选择合适的字段创建索引"></a>选择合适的字段创建索引</h3><ul><li><strong>不为 NULL 的字段</strong> ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。</li><li><strong>被频繁查询的字段</strong> ：我们创建索引的字段应该是查询操作非常频繁的字段。</li><li><strong>被作为条件查询的字段</strong> ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</li><li><strong>频繁需要排序的字段</strong> ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</li><li><strong>被经常频繁用于连接的字段</strong> ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</li></ul><h3 id="被频繁更新的字段应该慎重建立索引"><a href="#被频繁更新的字段应该慎重建立索引" class="headerlink" title="被频繁更新的字段应该慎重建立索引"></a>被频繁更新的字段应该慎重建立索引</h3><p>虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p><h3 id="尽可能的考虑建立联合索引而不是单列索引"><a href="#尽可能的考虑建立联合索引而不是单列索引" class="headerlink" title="尽可能的考虑建立联合索引而不是单列索引"></a>尽可能的考虑建立联合索引而不是单列索引</h3><p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p><h3 id="注意避免冗余索引"><a href="#注意避免冗余索引" class="headerlink" title="注意避免冗余索引"></a>注意避免冗余索引</h3><p>冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p><h3 id="考虑在字符串类型的字段上使用前缀索引代替普通索引"><a href="#考虑在字符串类型的字段上使用前缀索引代替普通索引" class="headerlink" title="考虑在字符串类型的字段上使用前缀索引代替普通索引"></a>考虑在字符串类型的字段上使用前缀索引代替普通索引</h3><p>前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。</p><h3 id="避免索引失效"><a href="#避免索引失效" class="headerlink" title="避免索引失效"></a>避免索引失效</h3><p>索引失效也是慢查询的主要原因之一，常见的导致索引失效的情况有下面这些：</p><ul><li>使用 <code>SELECT *</code> 进行查询;</li><li>创建了组合索引，但查询条件未准守最左匹配原则;</li><li>在索引列上进行计算、函数、类型转换等操作;</li><li>以 % 开头的 LIKE 查询比如 <code>like &#39;%abc&#39;;</code>;</li><li>查询条件中使用 or，且 or 的前后条件中有一个列没有索引，涉及的索引都不会被使用到;</li><li>发生<a href="https://javaguide.cn/database/mysql/index-invalidation-caused-by-implicit-conversion.html">隐式转换</a>;</li><li>……</li></ul><h3 id="删除长期未使用的索引"><a href="#删除长期未使用的索引" class="headerlink" title="删除长期未使用的索引"></a>删除长期未使用的索引</h3><p>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 schema_unused_indexes 视图来查询哪些索引从未被使用</p><h2 id="索引设计规范"><a href="#索引设计规范" class="headerlink" title="索引设计规范"></a>索引设计规范</h2><h3 id="限制每张表上的索引数量-建议单张表索引不超过-5-个"><a href="#限制每张表上的索引数量-建议单张表索引不超过-5-个" class="headerlink" title="限制每张表上的索引数量,建议单张表索引不超过 5 个"></a>限制每张表上的索引数量,建议单张表索引不超过 5 个</h3><p>索引并不是越多越好！索引可以提高效率同样可以降低效率。</p><p>索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。</p><p>因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。</p><h3 id="禁止使用全文索引"><a href="#禁止使用全文索引" class="headerlink" title="禁止使用全文索引"></a>禁止使用全文索引</h3><p>全文索引不适用于 OLTP 场景。</p><h3 id="禁止给表中的每一列都建立单独的索引"><a href="#禁止给表中的每一列都建立单独的索引" class="headerlink" title="禁止给表中的每一列都建立单独的索引"></a>禁止给表中的每一列都建立单独的索引</h3><p>5.6 版本之前，一个 sql 只能使用到一个表中的一个索引，5.6 以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好。</p><h3 id="每个-InnoDB-表必须有个主键"><a href="#每个-InnoDB-表必须有个主键" class="headerlink" title="每个 InnoDB 表必须有个主键"></a>每个 InnoDB 表必须有个主键</h3><p>InnoDB 是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种。</p><p>InnoDB 是按照主键索引的顺序来组织表的</p><ul><li>不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引）</li><li>不要使用 UUID,MD5,HASH,字符串列作为主键（无法保证数据的顺序增长）</li><li>主键建议使用自增 ID 值</li></ul><h3 id="常见索引列建议"><a href="#常见索引列建议" class="headerlink" title="常见索引列建议"></a>常见索引列建议</h3><ul><li>出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列</li><li>包含在 ORDER BY、GROUP BY、DISTINCT 中的字段</li><li>并不要将符合 1 和 2 中的字段的列都建立一个索引， 通常将 1、2 中的字段建立联合索引效果更好</li><li>多表 join 的关联列</li></ul><h3 id="如何选择索引列的顺序"><a href="#如何选择索引列的顺序" class="headerlink" title="如何选择索引列的顺序"></a>如何选择索引列的顺序</h3><p>建立索引的目的是：希望通过索引进行数据查找，减少随机 IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。</p><ul><li>区分度最高的放在联合索引的最左侧（区分度&#x3D;列中不同值的数量&#x2F;列的总行数）</li><li>尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）</li><li>使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）</li></ul><h3 id="避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）"><a href="#避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）" class="headerlink" title="避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）"></a>避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）</h3><ul><li>重复索引示例：primary key(id)、index(id)、unique index(id)</li><li>冗余索引示例：index(a,b,c)、index(a,b)、index(a)</li></ul><h3 id="对于频繁的查询优先考虑使用覆盖索引"><a href="#对于频繁的查询优先考虑使用覆盖索引" class="headerlink" title="对于频繁的查询优先考虑使用覆盖索引"></a>对于频繁的查询优先考虑使用覆盖索引</h3><blockquote><p>覆盖索引：就是包含了所有查询字段 (where,select,order by,group by 包含的字段) 的索引</p></blockquote><p><strong>覆盖索引的好处：</strong></p><ul><li><strong>避免 InnoDB 表进行索引的二次查询:</strong> InnoDB 是以聚集索引的顺序来存储的，对于 InnoDB 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。</li><li><strong>可以把随机 IO 变成顺序 IO 加快查询效率:</strong> 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。</li></ul><hr><h3 id="索引-SET-规范"><a href="#索引-SET-规范" class="headerlink" title="索引 SET 规范"></a>索引 SET 规范</h3><p><strong>尽量避免使用外键约束</strong></p><ul><li>不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引</li><li>外键可用于保证数据的参照完整性，但建议在业务端实现</li><li>外键会影响父表和子表的写操作从而降低性能</li></ul><h2 id="数据库-SQL-开发规范"><a href="#数据库-SQL-开发规范" class="headerlink" title="数据库 SQL 开发规范"></a>数据库 SQL 开发规范</h2><h3 id="优化对性能影响较大的-SQL-语句"><a href="#优化对性能影响较大的-SQL-语句" class="headerlink" title="优化对性能影响较大的 SQL 语句"></a>优化对性能影响较大的 SQL 语句</h3><p>要找到最需要优化的 SQL 语句。要么是使用最频繁的语句，要么是优化后提高最明显的语句，可以通过查询 MySQL 的慢查询日志来发现需要进行优化的 SQL 语句；</p><h3 id="充分利用表上已经存在的索引"><a href="#充分利用表上已经存在的索引" class="headerlink" title="充分利用表上已经存在的索引"></a>充分利用表上已经存在的索引</h3><p>避免使用双%号的查询条件。如：<code>a like &#39;%123%&#39;</code>，（如果无前置%,只有后置%，是可以用到列上的索引的）</p><p>一个 SQL 只能利用到复合索引中的一列进行范围查询。如：有 a,b,c 列的联合索引，在查询条件中有 a 列的范围查询，则在 b,c 列上的索引将不会被用到。</p><p>在定义联合索引时，如果 a 列要用到范围查找的话，就要把 a 列放到联合索引的右侧，使用 left join 或 not exists 来优化 not in 操作，因为 not in 也通常会使用索引失效。</p><h3 id="禁止使用-SELECT-必须使用-SELECT-lt-字段列表-gt-查询"><a href="#禁止使用-SELECT-必须使用-SELECT-lt-字段列表-gt-查询" class="headerlink" title="禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询"></a>禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询</h3><ul><li><code>SELECT *</code> 消耗更多的 CPU 和 IO 以网络带宽资源</li><li><code>SELECT *</code> 无法使用覆盖索引</li><li><code>SELECT &lt;字段列表&gt;</code> 可减少表结构变更带来的影响</li></ul><h3 id="禁止使用不含字段列表的-INSERT-语句"><a href="#禁止使用不含字段列表的-INSERT-语句" class="headerlink" title="禁止使用不含字段列表的 INSERT 语句"></a>禁止使用不含字段列表的 INSERT 语句</h3><p>如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t <span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>);<br></code></pre></td></tr></table></figure><p>应使用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t(c1,c2,c3) <span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="建议使用预编译语句进行数据库操作"><a href="#建议使用预编译语句进行数据库操作" class="headerlink" title="建议使用预编译语句进行数据库操作"></a>建议使用预编译语句进行数据库操作</h3><ul><li>预编译语句可以重复使用这些计划，减少 SQL 编译所需要的时间，还可以解决动态 SQL 所带来的 SQL 注入的问题。</li><li>只传参数，比传递 SQL 语句更高效。</li><li>相同语句可以一次解析，多次使用，提高处理效率。</li></ul><h3 id="避免数据类型的隐式转换"><a href="#避免数据类型的隐式转换" class="headerlink" title="避免数据类型的隐式转换"></a>避免数据类型的隐式转换</h3><p>隐式转换会导致索引失效如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> name,phone <span class="hljs-keyword">from</span> customer <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;111&#x27;</span>;<br></code></pre></td></tr></table></figure><p>详细解读可以看：<a href="./index-invalidation-caused-by-implicit-conversion.md">MySQL 中的隐式转换造成的索引失效</a> 这篇文章。</p><h3 id="避免使用子查询，可以把子查询优化为-join-操作"><a href="#避免使用子查询，可以把子查询优化为-join-操作" class="headerlink" title="避免使用子查询，可以把子查询优化为 join 操作"></a>避免使用子查询，可以把子查询优化为 join 操作</h3><p>通常子查询在 in 子句中，且子查询中为简单 SQL(不包含 union、group by、order by、limit 从句) 时,才可以把子查询转化为关联查询进行优化。</p><p><strong>子查询性能差的原因：</strong> 子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。</p><h3 id="避免使用-JOIN-关联太多的表"><a href="#避免使用-JOIN-关联太多的表" class="headerlink" title="避免使用 JOIN 关联太多的表"></a>避免使用 JOIN 关联太多的表</h3><p>对于 MySQL 来说，是存在关联缓存的，缓存的大小可以由 join_buffer_size 参数进行设置。</p><p>在 MySQL 中，对于同一个 SQL 多关联（join）一个表，就会多分配一个关联缓存，如果在一个 SQL 中关联的表越多，所占用的内存也就越大。</p><p>如果程序中大量的使用了多表关联的操作，同时 join_buffer_size 设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。</p><p>同时对于关联操作来说，会产生临时表操作，影响查询效率，MySQL 最多允许关联 61 个表，建议不超过 5 个。</p><h3 id="减少同数据库的交互次数"><a href="#减少同数据库的交互次数" class="headerlink" title="减少同数据库的交互次数"></a>减少同数据库的交互次数</h3><p>数据库更适合处理批量操作，合并多个相同的操作到一起，可以提高处理效率。</p><h3 id="对应同一列进行-or-判断时，使用-in-代替-or"><a href="#对应同一列进行-or-判断时，使用-in-代替-or" class="headerlink" title="对应同一列进行 or 判断时，使用 in 代替 or"></a>对应同一列进行 or 判断时，使用 in 代替 or</h3><p>in 的值不要超过 500 个，in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引。</p><h3 id="禁止使用-order-by-rand-进行随机排序"><a href="#禁止使用-order-by-rand-进行随机排序" class="headerlink" title="禁止使用 order by rand() 进行随机排序"></a>禁止使用 order by rand() 进行随机排序</h3><p>order by rand() 会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的 CPU 和 IO 及内存资源。</p><p>推荐在程序中获取一个随机值，然后从数据库中获取数据的方式。</p><h3 id="WHERE-从句中禁止对列进行函数转换和计算"><a href="#WHERE-从句中禁止对列进行函数转换和计算" class="headerlink" title="WHERE 从句中禁止对列进行函数转换和计算"></a>WHERE 从句中禁止对列进行函数转换和计算</h3><p>对列进行函数转换或计算时会导致无法使用索引</p><h2 id="使用B-树原因"><a href="#使用B-树原因" class="headerlink" title="使用B+树原因"></a>使用B+树原因</h2><ol><li>高效的查找性能：B+树是一种高效的平衡树结构，具有非常高效的查找性能。它的平均查找时间复杂度为O(logN)，能够快速地定位到目标数据的位置。</li><li>高效的范围查询：B+树是一种有序树结构，能够非常高效地支持范围查询操作。它可以快速地找到满足条件的起始位置和结束位置，从而快速地定位到需要查询的数据。</li><li>内存友好：B+树的内部节点只存储索引信息，而不存储具体的数据，因此它的内存占用比较小。此外，B+树的叶子节点是顺序存储的，能够利用操作系统的预读特性，从而更加高效地利用内存。</li><li>支持高效的插入和删除：B+树的平衡特性使得它支持高效的插入和删除操作。对于插入操作，B+树只需要在叶子节点上插入新的数据即可。对于删除操作，B+树只需要删除叶子节点上的数据即可。</li></ol>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>aqs</title>
    <link href="/2022/12/12/jdk/aqs/"/>
    <url>/2022/12/12/jdk/aqs/</url>
    
    <content type="html"><![CDATA[<h1 id="AQS-简单介绍"><a href="#AQS-简单介绍" class="headerlink" title="AQS 简单介绍"></a>AQS 简单介绍</h1><p>AQS的全称为（AbstractQueuedSynchronizer），这个类在 java.util.concurrent.locks 包下面。<br>AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue，FutureTask(jdk1.7) 等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。</p><h1 id="AQS-原理"><a href="#AQS-原理" class="headerlink" title="AQS 原理"></a>AQS 原理</h1><blockquote><p>在面试中被问到并发知识的时候，大多都会被问到“请你说一下自己对于 AQS 原理的理解”。下面给大家一个示例供大家参考，面试不是背题，大家一定要加入自己的思想，即使加入不了自己的思想也要保证自己能够通俗的讲出来而不是背出来。</p></blockquote><p>下面大部分内容其实在 AQS 类注释上已经给出了，不过是英语看着比较吃力一点，感兴趣的话可以看看源码。</p><h2 id="AQS-原理概览"><a href="#AQS-原理概览" class="headerlink" title="AQS 原理概览"></a>AQS 原理概览</h2><p><strong>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p><blockquote><p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p></blockquote><p>看个 AQS(AbstractQueuedSynchronizer)原理图：</p><p><img src="/../../img/jdk/aqs%E5%8E%9F%E7%90%86.png" alt="enter image description here"></p><p>AQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-comment">// 标识节点当前在共享模式下</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">SHARED</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>    <span class="hljs-comment">// 标识节点当前在独占模式下</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">EXCLUSIVE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// ======== 下面的几个int常量是给waitStatus用的 ===========</span><br>    <span class="hljs-comment">/** waitStatus value to indicate thread has cancelled */</span><br>    <span class="hljs-comment">// 代码此线程取消了争抢这个锁</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">/** waitStatus value to indicate successor&#x27;s thread needs unparking */</span><br>    <span class="hljs-comment">// 官方的描述是，其表示当前node的后继节点对应的线程需要被唤醒</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIGNAL</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">/** waitStatus value to indicate thread is waiting on condition */</span><br>    <span class="hljs-comment">// 本文不分析condition，所以略过吧，下一篇文章会介绍这个</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CONDITION</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * waitStatus value to indicate the next acquireShared should</span><br><span class="hljs-comment">     * unconditionally propagate</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// 同样的不分析，略过吧</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATE</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3</span>;<br>    <span class="hljs-comment">// =====================================================</span><br>    <span class="hljs-comment">// 取值为上面的1、-1、-2、-3，或者0(以后会讲到)</span><br>    <span class="hljs-comment">// 这么理解，暂时只需要知道如果这个值 大于0 代表此线程取消了等待，</span><br>    <span class="hljs-comment">//    ps: 半天抢不到锁，不抢了，ReentrantLock是可以指定timeouot的。。。</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> waitStatus;<br>    <span class="hljs-comment">// 前驱节点的引用</span><br>    <span class="hljs-keyword">volatile</span> Node prev;<br>    <span class="hljs-comment">// 后继节点的引用</span><br>    <span class="hljs-keyword">volatile</span> Node next;<br>    <span class="hljs-comment">// 这个就是线程本尊</span><br>    <span class="hljs-keyword">volatile</span> Thread thread;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;<span class="hljs-comment">//共享变量，使用volatile修饰保证线程可见性</span><br></code></pre></td></tr></table></figure><p>状态信息通过 protected 类型的<code>getState</code>，<code>setState</code>，<code>compareAndSetState</code>进行操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//返回同步状态的当前值(是否被占用)</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> state;<br>&#125;<br> <span class="hljs-comment">// 设置同步状态的值(是否被占用)</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(<span class="hljs-type">int</span> newState)</span> &#123;<br>        state = newState;<br>&#125;<br><span class="hljs-comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSetState</span><span class="hljs-params">(<span class="hljs-type">int</span> expect, <span class="hljs-type">int</span> update)</span> &#123;<br>        <span class="hljs-keyword">return</span> unsafe.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, expect, update);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="AQS对资源的共享方式"><a href="#AQS对资源的共享方式" class="headerlink" title="AQS对资源的共享方式"></a>AQS对资源的共享方式</h2><h3 id="独占"><a href="#独占" class="headerlink" title="独占"></a>独占</h3><h4 id="是否公平"><a href="#是否公平" class="headerlink" title="是否公平"></a>是否公平</h4><p>只有一个线程能执行，如 ReentrantLock。又可分为公平锁和非公平锁,ReentrantLock 同时支持两种锁,下面以 ReentrantLock 对这两种锁的定义做介绍：</p><ul><li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li><li>非公平锁：当线程要获取锁时，先通过两次 CAS 操作去抢锁，如果没抢到，当前线程再加入到队列中等待唤醒。</li></ul><h5 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h5><p>ReentrantLock 默认采用非公平锁，因为考虑获得更好的性能，通过 boolean 来决定是否用公平锁（传入 true 用公平锁）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 默认非公平锁</span><br>    sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>非公平锁的 lock 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 和公平锁相比，这里会直接先进行一次CAS，成功就返回了</span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>            setExclusiveOwnerThread(Thread.currentThread());<br>        <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// 尝试获取锁</span><br>            acquire(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// AQS.acquire(int arg)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>            selfInterrupt();<br>    &#125;<br>    <span class="hljs-comment">// 尝试获取锁</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>        <span class="hljs-keyword">return</span> nonfairTryAcquire(acquires);<br>    &#125;<br>&#125;<br>非公平锁的方式<br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">// 查看当前是否被占用, 0表示没有被占用, 可重入1 表示被占用</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 这里没有对阻塞队列进行判断</span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 确认是否为当前线程占用资源</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>        setState(nextc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java">acquireQueued 尝试将自己入队列<br>  <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 * 1. 前驱节点是头节点, 可以进行tryAcquire,</span><br><span class="hljs-comment">                 *    因为头节点是lazy init的, 初始化的时候没有放线程进去,</span><br><span class="hljs-comment">                 *    只是对state进行设置</span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                     * 如果获取到头节点, 则说明获取到锁资源成功</span><br><span class="hljs-comment">                     */</span><br>                    setHead(node);<br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                    failed = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">return</span> interrupted;<br>                &#125;<br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 * 1. 当前前驱节点不是头节点</span><br><span class="hljs-comment">                 * 2. 尝试tryAcquire失败了, 获取锁资源失败了</span><br><span class="hljs-comment">                 *          shouldParkAfterFailedAcquire 返回true,</span><br><span class="hljs-comment">                 *                  说明前驱节点的等待状态是-1, 是正常的, 当前线程需要被挂起, 等待唤醒</span><br><span class="hljs-comment">                 *                      通过parkAndCheckInterrupt 进行挂起</span><br><span class="hljs-comment">                 *</span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                    parkAndCheckInterrupt())<br>                    interrupted = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (failed)<br>                cancelAcquire(node);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java">shouldParkAfterFailedAcquire<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> &#123;<br>        <span class="hljs-comment">//获取前驱节点的状态</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> pred.waitStatus;<br>        <span class="hljs-comment">//-1 说明前驱节点是正常的, 当前线程需要挂起即可</span><br>        <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * This node has already set status asking a release</span><br><span class="hljs-comment">             * to signal it, so it can safely park.</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 大于0, 说明前驱节点取消了排队</span><br><span class="hljs-comment">         *  由于节点中线程的唤醒是需要前驱节点来操作的, 所以往前遍历寻找一个新的前驱节点</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * Predecessor was cancelled. Skip over predecessors and</span><br><span class="hljs-comment">             * indicate retry.</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                node.prev = pred = pred.prev;<br>            &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>            pred.next = node;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="hljs-comment">             * need a signal, but don&#x27;t park yet.  Caller will need to</span><br><span class="hljs-comment">             * retry to make sure it cannot acquire before parking.</span><br><span class="hljs-comment">             * 此时的前驱节点为0, 因此通过CAS 将节点状态设置为-1</span><br><span class="hljs-comment">             */</span><br>            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="/../img/jdk/mt_fail_aqsAQS.jpg" alt="加锁"></p><ol><li>CAS 尝试获取锁, 获取锁成功则将当前线程为占用了锁资源</li><li>获取锁资源<br>2.1  尝试获取锁资源<br>2.1.1 查看当前锁是否被占据<br>2.1.2 如果没有的话则通过CAS 尝试获取锁, CAS 成功则将当前线程占用了锁资源<br>2.1.3 如果本来就是当前线程拿到了锁的资源, 则进行可重入计数+, 更新当前锁的重入个数<br>2.2 获取当前锁资源失败, 则进行入队列等待<br>2.2.1 创建一个等待的 Node 节点, 通过CAS 的方式加入到队尾节点<br>2.2.1.1 如果上一步CAS 入队尾失败了, 则进行自旋的方式加入到队尾<br>2.3 尝试入队列<br>2.3.1 如果前驱节点为头节点, 则尝试获取锁<br>2.3.2 获取锁成功则将当前节点设置为头节点<br>2.3.3 如果当前节点不是头节点，或者是获取锁失败<br>2.3.4 获取前驱节点的状态, 如果状态为SIGINAL(-1) 则挂起<br>2.3.5 当前前驱节点状态大于0, 说明前驱节点取消了排队, 从后向前去找一个新的前驱节点<br>2.3.6 当前前驱节点状态为0, 通过CAS 将当前状态设置为-1</li></ol><p><img src="/../img/jdk/AQS_RELEASE.jpg" alt="释放锁"></p><ol><li>获取当前可重入锁的个数<br>1.1 如果当前线程不是占有锁的线程, 则抛出异常<br>1.2 只有当前线程完全释放了锁资源, 才对后续的节点进行唤醒<br>1.3 更新是否占有的状态</li><li>完全释放了锁, 对后续节点进行唤醒<br>2.1 如果头节点不为空，或者是头节点的状态不是初始状态, 则解除线程挂起<br>2.1.1 头节点为空, 说明是第一个节点入队列,<br>2.2 对线程解除挂起<br>2.2.1 获取头节点的状态值<br>2.2.2 如果当前头节点状态值小于0, 则将状态值CAS设置为0<br>2.2.3 获取头节点的下一个节点, 如果下一个节点为空, 或者下个节点状态是被cancel 的, 选择从后向前找到第一个waitStatus&lt; 0的<br>2.2.3.1 选择从后向前找, 而不是从前向后找, 是因为可能有节点是无效的或者是cancelled的状态<br>2.2.4 找到节点后, 进行唤醒</li></ol><p><img src="/../img/jdk/unfail_aqs.png" alt="unfail_aqs.jpg"></p><h5 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h5><p>ReentrantLock 中公平锁的 <code>lock</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        acquire(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// AbstractQueuedSynchronizer.acquire(int arg)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>            selfInterrupt();<br>    &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 1. 和非公平锁相比，这里多了一个判断：是否有线程在等待</span><br>            <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br>                compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>                setExclusiveOwnerThread(current);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>            <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>            setState(nextc);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol><li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li><li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state &#x3D;&#x3D; 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</li></ol><p>公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。</p><p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p>多个线程可同时执行，如 Semaphore&#x2F;CountDownLatch。Semaphore、CountDownLatCh、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</p><p>ReentrantReadWriteLock 可以看成是组合式，因为 ReentrantReadWriteLock 也就是读写锁允许多个线程同时对某一资源进行读。</p><p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS 已经在上层已经帮我们实现好了。</p><h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p><ol><li>使用者继承 AbstractQueuedSynchronizer 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放）</li><li>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。<br>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用，下面简单的给大家介绍一下模板方法模式，模板方法模式是一个很容易理解的设计模式之一。</li></ol><blockquote><p>模板方法模式是基于”继承“的，主要是为了在不改变模板结构的前提下在子类中重新定义模板中的内容以实现复用代码。举个很简单的例子假如我们要去一个地方的步骤是：购票<code>buyTicket()</code>-&gt;安检<code>securityCheck()</code>-&gt;乘坐某某工具回家<code>ride()</code>-&gt;到达目的地<code>arrive()</code>。我们可能乘坐不同的交通工具回家比如飞机或者火车，所以除了<code>ride()</code>方法，其他方法的实现几乎相同。我们可以定义一个包含了这些方法的抽象类，然后用户根据自己的需要继承该抽象类然后修改 <code>ride()</code>方法。</p></blockquote><p><strong>AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的模板方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">isHeldExclusively()<span class="hljs-comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span><br>tryAcquire(<span class="hljs-type">int</span>)<span class="hljs-comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span><br>tryRelease(<span class="hljs-type">int</span>)<span class="hljs-comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span><br>tryAcquireShared(<span class="hljs-type">int</span>)<span class="hljs-comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span><br>tryReleaseShared(<span class="hljs-type">int</span>)<span class="hljs-comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span><br><br></code></pre></td></tr></table></figure><p>默认情况下，每个方法都抛出 <code>UnsupportedOperationException</code>。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS 类中的其他方法都是 final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。</p><p>以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程 lock()时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失败，直到 A 线程 unlock()到 state&#x3D;0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。</p><p>再以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown()一次，state 会 CAS(Compare and Swap)减 1。等到所有子线程都执行完后(即 state&#x3D;0)，会 unpark()主调用线程，然后主调用线程就会从 await()函数返回，继续后余动作。</p><p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p><p>推荐两篇 AQS 原理和相关源码分析的文章：</p><h2 id="3-Semaphore-信号量"><a href="#3-Semaphore-信号量" class="headerlink" title="3 Semaphore(信号量)"></a>3 Semaphore(信号量)</h2><p><strong>synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。</strong></p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Snailclimb</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2018年9月30日</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: 需要一次性拿一个许可的情况</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SemaphoreExample1</span> &#123;<br>  <span class="hljs-comment">// 请求的数量</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">threadCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">550</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">// 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）</span><br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">300</span>);<br>    <span class="hljs-comment">// 一次只能允许执行的线程数量。</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">20</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; threadCount; i++) &#123;<br>      <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">threadnum</span> <span class="hljs-operator">=</span> i;<br>      threadPool.execute(() -&gt; &#123;<span class="hljs-comment">// Lambda 表达式的运用</span><br>        <span class="hljs-keyword">try</span> &#123;<br>          semaphore.acquire();<span class="hljs-comment">// 获取一个许可，所以可运行线程数量为20/1=20</span><br>          test(threadnum);<br>          semaphore.release();<span class="hljs-comment">// 释放一个许可</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>          <span class="hljs-comment">// TODO Auto-generated catch block</span><br>          e.printStackTrace();<br>        &#125;<br><br>      &#125;);<br>    &#125;<br>    threadPool.shutdown();<br>    System.out.println(<span class="hljs-string">&quot;finish&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> threadnum)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    Thread.sleep(<span class="hljs-number">1000</span>);<span class="hljs-comment">// 模拟请求的耗时操作</span><br>    System.out.println(<span class="hljs-string">&quot;threadnum:&quot;</span> + threadnum);<br>    Thread.sleep(<span class="hljs-number">1000</span>);<span class="hljs-comment">// 模拟请求的耗时操作</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行 <code>acquire</code> 方法阻塞，直到有一个许可证可以获得然后拿走一个许可证；每个 <code>release</code> 方法增加一个许可证，这可能会释放一个阻塞的 acquire 方法。然而，其实并没有实际的许可证这个对象，Semaphore 只是维持了一个可获得许可证的数量。 Semaphore 经常用于限制获取某种资源的线程数量。</p><p>当然一次也可以一次拿取和释放多个许可，不过一般没有必要这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">semaphore.acquire(<span class="hljs-number">5</span>);<span class="hljs-comment">// 获取5个许可，所以可运行线程数量为20/5=4</span><br>test(threadnum);<br>semaphore.release(<span class="hljs-number">5</span>);<span class="hljs-comment">// 获取5个许可，所以可运行线程数量为20/5=4</span><br></code></pre></td></tr></table></figure><p>除了 <code>acquire</code>方法之外，另一个比较常用的与之对应的方法是<code>tryAcquire</code>方法，该方法如果获取不到许可就立即返回 false。</p><p>Semaphore 有两种模式，公平模式和非公平模式。</p><ul><li><strong>公平模式：</strong> 调用 acquire 的顺序就是获取许可证的顺序，遵循 FIFO；</li><li><strong>非公平模式：</strong> 抢占式的。</li></ul><p><strong>Semaphore 对应的两个构造方法如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Semaphore</span><span class="hljs-params">(<span class="hljs-type">int</span> permits)</span> &#123;<br>     sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>(permits);<br> &#125;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">Semaphore</span><span class="hljs-params">(<span class="hljs-type">int</span> permits, <span class="hljs-type">boolean</span> fair)</span> &#123;<br>     sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>(permits) : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>(permits);<br> &#125;<br></code></pre></td></tr></table></figure><p><strong>这两个构造方法，都必须提供许可的数量，第二个构造方法可以指定是公平模式还是非公平模式，默认非公平模式。</strong></p><p><a href="https://github.com/Snailclimb/JavaGuide/issues/645">issue645补充内容</a> ：Semaphore与CountDownLatch一样，也是共享锁的一种实现。它默认构造AQS的state为permits。当执行任务的线程数量超出permits,那么多余的线程将会被放入阻塞队列Park,并自旋判断state是否大于0。只有当state大于0的时候，阻塞的线程才能继续执行,此时先前执行任务的线程继续执行release方法，release方法使得state的变量会加1，那么自旋的线程便会判断成功。<br>如此，每次只有最多不超过permits数量的线程能自旋成功，便限制了执行任务线程的数量。</p><p>由于篇幅问题，如果对 Semaphore 源码感兴趣的朋友可以看下这篇文章：<a href="https://juejin.im/post/5ae755366fb9a07ab508adc6">https://juejin.im/post/5ae755366fb9a07ab508adc6</a></p><h2 id="4-CountDownLatch"><a href="#4-CountDownLatch" class="headerlink" title="4 CountDownLatch"></a>4 CountDownLatch</h2><p>CountDownLatch允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。在 Java 并发中，countdownlatch 的概念是一个常见的面试题，所以一定要确保你很好的理解了它。</p><p>CountDownLatch是共享锁的一种实现,它默认构造 AQS 的 state 值为 count。当线程使用countDown方法时,其实使用了<code>tryReleaseShared</code>方法以CAS的操作来减少state,直至state为0就代表所有的线程都调用了countDown方法。当调用await方法的时候，如果state不为0，就代表仍然有线程没有调用countDown方法，那么就把已经调用过countDown的线程都放入阻塞队列Park,并自旋CAS判断state &#x3D;&#x3D; 0，直至最后一个线程调用了countDown，使得state &#x3D;&#x3D; 0，于是阻塞的线程便判断成功，全部往下执行。</p><h3 id="4-1-CountDownLatch-的两种典型用法"><a href="#4-1-CountDownLatch-的两种典型用法" class="headerlink" title="4.1 CountDownLatch 的两种典型用法"></a>4.1 CountDownLatch 的两种典型用法</h3><ol><li>某一线程在开始运行前等待 n 个线程执行完毕。将 CountDownLatch 的计数器初始化为 n ：<code>new CountDownLatch(n)</code>，每当一个任务线程执行完毕，就将计数器减 1 <code>countdownlatch.countDown()</code>，当计数器的值变为 0 时，在<code>CountDownLatch上 await()</code> 的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。</li><li>实现多个线程开始执行任务的最大并行性。注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的 <code>CountDownLatch</code> 对象，将其计数器初始化为 1 ：<code>new CountDownLatch(1)</code>，多个线程在开始执行任务前首先 <code>coundownlatch.await()</code>，当主线程调用 countDown() 时，计数器变为 0，多个线程同时被唤醒。</li></ol><h3 id="4-2-CountDownLatch-的使用示例"><a href="#4-2-CountDownLatch-的使用示例" class="headerlink" title="4.2 CountDownLatch 的使用示例"></a>4.2 CountDownLatch 的使用示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> SnailClimb</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2018年10月1日</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: CountDownLatch 使用方法示例</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountDownLatchExample1</span> &#123;<br>  <span class="hljs-comment">// 请求的数量</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">threadCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">550</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">// 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）</span><br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">300</span>);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(threadCount);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; threadCount; i++) &#123;<br>      <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">threadnum</span> <span class="hljs-operator">=</span> i;<br>      threadPool.execute(() -&gt; &#123;<span class="hljs-comment">// Lambda 表达式的运用</span><br>        <span class="hljs-keyword">try</span> &#123;<br>          test(threadnum);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>          <span class="hljs-comment">// TODO Auto-generated catch block</span><br>          e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>          countDownLatch.countDown();<span class="hljs-comment">// 表示一个请求已经被完成</span><br>        &#125;<br><br>      &#125;);<br>    &#125;<br>    countDownLatch.await();<br>    threadPool.shutdown();<br>    System.out.println(<span class="hljs-string">&quot;finish&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> threadnum)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    Thread.sleep(<span class="hljs-number">1000</span>);<span class="hljs-comment">// 模拟请求的耗时操作</span><br>    System.out.println(<span class="hljs-string">&quot;threadnum:&quot;</span> + threadnum);<br>    Thread.sleep(<span class="hljs-number">1000</span>);<span class="hljs-comment">// 模拟请求的耗时操作</span><br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面的代码中，我们定义了请求的数量为 550，当这 550 个请求被处理完成之后，才会执行<code>System.out.println(&quot;finish&quot;);</code>。</p><p>与 CountDownLatch 的第一次交互是主线程等待其他线程。主线程必须在启动其他线程后立即调用 <code>CountDownLatch.await()</code> 方法。这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。</p><p>其他 N 个线程必须引用闭锁对象，因为他们需要通知 <code>CountDownLatch</code> 对象，他们已经完成了各自的任务。这种通知机制是通过 <code>CountDownLatch.countDown()</code>方法来完成的；每调用一次这个方法，在构造函数中初始化的 count 值就减 1。所以当 N 个线程都调 用了这个方法，count 的值等于 0，然后主线程就能通过 <code>await()</code>方法，恢复执行自己的任务。</p><p>再插一嘴：<code>CountDownLatch</code> 的  <code>await()</code> 方法使用不当很容易产生死锁，比如我们上面代码中的 for 循环改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; threadCount-<span class="hljs-number">1</span>; i++) &#123;<br>.......<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就导致  <code>count</code> 的值没办法等于 0，然后就会导致一直等待。</p><p>如果对CountDownLatch源码感兴趣的朋友，可以查看： <a href="https://www.cnblogs.com/leesf456/p/5406191.html">【JUC】JDK1.8源码分析之CountDownLatch（五）</a></p><h3 id="4-3-CountDownLatch-的不足"><a href="#4-3-CountDownLatch-的不足" class="headerlink" title="4.3 CountDownLatch 的不足"></a>4.3 CountDownLatch 的不足</h3><p>CountDownLatch 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 CountDownLatch 使用完毕后，它不能再次被使用。</p><h3 id="4-4-CountDownLatch-相常见面试题"><a href="#4-4-CountDownLatch-相常见面试题" class="headerlink" title="4.4 CountDownLatch 相常见面试题"></a>4.4 CountDownLatch 相常见面试题</h3><p>解释一下 CountDownLatch 概念？</p><p>CountDownLatch 和 CyclicBarrier 的不同之处？</p><p>给出一些 CountDownLatch 使用的例子？</p><p>CountDownLatch 类中主要的方法？</p><h2 id="5-CyclicBarrier-循环栅栏"><a href="#5-CyclicBarrier-循环栅栏" class="headerlink" title="5 CyclicBarrier(循环栅栏)"></a>5 CyclicBarrier(循环栅栏)</h2><p>CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。</p><blockquote><p>CountDownLatch的实现是基于AQS的，而CycliBarrier是基于 ReentrantLock(ReentrantLock也属于AQS同步器)和 Condition 的.</p></blockquote><p>CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier 默认的构造方法是 <code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用<code>await</code>方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</p><p>再来看一下它的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">CyclicBarrier</span><span class="hljs-params">(<span class="hljs-type">int</span> parties)</span> &#123;<br>    <span class="hljs-built_in">this</span>(parties, <span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CyclicBarrier</span><span class="hljs-params">(<span class="hljs-type">int</span> parties, Runnable barrierAction)</span> &#123;<br>    <span class="hljs-keyword">if</span> (parties &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-built_in">this</span>.parties = parties;<br>    <span class="hljs-built_in">this</span>.count = parties;<br>    <span class="hljs-built_in">this</span>.barrierCommand = barrierAction;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，parties 就代表了有拦截的线程的数量，当拦截的线程数量达到这个值的时候就打开栅栏，让所有线程通过。</p><h3 id="5-1-CyclicBarrier-的应用场景"><a href="#5-1-CyclicBarrier-的应用场景" class="headerlink" title="5.1 CyclicBarrier 的应用场景"></a>5.1 CyclicBarrier 的应用场景</h3><p>CyclicBarrier 可以用于多线程计算数据，最后合并计算结果的应用场景。比如我们用一个 Excel 保存了用户所有银行流水，每个 Sheet 保存一个帐户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个 sheet 里的银行流水，都执行完之后，得到每个 sheet 的日均银行流水，最后，再用 barrierAction 用这些线程的计算结果，计算出整个 Excel 的日均银行流水。</p><h3 id="5-2-CyclicBarrier-的使用示例"><a href="#5-2-CyclicBarrier-的使用示例" class="headerlink" title="5.2 CyclicBarrier 的使用示例"></a>5.2 CyclicBarrier 的使用示例</h3><p>示例 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Snailclimb</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2018年10月1日</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: 测试 CyclicBarrier 类中带参数的 await() 方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CyclicBarrierExample2</span> &#123;<br>  <span class="hljs-comment">// 请求的数量</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">threadCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">550</span>;<br>  <span class="hljs-comment">// 需要同步的线程数量</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">cyclicBarrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">5</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">// 创建线程池</span><br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; threadCount; i++) &#123;<br>      <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">threadNum</span> <span class="hljs-operator">=</span> i;<br>      Thread.sleep(<span class="hljs-number">1000</span>);<br>      threadPool.execute(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          test(threadNum);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>          <span class="hljs-comment">// TODO Auto-generated catch block</span><br>          e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (BrokenBarrierException e) &#123;<br>          <span class="hljs-comment">// TODO Auto-generated catch block</span><br>          e.printStackTrace();<br>        &#125;<br>      &#125;);<br>    &#125;<br>    threadPool.shutdown();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> threadnum)</span> <span class="hljs-keyword">throws</span> InterruptedException, BrokenBarrierException &#123;<br>    System.out.println(<span class="hljs-string">&quot;threadnum:&quot;</span> + threadnum + <span class="hljs-string">&quot;is ready&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">/**等待60秒，保证子线程完全执行结束*/</span><br>      cyclicBarrier.await(<span class="hljs-number">60</span>, TimeUnit.SECONDS);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>      System.out.println(<span class="hljs-string">&quot;-----CyclicBarrierException------&quot;</span>);<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;threadnum:&quot;</span> + threadnum + <span class="hljs-string">&quot;is finish&quot;</span>);<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到当线程数量也就是请求数量达到我们定义的 5 个的时候， <code>await</code>方法之后的方法才被执行。</p><p>另外，CyclicBarrier 还提供一个更高级的构造函数<code>CyclicBarrier(int parties, Runnable barrierAction)</code>，用于在线程到达屏障时，优先执行<code>barrierAction</code>，方便处理更复杂的业务场景。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> SnailClimb</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2018年10月1日</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: 新建 CyclicBarrier 的时候指定一个 Runnable</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CyclicBarrierExample3</span> &#123;<br>  <span class="hljs-comment">// 请求的数量</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">threadCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">550</span>;<br>  <span class="hljs-comment">// 需要同步的线程数量</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">cyclicBarrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">5</span>, () -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;------当线程数达到之后，优先执行------&quot;</span>);<br>  &#125;);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">// 创建线程池</span><br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; threadCount; i++) &#123;<br>      <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">threadNum</span> <span class="hljs-operator">=</span> i;<br>      Thread.sleep(<span class="hljs-number">1000</span>);<br>      threadPool.execute(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          test(threadNum);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>          <span class="hljs-comment">// TODO Auto-generated catch block</span><br>          e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (BrokenBarrierException e) &#123;<br>          <span class="hljs-comment">// TODO Auto-generated catch block</span><br>          e.printStackTrace();<br>        &#125;<br>      &#125;);<br>    &#125;<br>    threadPool.shutdown();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> threadnum)</span> <span class="hljs-keyword">throws</span> InterruptedException, BrokenBarrierException &#123;<br>    System.out.println(<span class="hljs-string">&quot;threadnum:&quot;</span> + threadnum + <span class="hljs-string">&quot;is ready&quot;</span>);<br>    cyclicBarrier.await();<br>    System.out.println(<span class="hljs-string">&quot;threadnum:&quot;</span> + threadnum + <span class="hljs-string">&quot;is finish&quot;</span>);<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-3-CyclicBarrier源码分析"><a href="#5-3-CyclicBarrier源码分析" class="headerlink" title="5.3 CyclicBarrier源码分析"></a>5.3 <code>CyclicBarrier</code>源码分析</h4><p>当调用 <code>CyclicBarrier</code> 对象调用 <code>await()</code> 方法时，实际上调用的是<code>dowait(false, 0L)</code>方法。 <code>await()</code> 方法就像树立起一个栅栏的行为一样，将线程挡住了，当拦住的线程数量达到 parties 的值时，栅栏才会打开，线程才得以通过执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, BrokenBarrierException &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> dowait(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (TimeoutException toe) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(toe); <span class="hljs-comment">// cannot happen</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>dowait(false, 0L)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 当线程数量或者请求数量达到 count 时 await 之后的方法才会被执行。上面的示例中 count 的值就为 5。</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Main barrier code, covering the various policies.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dowait</span><span class="hljs-params">(<span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException, BrokenBarrierException,<br>           TimeoutException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    <span class="hljs-comment">// 锁住</span><br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Generation</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> generation;<br><br>        <span class="hljs-keyword">if</span> (g.broken)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BrokenBarrierException</span>();<br><br>        <span class="hljs-comment">// 如果线程中断了，抛出异常</span><br>        <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;<br>            breakBarrier();<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        &#125;<br>        <span class="hljs-comment">// cout减1</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> --count;<br>        <span class="hljs-comment">// 当 count 数量减为 0 之后说明最后一个线程已经到达栅栏了，也就是达到了可以执行await 方法之后的条件</span><br>        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// tripped</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">ranAction</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Runnable</span> <span class="hljs-variable">command</span> <span class="hljs-operator">=</span> barrierCommand;<br>                <span class="hljs-keyword">if</span> (command != <span class="hljs-literal">null</span>)<br>                    command.run();<br>                ranAction = <span class="hljs-literal">true</span>;<br>                <span class="hljs-comment">// 将 count 重置为 parties 属性的初始化值</span><br>                <span class="hljs-comment">// 唤醒之前等待的线程</span><br>                <span class="hljs-comment">// 下一波执行开始</span><br>                nextGeneration();<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span> (!ranAction)<br>                    breakBarrier();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// loop until tripped, broken, interrupted, or timed out</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (!timed)<br>                    trip.await();<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nanos &gt; <span class="hljs-number">0L</span>)<br>                    nanos = trip.awaitNanos(nanos);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;<br>                <span class="hljs-keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;<br>                    breakBarrier();<br>                    <span class="hljs-keyword">throw</span> ie;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// We&#x27;re about to finish waiting even if we had not</span><br>                    <span class="hljs-comment">// been interrupted, so this interrupt is deemed to</span><br>                    <span class="hljs-comment">// &quot;belong&quot; to subsequent execution.</span><br>                    Thread.currentThread().interrupt();<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (g.broken)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BrokenBarrierException</span>();<br><br>            <span class="hljs-keyword">if</span> (g != generation)<br>                <span class="hljs-keyword">return</span> index;<br><br>            <span class="hljs-keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="hljs-number">0L</span>) &#123;<br>                breakBarrier();<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>();<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>总结：<code>CyclicBarrier</code> 内部通过一个 count 变量作为计数器，cout 的初始值为 parties 属性的初始化值，每当一个线程到了栅栏这里了，那么就将计数器减一。如果 count 值为 0 了，表示这是这一代最后一个线程到达栅栏，就尝试执行我们构造方法中输入的任务。</p><h3 id="5-4-CyclicBarrier-和-CountDownLatch-的区别"><a href="#5-4-CyclicBarrier-和-CountDownLatch-的区别" class="headerlink" title="5.4 CyclicBarrier 和 CountDownLatch 的区别"></a>5.4 CyclicBarrier 和 CountDownLatch 的区别</h3><p><strong>下面这个是国外一个大佬的回答：</strong></p><p>CountDownLatch 是计数器，只能使用一次，而 CyclicBarrier 的计数器提供 reset 功能，可以多次使用。但是我不那么认为它们之间的区别仅仅就是这么简单的一点。我们来从 jdk 作者设计的目的来看，javadoc 是这么描述它们的：</p><blockquote><p>CountDownLatch: A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.(CountDownLatch: 一个或者多个线程，等待其他多个线程完成某件事情之后才能执行；)<br>CyclicBarrier : A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point.(CyclicBarrier : 多个线程互相等待，直到到达同一个同步点，再继续一起执行。)</p></blockquote><p>对于 CountDownLatch 来说，重点是“一个线程（多个线程）等待”，而其他的 N 个线程在完成“某件事情”之后，可以终止，也可以等待。而对于 CyclicBarrier，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。</p><p>CountDownLatch 是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而 CyclicBarrier 更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。</p><h2 id="6-ReentrantReadWriteLock-使用场景"><a href="#6-ReentrantReadWriteLock-使用场景" class="headerlink" title="6 ReentrantReadWriteLock 使用场景"></a>6 ReentrantReadWriteLock 使用场景</h2><p>读多, 写少的情况下<br>读操作的并发性:<br>    只有没有写操作, 多个线程同时进行读取数据, 在读多写少的场景下面可以显著提高读取的性能<br>写操作的独占性:<br>    写操作是独占的, 当一个线程在运行的时候, 其他所有的读取和写都会被阻塞, 直到写操作完成。这样可以保证数据的一致性, 防止读线程读取到错误不完整的数据。<br>使用场景:<br>    读多写少的场景, 例如: 缓存, 配置读取<br>读锁为共享锁，写锁为排他锁<br>如何保证安全性:<br>    读锁: 在进行更新数据的时候, 只有所有读锁都释放了以后, 写锁才可以被获取到<br>    写锁: 写锁获取时, 会检查是否有读锁的存在, 如果有读锁的存在, 写锁会被阻塞, 直到所有的读锁都被释放, 一旦有线程拿到写锁, 会阻止任何新的读锁和其他写锁的获取</p><p>锁的使用场景:<br>    读写锁:<br>        读多写少的, 高并发的情况下可以提高读取的效率<br>    客观锁:<br>        通过版本号机制, 适用于冲突较少, 并发较低的情况下<br>    synchronized:<br>        简单的并发控制, 例如在方法上或者对象上控制并发<br>    ReentrantLock:<br>        可以手动的管理锁的粒度, 可中断锁, 可对锁进行超时处理</p>]]></content>
    
    
    <categories>
      
      <category>jdk</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>synchronized</title>
    <link href="/2022/12/12/jdk/synchronize/"/>
    <url>/2022/12/12/jdk/synchronize/</url>
    
    <content type="html"><![CDATA[<p><img src="/../../img/jdk/synchronized%E5%AF%B9%E6%AF%94.png" alt="Synchronized 关键字使用、底层原理、JDK1.6 之后的底层优化以及 和ReenTrantLock 的对比"></p><h1 id="synchronized-使用方式"><a href="#synchronized-使用方式" class="headerlink" title="synchronized 使用方式"></a>synchronized 使用方式</h1><h2 id="修饰实例方法"><a href="#修饰实例方法" class="headerlink" title="修饰实例方法"></a>修饰实例方法</h2><ul><li><strong>修饰实例方法，作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁</strong></li></ul><h2 id="修饰静态方法"><a href="#修饰静态方法" class="headerlink" title="修饰静态方法"></a>修饰静态方法</h2><ul><li><strong>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁</strong> 也就是给当前类加锁，会作用于类的所有对象实例; 所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，<strong>因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁</strong>。</li></ul><h2 id="修饰代码快"><a href="#修饰代码快" class="headerlink" title="修饰代码快"></a>修饰代码快</h2><ul><li><strong>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码块前要获得给定对象的锁。</strong> 和 synchronized 方法一样，synchronized(this)代码块也是锁定当前对象的。synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。这里再提一下：synchronized关键字加到非 static 静态方法上是给对象实例上锁。另外需要注意的是：尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓冲功能！</li></ul><h2 id="场景case-单例"><a href="#场景case-单例" class="headerlink" title="场景case 单例"></a>场景case 单例</h2><p>下面我已一个常见的面试题为例讲解一下 synchronized 关键字的具体使用。<br>面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”</p><p><strong>双重校验锁实现对象单例（线程安全）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getUniqueInstance</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span><br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//类对象加锁</span><br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>                    uniqueInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。<br>static 保证了对象只有一个实例, 同时可以确保全局访问唯一, 同时提供了静态访问方式, 让外部对象直接通过类名访问<br>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance &#x3D; new Singleton(); 这段代码其实是分为三步执行：</p><ol><li>为 uniqueInstance 分配内存空间</li><li>初始化 uniqueInstance</li><li>将 uniqueInstance 指向分配的内存地址</li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。<br>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p><h1 id="synchronized-底层总结"><a href="#synchronized-底层总结" class="headerlink" title="synchronized 底层总结"></a>synchronized 底层总结</h1><h2 id="synchronized-修饰对象"><a href="#synchronized-修饰对象" class="headerlink" title="synchronized 修饰对象"></a>synchronized 修饰对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedDemo</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>System.out.println(<span class="hljs-string">&quot;synchronized 代码块&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>通过 JDK 自带的 javap 命令查看 SynchronizedDemo 类的相关字节码信息：首先切换到类的对应目录执行 <code>javac SynchronizedDemo.java</code> 命令生成编译后的 .class 文件，然后执行<code>javap -c -s -v -l SynchronizedDemo.class</code>。<br>从上面我们可以看出：<br><strong>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</strong> 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权.当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p><h2 id="synchronized-修饰方法"><a href="#synchronized-修饰方法" class="headerlink" title="synchronized 修饰方法"></a>synchronized 修饰方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedDemo2</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;synchronized 方法&quot;</span>);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法</strong><br>在 Java 早期版本中，synchronized 属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p><h1 id="1-6-以后的优化"><a href="#1-6-以后的优化" class="headerlink" title="1.6 以后的优化"></a>1.6 以后的优化</h1><h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h2><p>JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、锁消除、锁粗化等技术来减少锁操作的开销。<br>锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p><h3 id="无锁状态"><a href="#无锁状态" class="headerlink" title="无锁状态"></a>无锁状态</h3><p>无锁其实就是不使用 synchronized 关键字，无锁的锁标志位为 01。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p><strong>① 偏向锁</strong><br><strong>其实在大多数实际应用运行过程中，锁不存在多线程竞争的，而是总被同一个线程持有，很少发生竞争。这样的话就会带来多次非必要的获取释放锁过程，从而带来非必要的性能开销。所以引入了偏向锁是为了解决只有一个线程执行同步代码时提高性能</strong>。<br>上锁过程:<br>当一个线程进入被 synchronized 关键字修饰的同步代码后，JVM 会使用 CAS 操作把当前线程 ID 记录到作为锁的对象的 Mark Word 中占用 54 bit 的 ThreadID 字段中，同时会修改偏向锁位置为 1，表示当前线程获得该锁。此时的锁对象由无锁状态变为偏向锁状态。<br>在当前线程再次访问该同步代码时，JVM 通过锁对象的对象头的 Mark Word 判断 ThreadID 字段是否与当前线程 ID 一致，一致则说明当前线程还持有该锁对象，可以直接进入同步代码（偏向锁不会在线程执行完同步代码后就释放，也就是线程不会主动释放偏向锁）。<br>可以看到通过这种方式无需切换 CPU 状态，也就是不用操作系统接入。偏向锁其实就是在没有其他线程的竞争下，一直偏向于同一线程，该线程可以一直访问同步代码，而无需重复加锁。所以使用偏向锁几乎没有额外的开销，性能极高。<br>解锁过程:<br>偏向锁的释放时机在：只有当其他线程竞争该锁时，持有偏向锁的线程才会被撤销，释放该偏向锁。并且撤销需要等待全局安全点，也就是该时间点没有字节码正在执行。<br>同时根据当前持有偏向锁的线程是否执行完同步代码分为两种撤销情况：<br>情况一：线程 A 正在执行同步代码（还没有执行完同步代码）。此时线程 B 抢占该锁，该偏向锁会被撤销并出现锁升级成轻量级锁，此时该轻量级锁由原持有偏向锁的线程 A 持有，继续执行其同步代码，而正在竞争的线程 B 会进入自旋等待获得该轻量级锁。<br>情况二：线程 A 执行完同步代码（已经退出同步代码）。此时线程 B 抢占该锁，该偏向锁会被撤销并将 ThreadID 置空以及偏向锁位置 0，根据线程 A 是否再次竞争分为：<br>如果线程 A 不再继续竞争，那么会将偏向锁重新偏向线程 B，即线程 B 持有该偏向锁；<br>如果线程 A 继续竞争，那么会将锁升级到了轻量级锁，通过 CAS 自旋抢占锁；</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)。<strong>轻量级锁不是为了代替重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。另外，轻量级锁的加锁和解锁都用到了CAS操作。</strong> 关于轻量级锁的加锁和解锁的原理可以查看《深入理解Java虚拟机：JVM高级特性与最佳实践》第二版的13章第三节锁优化。</p><p><strong>轻量级锁能够提升程序同步性能的依据是“对于绝大部分锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥操作的开销。但如果存在锁竞争，除了互斥量开销外，还会额外发生CAS操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁！</strong><br>当线程 A 与 线程 B 同时抢占锁对象时，偏向锁会被撤销并将锁升级为轻量级锁，这个升级过程如下：<br>线程 A 在执行同步代码前，JVM 在线程的栈帧中创建用于存储锁记录的空间 Lock Record。当线程 A 抢占锁对象时，JVM 使用 CAS 操作将锁对象的对象头的 Mark Word 拷贝进线程 A 的锁记录 Lock Record 中，并且将 Mark Word 中指向线程栈中 Lock Record 的指针指向线程 A 的锁空间。<br>如果更新成功，则线程 A 持有该对象锁，并将对象锁的 Mark Word 的锁标志位更新为 00。即此时线程 A 持有轻量级锁会执行同步代码，而线程 B 会自旋等待获取该轻量级锁；如果更新失败，则说明该锁被线程 B 抢占。</p><p>轻量级锁撤销的两种情况：<br>当有两个以上的线程同时竞争一个锁时，那么轻量级锁会被撤销并升级为重量级锁，不再通过自旋的方式等待获取锁而是直接阻塞线程；<br>当持有轻量级锁的线程执行完同步代码时，同样会释放轻量级锁，会使用 CAS 操作将锁对象的 Mark Word 中指针指向的锁记录 Lock Record 重新替换回锁对象的 Mark Word。</p><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>当存在两个以上的线程竞争同一把锁或线程竞争轻量级锁自旋多次仍然失败时，会导致锁升级为重量级锁。重量级锁会直接阻塞持有锁的线程以外的所有线程，防止 CPU 空转，减小 CPU 的开销。<br>通过将锁对象的 Mark Word 的锁标志位更新为 10，从而将锁升级为重量级锁。此时可以看到 Mark Word 中有一个指向互斥量的指针，这个指针其实指向的就是 Monitor 对象的起始地址，通过 Monitor 对象即可实现互斥访问同步代码，也就是通过阻塞唤醒的方式实现同步。</p><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><h3 id="自旋锁和自适应性锁"><a href="#自旋锁和自适应性锁" class="headerlink" title="自旋锁和自适应性锁"></a>自旋锁和自适应性锁</h3><p>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。<br>互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程&#x2F;恢复线程的操作都需要转入内核态中完成（用户态转换到内核态会耗费时间）。<br><strong>一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程&#x2F;恢复线程是得不偿失的。</strong> 所以，虚拟机的开发团队就这样去考虑：“我们能不能让后面来的请求获取锁的线程等待一会而不被挂起呢？看看持有锁的线程是否很快就会释放锁”。<strong>为了让一个线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就叫做自旋</strong>。</p><p>百度百科对自旋锁的解释：</p><blockquote><p>何谓自旋锁？它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。</p></blockquote><p>自旋锁在 JDK1.6 之前其实就已经引入了，不过是默认关闭的，需要通过<code>--XX:+UseSpinning</code>参数来开启。JDK1.6及1.6之后，就改为默认开启的了。需要注意的是：自旋等待不能完全替代阻塞，因为它还是要占用处理器时间。如果锁被占用的时间短，那么效果当然就很好了！反之，相反！自旋等待的时间必须要有限度。如果自旋超过了限定次数任然没有获得锁，就应该挂起线程。<strong>自旋次数的默认值是10次，用户可以修改<code>--XX:PreBlockSpin</code>来更改</strong>。</p><p>另外,<strong>在 JDK1.6 中引入了自适应的自旋锁。自适应的自旋锁带来的改进就是：自旋的时间不在固定了，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定，虚拟机变得越来越“聪明”了</strong>。</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除理解起来很简单，它指的就是虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省毫无意义的请求锁的时间。</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，——直在共享数据的实际作用域才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待线程也能尽快拿到锁。<br>大部分情况下，上面的原则都是没有问题的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，那么会带来很多不必要的性能消耗。</p><h1 id="synchronized和ReenTrantLock-的对比"><a href="#synchronized和ReenTrantLock-的对比" class="headerlink" title="synchronized和ReenTrantLock 的对比"></a>synchronized和ReenTrantLock 的对比</h1><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p><h2 id="依赖属性"><a href="#依赖属性" class="headerlink" title="依赖属性"></a>依赖属性</h2><p>synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReenTrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock 方法配合 try&#x2F;finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p><h2 id="功能对比"><a href="#功能对比" class="headerlink" title="功能对比"></a>功能对比</h2><h3 id="等待可中断"><a href="#等待可中断" class="headerlink" title="等待可中断"></a>等待可中断</h3><ul><li><strong>ReenTrantLock提供了一种能够中断等待锁的线程的机制</strong>，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li></ul><h3 id="可实现公平锁"><a href="#可实现公平锁" class="headerlink" title="可实现公平锁"></a>可实现公平锁</h3><ul><li><strong>ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</strong> ReenTrantLock默认情况是非公平的，可以通过 ReenTrantLock类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li></ul><h3 id="可实现选择性通知"><a href="#可实现选择性通知" class="headerlink" title="可实现选择性通知"></a>可实现选择性通知</h3><ul><li>synchronized关键字与wait()和notify&#x2F;notifyAll()方法相结合可以实现等待&#x2F;通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），<strong>线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify&#x2F;notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。<br>如果你想使用上述功能，那么选择ReenTrantLock是一个不错的选择。</li></ul><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>在JDK1.6之前，synchronized 的性能是比 ReenTrantLock 差很多。具体表示为：synchronized 关键字吞吐量随线程数的增加，下降得非常严重。而ReenTrantLock 基本保持一个比较稳定的水平。我觉得这也侧面反映了， synchronized 关键字还有非常大的优化余地。后续的技术发展也证明了这一点，我们上面也讲了在 JDK1.6 之后 JVM 团队对 synchronized 关键字做了很多优化。<strong>JDK1.6 之后，synchronized 和 ReenTrantLock 的性能基本是持平了。所以网上那些说因为性能才选择 ReenTrantLock 的文章都是错的！JDK1.6之后，性能已经不是选择synchronized和ReenTrantLock的影响因素了！而且虚拟机在未来的性能改进中会更偏向于原生的synchronized，所以还是提倡在synchronized能满足你的需求的情况下，优先考虑使用synchronized关键字来进行同步！优化后的synchronized和ReenTrantLock一样，在很多地方都是用到了CAS操作</strong>。</p><h2 id="ReentrantLock-和-ReentrantReadWriteLock"><a href="#ReentrantLock-和-ReentrantReadWriteLock" class="headerlink" title="ReentrantLock 和 ReentrantReadWriteLock"></a>ReentrantLock 和 ReentrantReadWriteLock</h2><p>ReentrantLock 和 synchronized 的区别在上面已经讲过了这里就不多做讲解。另外，需要注意的是：读写锁 ReentrantReadWriteLock 可以保证多个线程可以同时读，所以在读操作远大于写操作的时候，读写锁就非常有用了。</p><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>因此，在Java中可以使用synchronized来保证方法和代码块内的操作是原子性的。<br>在CPU和主存之间增加缓存，在多线程场景下就可能存在缓存一致性问题，也就是说，在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致。</p><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。<br>Java中的volatile关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用volatile来保证多线程操作时变量的可见性。<br>除了volatile，Java中的synchronized和final两个关键字也可以实现可见性。只不过实现方式不同，这里不再展开了。</p><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>在Java中，可以使用synchronized和volatile来保证多线程之间操作的有序性。实现方式有所区别：<br>volatile关键字会禁止指令重排。synchronized关键字保证同一时刻只允许一条线程操作。<br>好了，这里简单的介绍完了Java并发编程中解决原子性、可见性以及有序性可以使用的关键字。读者可能发现了，好像synchronized关键字是万能的，他可以同时满足以上三种特性，这其实也是很多人滥用synchronized的原因。<br>但是synchronized是比较影响性能的，虽然编译器提供了很多锁优化技术，但是也不建议过度使用。</p>]]></content>
    
    
    <categories>
      
      <category>jdk</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>所有常见问题</title>
    <link href="/2022/12/11/interview/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2022/12/11/interview/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E4%B8%80-%E5%9F%BA%E7%A1%80%E7%AF%87">一 基础篇</a><ul><li><a href="#1-systemoutprintln39%E8%BE%93%E5%87%BA%E4%BB%80%E4%B9%88">1. <code>System.out.println(3|9)</code>输出什么?</a></li><li><a href="#2-%E8%AF%B4%E4%B8%80%E4%B8%8B%E8%BD%AC%E5%8F%91forward%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91redirect%E7%9A%84%E5%8C%BA%E5%88%AB">2. 说一下转发(Forward)和重定向(Redirect)的区别</a></li><li><a href="#3-%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5-url-%E5%9C%B0%E5%9D%80%E5%88%B0%E6%98%BE%E7%A4%BA%E4%B8%BB%E9%A1%B5%E7%9A%84%E8%BF%87%E7%A8%8B%E6%95%B4%E4%B8%AA%E8%BF%87%E7%A8%8B%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%93%AA%E4%BA%9B%E5%8D%8F%E8%AE%AE">3. 在浏览器中输入 url 地址到显示主页的过程,整个过程会使用哪些协议</a></li><li><a href="#4-tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">4. TCP 三次握手和四次挥手</a><br>  - <a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">为什么要三次握手</a><br>  - <a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BC%A0%E5%9B%9E-syn">为什么要传回 SYN</a><br>  - <a href="#%E4%BC%A0%E4%BA%86-syn%E4%B8%BA%E5%95%A5%E8%BF%98%E8%A6%81%E4%BC%A0-ack">传了 SYN,为啥还要传 ACK</a><br>  - <a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">为什么要四次挥手</a></li><li><a href="#5-ip-%E5%9C%B0%E5%9D%80%E4%B8%8E-mac-%E5%9C%B0%E5%9D%80%E7%9A%84%E5%8C%BA%E5%88%AB">5. IP 地址与 MAC 地址的区别</a></li><li><a href="#6-http-%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F">6. HTTP 请求,响应报文格式</a></li><li><a href="#7-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%B4%A2%E5%BC%95%E8%BF%99%E4%B9%88%E5%A4%9A%E4%BC%98%E7%82%B9%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%AF%B9%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%88%97%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%B4%A2%E5%BC%95%E5%91%A2%E7%B4%A2%E5%BC%95%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%9F%A5%E8%AF%A2%E9%80%9F%E5%BA%A6%E7%9A%84%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9mysql-%E7%B4%A2%E5%BC%95%E4%B8%BB%E8%A6%81%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%80%E4%B9%88%E6%98%AF%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95">7. 为什么要使用索引?索引这么多优点,为什么不对表中的每一个列创建一个索引呢?索引是如何提高查询速度的?说一下使用索引的注意事项?Mysql 索引主要使用的两种数据结构?什么是覆盖索引?</a></li><li><a href="#8-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E5%87%A0%E7%A7%8D%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E8%AF%B4%E4%B8%80%E4%B8%8B%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E5%87%A0%E7%A7%8D%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E7%9F%A5%E9%81%93%E4%B8%8D">8. 进程与线程的区别是什么?进程间的几种通信方式说一下?线程间的几种通信方式知道不?</a></li><li><a href="#9-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%89%8B%E5%86%99%E5%87%A0%E7%A7%8D%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">9. 为什么要用单例模式?手写几种线程安全的单例模式?</a></li><li><a href="#10-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-bean%E7%9F%A5%E9%81%93-spring-%E7%9A%84-bean-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%90%97">10. 简单介绍一下 bean;知道 Spring 的 bean 的作用域与生命周期吗?</a></li><li><a href="#11-spring-%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%E4%BA%86%E8%A7%A3%E5%90%97transactiondefinition-%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%93%AA%E4%BA%94%E4%B8%AA%E8%A1%A8%E7%A4%BA%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%B8%B8%E9%87%8F">11. Spring 中的事务传播行为了解吗?TransactionDefinition 接口中哪五个表示隔离级别的常量?</a><br>  - <a href="#%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA">事务传播行为</a><br>  - <a href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">隔离级别</a></li><li><a href="#12-springmvc-%E5%8E%9F%E7%90%86%E4%BA%86%E8%A7%A3%E5%90%97">12. SpringMVC 原理了解吗?</a></li><li><a href="#13-spring-aop-ioc-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">13. Spring AOP IOC 实现原理</a></li></ul></li><li><a href="#%E4%BA%8C-%E8%BF%9B%E9%98%B6%E7%AF%87">二 进阶篇</a><ul><li><a href="#1-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-mq-%E7%9A%84%E5%A5%97%E8%B7%AF">1 消息队列 MQ 的套路</a><ul><li><a href="#11-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-mq-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%A5%BD%E5%A4%84">1.1 介绍一下消息队列 MQ 的应用场景&#x2F;使用消息队列的好处</a><ul><li><a href="#1%E9%80%9A%E8%BF%87%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E6%8F%90%E9%AB%98%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD">1)通过异步处理提高系统性能</a></li><li><a href="#2%E9%99%8D%E4%BD%8E%E7%B3%BB%E7%BB%9F%E8%80%A6%E5%90%88%E6%80%A7">2)降低系统耦合性</a></li></ul></li><li><a href="#12-%E9%82%A3%E4%B9%88%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BC%9A%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E8%80%83%E8%99%91%E8%BF%87%E8%BF%99%E4%BA%9B%E9%97%AE%E9%A2%98%E5%90%97">1.2 那么使用消息队列会带来什么问题?考虑过这些问题吗?</a></li><li><a href="#13-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E5%87%A0%E7%A7%8D%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%AF%A5%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%91%A2">1.3 介绍一下你知道哪几种消息队列,该如何选择呢?</a></li><li><a href="#14-%E5%85%B3%E4%BA%8E%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%85%B6%E4%BB%96%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98%E5%B1%95%E6%9C%9B">1.4 关于消息队列其他一些常见的问题展望</a></li></ul></li><li><a href="#2-%E8%B0%88%E8%B0%88-innodb-%E5%92%8C-myisam-%E4%B8%A4%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB">2 谈谈 InnoDB 和 MyIsam 两者的区别</a><ul><li><a href="#21-%E4%B8%A4%E8%80%85%E7%9A%84%E5%AF%B9%E6%AF%94">2.1 两者的对比</a></li><li><a href="#22-%E5%85%B3%E4%BA%8E%E4%B8%A4%E8%80%85%E7%9A%84%E6%80%BB%E7%BB%93">2.2 关于两者的总结</a></li></ul></li><li><a href="#3-%E8%81%8A%E8%81%8A-java-%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88%E5%90%A7">3 聊聊 Java 中的集合吧!</a><ul><li><a href="#31-arraylist-%E4%B8%8E-linkedlist-%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%E6%B3%A8%E6%84%8F%E5%8A%A0%E4%B8%8A%E4%BB%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90%E7%9A%84%E5%86%85%E5%AE%B9">3.1 Arraylist 与 LinkedList 有什么不同?(注意加上从数据结构分析的内容)</a></li><li><a href="#32-hashmap-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0">3.2 HashMap 的底层实现</a><ul><li><a href="#1jdk18-%E4%B9%8B%E5%89%8D">1)JDK1.8 之前</a></li><li><a href="#2jdk18-%E4%B9%8B%E5%90%8E">2)JDK1.8 之后</a></li></ul></li><li><a href="#33-%E6%97%A2%E7%84%B6%E8%B0%88%E5%88%B0%E4%BA%86%E7%BA%A2%E9%BB%91%E6%A0%91%E4%BD%A0%E7%BB%99%E6%88%91%E6%89%8B%E7%BB%98%E4%B8%80%E4%B8%AA%E5%87%BA%E6%9D%A5%E5%90%A7%E7%84%B6%E5%90%8E%E7%AE%80%E5%8D%95%E8%AE%B2%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E5%AF%B9%E4%BA%8E%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E7%90%86%E8%A7%A3">3.3 既然谈到了红黑树,你给我手绘一个出来吧,然后简单讲一下自己对于红黑树的理解</a></li><li><a href="#34-%E7%BA%A2%E9%BB%91%E6%A0%91%E8%BF%99%E4%B9%88%E4%BC%98%E7%A7%80%E4%B8%BA%E4%BD%95%E4%B8%8D%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E5%BE%97%E4%BA%86">3.4 红黑树这么优秀,为何不直接使用红黑树得了?</a></li><li><a href="#35-hashmap-%E5%92%8C-hashtable-%E7%9A%84%E5%8C%BA%E5%88%ABhashset-%E5%92%8C-hashmap-%E5%8C%BA%E5%88%AB">3.5 HashMap 和 Hashtable 的区别&#x2F;HashSet 和 HashMap 区别</a></li></ul></li></ul></li><li><a href="#%E4%B8%89-%E7%BB%88%E7%BB%93%E7%AF%87">三 终结篇</a><ul><li><a href="#1-object-%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95">1. Object 类有哪些方法?</a><ul><li><a href="#11-object-%E7%B1%BB%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93">1.1 Object 类的常见方法总结</a></li><li><a href="#12-hashcode-%E4%B8%8E-equals">1.2 hashCode 与 equals</a><ul><li><a href="#121-hashcode%E4%BB%8B%E7%BB%8D">1.2.1 hashCode()介绍</a></li><li><a href="#122-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89-hashcode">1.2.2 为什么要有 hashCode</a></li><li><a href="#123-hashcode%E4%B8%8E-equals%E7%9A%84%E7%9B%B8%E5%85%B3%E8%A7%84%E5%AE%9A">1.2.3 hashCode()与 equals()的相关规定</a></li><li><a href="#124-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84-hashcode-%E5%80%BC%E5%AE%83%E4%BB%AC%E4%B9%9F%E4%B8%8D%E4%B8%80%E5%AE%9A%E6%98%AF%E7%9B%B8%E7%AD%89%E7%9A%84">1.2.4 为什么两个对象有相同的 hashcode 值,它们也不一定是相等的?</a></li></ul></li><li><a href="#13-%E4%B8%8E-equals">1.3 &#x3D;&#x3D;与 equals</a></li></ul></li><li><a href="#2-concurrenthashmap-%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98">2 ConcurrentHashMap 相关问题</a><ul><li><a href="#21-concurrenthashmap-%E5%92%8C-hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB">2.1 ConcurrentHashMap 和 Hashtable 的区别</a></li><li><a href="#22-concurrenthashmap-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%BA%95%E5%B1%82%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0">2.2 ConcurrentHashMap 线程安全的具体实现方式&#x2F;底层具体实现</a><ul><li><a href="#jdk17%E4%B8%8A%E9%9D%A2%E6%9C%89%E7%A4%BA%E6%84%8F%E5%9B%BE">JDK1.7(上面有示意图)</a></li><li><a href="#jdk18%E4%B8%8A%E9%9D%A2%E6%9C%89%E7%A4%BA%E6%84%8F%E5%9B%BE">JDK1.8(上面有示意图)</a></li></ul></li></ul></li><li><a href="#3-%E8%B0%88%E8%B0%88-synchronized-%E5%92%8C-reentrantlock-%E7%9A%84%E5%8C%BA%E5%88%AB">3 谈谈 synchronized 和 ReentrantLock 的区别</a></li><li><a href="#4-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BA%86%E8%A7%A3%E5%90%97">4 线程池了解吗?</a><ul><li><a href="#41-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0">4.1 为什么要用线程池?</a></li><li><a href="#42-java-%E6%8F%90%E4%BE%9B%E4%BA%86%E5%93%AA%E5%87%A0%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%96%E4%BB%AC%E5%90%84%E8%87%AA%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88">4.2 Java 提供了哪几种线程池?他们各自的使用场景是什么?</a><ul><li><a href="#java-%E4%B8%BB%E8%A6%81%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%8B%E9%9D%A2-4-%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0">Java 主要提供了下面 4 种线程池</a></li><li><a href="#%E5%90%84%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E4%BB%8B%E7%BB%8D">各种线程池的适用场景介绍</a></li></ul></li><li><a href="#43-%E5%88%9B%E5%BB%BA%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%96%B9%E5%BC%8F">4.3 创建的线程池的方式</a></li></ul></li><li><a href="#5-nginx">5 Nginx</a><ul><li><a href="#51-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-nginx">5.1 简单介绍一下 Nginx</a><ul><li><a href="#%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86">反向代理</a></li><li><a href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">负载均衡</a></li><li><a href="#%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB">动静分离</a></li></ul></li><li><a href="#52-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-nginx">5.2 为什么要用 Nginx?</a></li><li><a href="#53-nginx-%E7%9A%84%E5%9B%9B%E4%B8%AA%E4%B8%BB%E8%A6%81%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86%E4%BA%86%E8%A7%A3%E5%90%97">5.3 Nginx 的四个主要组成部分了解吗?</a></li></ul></li></ul></li></ul><!-- /TOC --><p>这些问题是 2018 年去美团面试的同学被问到的一些常见的问题，希望对你有帮助！</p><h1 id="一-基础篇"><a href="#一-基础篇" class="headerlink" title="一 基础篇"></a>一 基础篇</h1><h2 id="1-System-out-println-3-9-输出什么"><a href="#1-System-out-println-3-9-输出什么" class="headerlink" title="1. System.out.println(3|9)输出什么?"></a>1. <code>System.out.println(3|9)</code>输出什么?</h2><p>正确答案：11。</p><p><strong>考察知识点：&amp;和&amp;&amp;；|和||</strong></p><p><strong>&amp;和&amp;&amp;：</strong></p><p>共同点：两者都可做逻辑运算符。它们都表示运算符的两边都是 true 时，结果为 true；</p><p>不同点: &amp;也是位运算符。&amp; 表示在运算时两边都会计算，然后再判断；&amp;&amp;表示先运算符号左边的东西，然后判断是否为 true，是 true 就继续运算右边的然后判断并输出，是 false 就停下来直接输出不会再运行后面的东西。</p><p><strong>|和||：</strong></p><p>共同点：两者都可做逻辑运算符。它们都表示运算符的两边任意一边为 true，结果为 true，两边都不是 true，结果就为 false；</p><p>不同点：|也是位运算符。| 表示两边都会运算，然后再判断结果；|| 表示先运算符号左边的东西，然后判断是否为 true，是 true 就停下来直接输出不会再运行后面的东西，是 false 就继续运算右边的然后判断并输出。</p><p><strong>回到本题：</strong></p><p>3 | 9&#x3D;0011（二进制） | 1001（二进制）&#x3D;1011（二进制）&#x3D;11（十进制）</p><h2 id="2-说一下转发-Forward-和重定向-Redirect-的区别"><a href="#2-说一下转发-Forward-和重定向-Redirect-的区别" class="headerlink" title="2. 说一下转发(Forward)和重定向(Redirect)的区别"></a>2. 说一下转发(Forward)和重定向(Redirect)的区别</h2><p><strong>转发是服务器行为，重定向是客户端行为。</strong></p><p><strong>转发（Forword）</strong> 通过 RequestDispatcher 对象的<code>forward（HttpServletRequest request,HttpServletResponse response）</code>方法实现的。<code>RequestDispatcher</code> 可以通过<code>HttpServletRequest</code> 的 <code>getRequestDispatcher()</code>方法获得。例如下面的代码就是跳转到 login_success.jsp 页面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">request.getRequestDispatcher(<span class="hljs-string">&quot;login_success.jsp&quot;</span>).forward(request, response);<br></code></pre></td></tr></table></figure><p><strong>重定向（Redirect）</strong> 是利用服务器返回的状态码来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过 HttpServletRequestResponse 的 setStatus(int status)方法设置状态码。如果服务器返回 301 或者 302，则浏览器会到新的网址重新请求该资源。</p><ol><li><strong>从地址栏显示来说</strong>：forward 是服务器请求资源，服务器直接访问目标地址的 URL，把那个 URL 的响应内容读取过来，然后把这些内容再发给浏览器。浏览器根本不知道服务器发送的内容从哪里来的，所以它的地址栏还是原来的地址。redirect 是服务端根据逻辑，发送一个状态码，告诉浏览器重新去请求那个地址。所以地址栏显示的是新的 URL。</li><li><strong>从数据共享来说</strong>：forward：转发页面和转发到的页面可以共享 request 里面的数据。redirect：不能共享数据。</li><li><strong>从运用地方来说</strong>：forward：一般用于用户登陆的时候，根据角色转发到相应的模块。redirect：一般用于用户注销登陆时返回主页面和跳转到其它的网站等。</li><li><strong>从效率来说</strong>：forward：高。redirect：低。</li></ol><h2 id="3-在浏览器中输入-url-地址到显示主页的过程-整个过程会使用哪些协议"><a href="#3-在浏览器中输入-url-地址到显示主页的过程-整个过程会使用哪些协议" class="headerlink" title="3. 在浏览器中输入 url 地址到显示主页的过程,整个过程会使用哪些协议"></a>3. 在浏览器中输入 url 地址到显示主页的过程,整个过程会使用哪些协议</h2><p>图片来源：《图解 HTTP》：</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/%E5%90%84%E7%A7%8D%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%94%A8%E5%88%B0%E7%9A%84%E5%8D%8F%E8%AE%AE.jpg" alt="各种网络请求用到的协议"></p><p>总体来说分为以下几个过程:</p><ol><li>DNS 解析</li><li>TCP 连接</li><li>发送 HTTP 请求</li><li>服务器处理请求并返回 HTTP 报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol><p>具体可以参考下面这篇文章：</p><ul><li><a href="https://segmentfault.com/a/1190000006879700" title="https://segmentfault.com/a/1190000006879700">https://segmentfault.com/a/1190000006879700</a></li></ul><blockquote><p>修正 <a href="https://github.com/Snailclimb/JavaGuide/issues/568" title="issue-568">issue-568</a>：上图中 IP 数据包在路由器之间使用的协议为 OPSF 协议错误，应该为 OSPF 协议 。</p><p>IP 数据包在路由器之间传播大致分为 IGP 和 BGP 协议，而 IGP 目前主流为 OSPF 协议，思科，华为和 H3C 等主流厂商都有各自实现并使用；BGP 协议为不同 AS（自治系统号）间路由传输，也分为 I-BGP 和 E-BGP，详细资料请查看《TCP&#x2F;IP 卷一》</p></blockquote><h2 id="4-TCP-三次握手和四次挥手"><a href="#4-TCP-三次握手和四次挥手" class="headerlink" title="4. TCP 三次握手和四次挥手"></a>4. TCP 三次握手和四次挥手</h2><p>为了准确无误地把数据送达目标处，TCP 协议采用了三次握手策略。</p><p><strong>漫画图解：</strong></p><p>图片来源：《图解 HTTP》<br><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/tcp三次握手.jpg" style="zoom:50%;" /></p><p><strong>简单示意图：</strong><br><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/tcp三次握手2.jpg" style="zoom:50%;" /></p><ul><li>客户端–发送带有 SYN 标志的数据包–一次握手–服务端</li><li>服务端–发送带有 SYN&#x2F;ACK 标志的数据包–二次握手–客户端</li><li>客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端</li></ul><h4 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h4><p><strong>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p><p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常。</p><p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己接收正常，对方发送正常</p><p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p><p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p><h4 id="为什么要传回-SYN"><a href="#为什么要传回-SYN" class="headerlink" title="为什么要传回 SYN"></a>为什么要传回 SYN</h4><p>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。</p><blockquote><p>SYN 是 TCP&#x2F;IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符 ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。 ]）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。</p></blockquote><h4 id="传了-SYN-为啥还要传-ACK"><a href="#传了-SYN-为啥还要传-ACK" class="headerlink" title="传了 SYN,为啥还要传 ACK"></a>传了 SYN,为啥还要传 ACK</h4><p>双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方（主动关闭方）到接收方（被动关闭方）的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。</p><p>断开一个 TCP 连接则需要“四次挥手”：</p><ul><li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li><li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加 1 。和 SYN 一样，一个 FIN 将占用一个序号</li><li>服务器-关闭与客户端的连接，发送一个 FIN 给客户端</li><li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加 1</li></ul><h4 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h4><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p><p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p><p>上面讲的比较概括，推荐一篇讲的比较细致的文章：<a href="https://blog.csdn.net/qzcsu/article/details/72861891" title="https://blog.csdn.net/qzcsu/article/details/72861891">https://blog.csdn.net/qzcsu/article/details/72861891</a></p><h2 id="5-IP-地址与-MAC-地址的区别"><a href="#5-IP-地址与-MAC-地址的区别" class="headerlink" title="5. IP 地址与 MAC 地址的区别"></a>5. IP 地址与 MAC 地址的区别</h2><p>参考：<a href="https://blog.csdn.net/guoweimelon/article/details/50858597" title="https://blog.csdn.net/guoweimelon/article/details/50858597">https://blog.csdn.net/guoweimelon/article/details/50858597</a></p><p>IP 地址是指互联网协议地址（Internet Protocol Address）IP Address 的缩写。IP 地址是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</p><p>MAC 地址又称为物理地址、硬件地址，用来定义网络设备的位置。网卡的物理地址通常是由网卡生产厂家写入网卡的，具有全球唯一性。MAC 地址用于在网络中唯一标示一个网卡，一台电脑会有一或多个网卡，每个网卡都需要有一个唯一的 MAC 地址。</p><h2 id="6-HTTP-请求-响应报文格式"><a href="#6-HTTP-请求-响应报文格式" class="headerlink" title="6. HTTP 请求,响应报文格式"></a>6. HTTP 请求,响应报文格式</h2><p>HTTP 请求报文主要由请求行、请求头部、请求正文 3 部分组成</p><p>HTTP 响应报文主要由状态行、响应头部、响应正文 3 部分组成</p><p>详细内容可以参考：<a href="https://blog.csdn.net/a19881029/article/details/14002273" title="https://blog.csdn.net/a19881029/article/details/14002273">https://blog.csdn.net/a19881029/article/details/14002273</a></p><h2 id="7-为什么要使用索引-索引这么多优点-为什么不对表中的每一个列创建一个索引呢-索引是如何提高查询速度的-说一下使用索引的注意事项-Mysql-索引主要使用的两种数据结构-什么是覆盖索引"><a href="#7-为什么要使用索引-索引这么多优点-为什么不对表中的每一个列创建一个索引呢-索引是如何提高查询速度的-说一下使用索引的注意事项-Mysql-索引主要使用的两种数据结构-什么是覆盖索引" class="headerlink" title="7. 为什么要使用索引?索引这么多优点,为什么不对表中的每一个列创建一个索引呢?索引是如何提高查询速度的?说一下使用索引的注意事项?Mysql 索引主要使用的两种数据结构?什么是覆盖索引?"></a>7. 为什么要使用索引?索引这么多优点,为什么不对表中的每一个列创建一个索引呢?索引是如何提高查询速度的?说一下使用索引的注意事项?Mysql 索引主要使用的两种数据结构?什么是覆盖索引?</h2><p><strong>为什么要使用索引？</strong></p><ol><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li><li>可以大大加快 数据的检索速度（大大减少的检索的数据量）, 这也是创建索引的最主要的原因。</li><li>帮助服务器避免排序和临时表</li><li>将随机 IO 变为顺序 IO</li><li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li></ol><p><strong>索引这么多优点，为什么不对表中的每一个列创建一个索引呢？</strong></p><ol><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li><li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li></ol><p><strong>索引是如何提高查询速度的？</strong></p><p>将无序的数据变成相对有序的数据（就像查目录一样）</p><p><strong>说一下使用索引的注意事项</strong></p><ol><li>避免 where 子句中对字段施加函数，这会造成无法命中索引。</li><li>在使用 InnoDB 时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。</li><li>将打算加索引的列建议设置为 NOT NULL ，因为 NULL 比空字符串需要更多的存储空间（不仅仅是索引列，普通的列如果业务允许都建议设置为 NOT NULL）</li><li>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 schema_unused_indexes 视图来查询哪些索引从未被使用</li><li>在使用 limit offset 查询缓慢时，可以借助索引来提高性能</li></ol><p><strong>Mysql 索引主要使用的哪两种数据结构？</strong></p><ul><li>哈希索引：对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择 BTree 索引。</li><li>BTree 索引：Mysql 的 BTree 索引使用的是 B 树中的 B+Tree。但对于主要的两种存储引擎（MyISAM 和 InnoDB）的实现方式是不同的。</li></ul><p>更多关于索引的内容可以查看我的这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247484486&idx=1&sn=215450f11e042bca8a58eac9f4a97686&chksm=fd985227caefdb3117b8375f150676f5824aa20d1ebfdbcfb93ff06e23e26efbafae6cf6b48e&token=1990180468&lang=zh_CN#rd">【思维导图-索引篇】搞定数据库索引就是这么简单</a></p><p><strong>什么是覆盖索引?</strong></p><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称<br>之为“覆盖索引”。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次,这样就会比较慢。覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p><h2 id="8-进程与线程的区别是什么-进程间的几种通信方式说一下-线程间的几种通信方式知道不"><a href="#8-进程与线程的区别是什么-进程间的几种通信方式说一下-线程间的几种通信方式知道不" class="headerlink" title="8. 进程与线程的区别是什么?进程间的几种通信方式说一下?线程间的几种通信方式知道不?"></a>8. 进程与线程的区别是什么?进程间的几种通信方式说一下?线程间的几种通信方式知道不?</h2><p><strong>进程与线程的区别是什么？</strong></p><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。另外，也正是因为共享资源，所以线程中执行时一般都要进行同步和互斥。总的来说，进程和线程的主要差别在于它们是不同的操作系统资源管理方式。</p><p><strong>进程间的几种通信方式说一下？</strong></p><ol><li><strong>管道（pipe）</strong>：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有血缘关系的进程间使用。进程的血缘关系通常指父子进程关系。管道分为 pipe（无名管道）和 fifo（命名管道）两种，有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间通信。</li><li><strong>信号量（semophore）</strong>：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它通常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li><li><strong>消息队列（message queue）</strong>：消息队列是由消息组成的链表，存放在内核中 并由消息队列标识符标识。消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。</li><li><strong>信号（signal）</strong>：信号是一种比较复杂的通信方式，用于通知接收进程某一事件已经发生。</li><li><strong>共享内存（shared memory）</strong>：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问，共享内存是最快的 IPC 方式，它是针对其他进程间的通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。</li><li><strong>套接字（socket）</strong>：socket，即套接字是一种通信机制，凭借这种机制，客户&#x2F;服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。也因为这样，套接字明确地将客户端和服务器区分开来。</li></ol><p><strong>线程间的几种通信方式知道不？</strong></p><p>1、锁机制</p><ul><li>互斥锁：提供了以排它方式阻止数据结构被并发修改的方法。</li><li>读写锁：允许多个线程同时读共享数据，而对写操作互斥。</li><li>条件变量：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li></ul><p>2、信号量机制：包括无名线程信号量与有名线程信号量</p><p>3、信号机制：类似于进程间的信号处理。</p><p>线程间通信的主要目的是用于线程同步，所以线程没有象进程通信中用于数据交换的通信机制。</p><h2 id="9-为什么要用单例模式-手写几种线程安全的单例模式"><a href="#9-为什么要用单例模式-手写几种线程安全的单例模式" class="headerlink" title="9. 为什么要用单例模式?手写几种线程安全的单例模式?"></a>9. 为什么要用单例模式?手写几种线程安全的单例模式?</h2><p><strong>简单来说使用单例模式可以带来下面几个好处:</strong></p><ul><li>对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；</li><li>由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。</li></ul><p><strong>懒汉式(双重检查加锁版本)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-comment">//volatile保证，当uniqueInstance变量被初始化成Singleton实例时，多个线程可以正确处理uniqueInstance变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">//检查实例，如果不存在，就进入同步代码块</span><br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//只有第一次才彻底执行这里的代码</span><br>            <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123;<br>               <span class="hljs-comment">//进入同步代码块后，再检查一次，如果仍是null，才创建实例</span><br>                <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>                    uniqueInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>静态内部类方式</strong></p><p>静态内部实现的单例是懒加载的且线程安全。</p><p>只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance（只有第一次使用这个单例的实例的时候才加载，同时不会有线程安全问题）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span> <span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-简单介绍一下-bean-知道-Spring-的-bean-的作用域与生命周期吗"><a href="#10-简单介绍一下-bean-知道-Spring-的-bean-的作用域与生命周期吗" class="headerlink" title="10. 简单介绍一下 bean;知道 Spring 的 bean 的作用域与生命周期吗?"></a>10. 简单介绍一下 bean;知道 Spring 的 bean 的作用域与生命周期吗?</h2><p>在 Spring 中，那些组成应用程序的主体及由 Spring IOC 容器所管理的对象，被称之为 bean。简单地讲，bean 就是由 IOC 容器初始化、装配及管理的对象，除此之外，bean 就与应用程序中的其他对象没有什么区别了。而 bean 的定义以及 bean 相互间的依赖关系将通过配置元数据来描述。</p><p>Spring 中的 bean 默认都是单例的，这些单例 Bean 在多线程程序下如何保证线程安全呢？ 例如对于 Web 应用来说，Web 容器对于每个用户请求都创建一个单独的 Sevlet 线程来处理请求，引入 Spring 框架之后，每个 Action 都是单例的，那么对于 Spring 托管的单例 Service Bean，如何保证其安全呢？ Spring 的单例是基于 BeanFactory 也就是 Spring 容器的，单例 Bean 在此容器内只有一个，Java 的单例是基于 JVM，每个 JVM 内只有一个实例。</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/10/166fd45773d5dd2e?w=563&h=299&f=webp&s=27930" alt="pring的bean的作用域"></p><p>Spring 的 bean 的生命周期以及更多内容可以查看：<a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247484400&idx=2&sn=7201eb365102fce017f89cb3527fb0bc&chksm=fd985591caefdc872a2fac897288119f94c345e4e12150774f960bf5f816b79e4b9b46be3d7f&token=1990180468&lang=zh_CN#rd">一文轻松搞懂 Spring 中 bean 的作用域与生命周期</a></p><h2 id="11-Spring-中的事务传播行为了解吗-TransactionDefinition-接口中哪五个表示隔离级别的常量"><a href="#11-Spring-中的事务传播行为了解吗-TransactionDefinition-接口中哪五个表示隔离级别的常量" class="headerlink" title="11. Spring 中的事务传播行为了解吗?TransactionDefinition 接口中哪五个表示隔离级别的常量?"></a>11. Spring 中的事务传播行为了解吗?TransactionDefinition 接口中哪五个表示隔离级别的常量?</h2><h4 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h4><p>事务传播行为（为了解决业务层方法之间互相调用的事务问题）：<br>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。在 TransactionDefinition 定义中包括了如下几个表示传播行为的常量：</p><p><strong>支持当前事务的情况：</strong></p><ul><li>TransactionDefinition.PROPAGATION_REQUIRED： 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li><li>TransactionDefinition.PROPAGATION_SUPPORTS： 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li>TransactionDefinition.PROPAGATION_MANDATORY： 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</li></ul><p><strong>不支持当前事务的情况：</strong></p><ul><li>TransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li><li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED： 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li>TransactionDefinition.PROPAGATION_NEVER： 以非事务方式运行，如果当前存在事务，则抛出异常。</li></ul><p><strong>其他情况：</strong></p><ul><li>TransactionDefinition.PROPAGATION_NESTED： 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 TransactionDefinition.PROPAGATION_REQUIRED。</li></ul><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</p><ul><li><strong>TransactionDefinition.ISOLATION_DEFAULT:</strong> 使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ 隔离级别 Oracle 默认采用的 READ_COMMITTED 隔离级别.</li><li><strong>TransactionDefinition.ISOLATION_READ_UNCOMMITTED:</strong> 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</li><li><strong>TransactionDefinition.ISOLATION_READ_COMMITTED:</strong> 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</li><li><strong>TransactionDefinition.ISOLATION_REPEATABLE_READ:</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><strong>TransactionDefinition.ISOLATION_SERIALIZABLE:</strong> 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li></ul><h2 id="12-SpringMVC-原理了解吗"><a href="#12-SpringMVC-原理了解吗" class="headerlink" title="12. SpringMVC 原理了解吗?"></a>12. SpringMVC 原理了解吗?</h2><p><img src="https://user-gold-cdn.xitu.io/2018/11/10/166fd45787394192?w=1015&h=466&f=webp&s=35352" alt="SpringMVC 原理"></p><p>客户端发送请求-&gt; 前端控制器 DispatcherServlet 接受客户端请求 -&gt; 找到处理器映射 HandlerMapping 解析请求对应的 Handler-&gt; HandlerAdapter 会根据 Handler 来调用真正的处理器处理请求，并处理相应的业务逻辑 -&gt; 处理器返回一个模型视图 ModelAndView -&gt; 视图解析器进行解析 -&gt; 返回一个视图对象-&gt;前端控制器 DispatcherServlet 渲染数据（Model）-&gt;将得到视图对象返回给用户</p><p>关于 SpringMVC 原理更多内容可以查看我的这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247484496&idx=1&sn=5472ffa687fe4a05f8900d8ee6726de4&chksm=fd985231caefdb27fc75b44ecf76b6f43e4617e0b01b3c040f8b8fab32e51dfa5118eed1d6ad&token=1990180468&lang=zh_CN#rd">SpringMVC 工作原理详解</a></p><h2 id="13-Spring-AOP-IOC-实现原理"><a href="#13-Spring-AOP-IOC-实现原理" class="headerlink" title="13. Spring AOP IOC 实现原理"></a>13. Spring AOP IOC 实现原理</h2><p>过了秋招挺长一段时间了，说实话我自己也忘了如何简要概括 Spring AOP IOC 实现原理，就在网上找了一个较为简洁的答案，下面分享给各位。</p><p><strong>IOC：</strong> 控制反转也叫依赖注入。IOC 利用 java 反射机制，AOP 利用代理模式。IOC 概念看似很抽象，但是很容易理解。说简单点就是将对象交给容器管理，你只需要在 spring 配置文件中配置对应的 bean 以及设置相关的属性，让 spring 容器来生成类的实例对象以及管理对象。在 spring 容器启动的时候，spring 会把你在配置文件中配置的 bean 都初始化好，然后在你需要调用的时候，就把它已经初始化好的那些 bean 分配给你需要调用这些 bean 的类。</p><p><strong>AOP：</strong> 面向切面编程。（Aspect-Oriented Programming） 。AOP 可以说是对 OOP 的补充和完善。OOP 引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。实现 AOP 的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码，属于静态代理。</p><h1 id="二-进阶篇"><a href="#二-进阶篇" class="headerlink" title="二 进阶篇"></a>二 进阶篇</h1><h2 id="1-消息队列-MQ-的套路"><a href="#1-消息队列-MQ-的套路" class="headerlink" title="1 消息队列 MQ 的套路"></a>1 消息队列 MQ 的套路</h2><p>消息队列&#x2F;消息中间件应该是 Java 程序员必备的一个技能了，如果你之前没接触过消息队列的话，建议先去百度一下某某消息队列入门，然后花 2 个小时就差不多可以学会任何一种消息队列的使用了。如果说仅仅学会使用是万万不够的，在实际生产环境还要考虑消息丢失等等情况。关于消息队列面试相关的问题，推荐大家也可以看一下视频《Java 工程师面试突击第 1 季-中华石杉老师》，如果大家没有资源的话，可以在我的公众号“Java 面试通关手册”后台回复关键字“1”即可！</p><h3 id="1-1-介绍一下消息队列-MQ-的应用场景-x2F-使用消息队列的好处"><a href="#1-1-介绍一下消息队列-MQ-的应用场景-x2F-使用消息队列的好处" class="headerlink" title="1.1 介绍一下消息队列 MQ 的应用场景&#x2F;使用消息队列的好处"></a>1.1 介绍一下消息队列 MQ 的应用场景&#x2F;使用消息队列的好处</h3><p>面试官一般会先问你这个问题，预热一下，看你知道消息队列不，一般在第一面的时候面试官可能只会问消息队列 MQ 的应用场景&#x2F;使用消息队列的好处、使用消息队列会带来什么问题、消息队列的技术选型这几个问题，不会太深究下去，在后面的第二轮&#x2F;第三轮技术面试中可能会深入问一下。</p><p><strong>《大型网站技术架构》第四章和第七章均有提到消息队列对应用性能及扩展性的提升。</strong></p><h4 id="1-通过异步处理提高系统性能"><a href="#1-通过异步处理提高系统性能" class="headerlink" title="1)通过异步处理提高系统性能"></a>1)通过异步处理提高系统性能</h4><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/%E9%80%9A%E8%BF%87%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E6%8F%90%E9%AB%98%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD.jpg" alt="通过异步处理提高系统性能"><br>如上图，<strong>在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即 返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。</strong></p><p>通过以上分析我们可以得出<strong>消息队列具有很好的削峰作用的功能</strong>——即<strong>通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。</strong> 举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示：<br><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8F%AF%E4%BB%A5%E6%9C%89%E6%95%88%E6%8A%B5%E5%BE%A1%E4%BF%83%E9%94%80%E6%B4%BB%E5%8A%A8%E5%88%9A%E5%BC%80%E5%A7%8B%E5%A4%A7%E9%87%8F%E8%AE%A2%E5%8D%95%E6%B6%8C%E5%85%A5%E5%AF%B9%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%B2%E5%87%BB.jpg" alt="合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击"><br>因为<strong>用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败</strong>。因此使用消息队列进行异步处理之后，需要<strong>适当修改业务流程进行配合</strong>，比如<strong>用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功</strong>，以免交易纠纷。这就类似我们平时手机订火车票和电影票。</p><h4 id="2-降低系统耦合性"><a href="#2-降低系统耦合性" class="headerlink" title="2)降低系统耦合性"></a>2)降低系统耦合性</h4><p>我们知道模块分布式部署以后聚合方式通常有两种：1.<strong>分布式消息队列</strong>和 2.<strong>分布式服务</strong>。</p><blockquote><p><strong>先来简单说一下分布式服务：</strong></p></blockquote><p>目前使用比较多的用来构建<strong>SOA（Service Oriented Architecture 面向服务体系结构）</strong>的<strong>分布式服务框架</strong>是阿里巴巴开源的<strong>Dubbo</strong>。如果想深入了解 Dubbo 的可以看我写的关于 Dubbo 的这一篇文章：<strong>《高性能优秀的服务框架-dubbo 介绍》</strong>：<a href="https://juejin.im/post/5acadeb1f265da2375072f9c" title="https://juejin.im/post/5acadeb1f265da2375072f9c">https://juejin.im/post/5acadeb1f265da2375072f9c</a></p><blockquote><p><strong>再来谈我们的分布式消息队列：</strong></p></blockquote><p>我们知道如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。</p><p>我们最常见的<strong>事件驱动架构</strong>类似生产者消费者模式，在大型网站中通常用利用消息队列实现事件驱动结构。如下图所示：</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/%E5%88%A9%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%BB%93%E6%9E%84.jpg" alt="利用消息队列实现事件驱动结构"><br><strong>消息队列使利用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。</strong> 从上图可以看到<strong>消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合</strong>，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。<strong>对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计</strong>。</p><p>消息接受者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消息接受者订阅该消息。因此基于事件（消息对象）驱动的业务架构可以是一系列流程。</p><p><strong>另外为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。</strong></p><p><strong>备注：</strong> 不要认为消息队列只能利用发布-订阅模式工作，只不过在解耦这个特定业务环境下是使用发布-订阅模式的，<strong>比如在我们的 ActiveMQ 消息队列中还有点对点工作模式</strong>，具体的会在后面的文章给大家详细介绍，这一篇文章主要还是让大家对消息队列有一个更透彻的了解。</p><blockquote><p>这个问题一般会在上一个问题问完之后，紧接着被问到。“使用消息队列会带来什么问题？”这个问题要引起重视，一般我们都会考虑使用消息队列会带来的好处而忽略它带来的问题！</p></blockquote><h3 id="1-2-那么使用消息队列会带来什么问题-考虑过这些问题吗"><a href="#1-2-那么使用消息队列会带来什么问题-考虑过这些问题吗" class="headerlink" title="1.2 那么使用消息队列会带来什么问题?考虑过这些问题吗?"></a>1.2 那么使用消息队列会带来什么问题?考虑过这些问题吗?</h3><ul><li><strong>系统可用性降低：</strong> 系统可用性在某种程度上降低，为什么这样说呢？在加入 MQ 之前，你不用考虑消息丢失或者说 MQ 挂掉等等的情况，但是，引入 MQ 之后你就需要去考虑了！</li><li><strong>系统复杂性提高：</strong> 加入 MQ 之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！</li><li><strong>一致性问题：</strong> 我上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了!</li></ul><blockquote><p>了解下面这个问题是为了我们更好的进行技术选型！该部分摘自：《Java 工程师面试突击第 1 季-中华石杉老师》，如果大家没有资源的话，可以在我的公众号“Java 面试通关手册”后台回复关键字“1”即可！</p></blockquote><h3 id="1-3-介绍一下你知道哪几种消息队列-该如何选择呢"><a href="#1-3-介绍一下你知道哪几种消息队列-该如何选择呢" class="headerlink" title="1.3 介绍一下你知道哪几种消息队列,该如何选择呢?"></a>1.3 介绍一下你知道哪几种消息队列,该如何选择呢?</h3><table><thead><tr><th align="left">特性</th><th align="right">ActiveMQ</th><th align="right">RabbitMQ</th><th align="right">RocketMQ</th><th align="right">Kafka</th></tr></thead><tbody><tr><td align="left">单机吞吐量</td><td align="right">万级，吞吐量比 RocketMQ 和 Kafka 要低了一个数量级</td><td align="right">万级，吞吐量比 RocketMQ 和 Kafka 要低了一个数量级</td><td align="right">10 万级，RocketMQ 也是可以支撑高吞吐的一种 MQ</td><td align="right">10 万级别，这是 kafka 最大的优点，就是吞吐量高。一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td></tr><tr><td align="left">topic 数量对吞吐量的影响</td><td align="right"></td><td align="right"></td><td align="right">topic 可以达到几百，几千个的级别，吞吐量会有较小幅度的下降这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td><td align="right">topic 从几十个到几百个的时候，吞吐量会大幅度下降。所以在同等机器下，kafka 尽量保证 topic 数量不要过多。如果要支撑大规模 topic，需要增加更多的机器资源</td></tr><tr><td align="left">可用性</td><td align="right">高，基于主从架构实现高可用性</td><td align="right">高，基于主从架构实现高可用性</td><td align="right">非常高，分布式架构</td><td align="right">非常高，kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td align="left">消息可靠性</td><td align="right">有较低的概率丢失数据</td><td align="right"></td><td align="right">经过参数优化配置，可以做到 0 丢失</td><td align="right">经过参数优化配置，消息可以做到 0 丢失</td></tr><tr><td align="left">时效性</td><td align="right">ms 级</td><td align="right">微秒级，这是 rabbitmq 的一大特点，延迟是最低的</td><td align="right">ms 级</td><td align="right">延迟在 ms 级以内</td></tr><tr><td align="left">功能支持</td><td align="right">MQ 领域的功能极其完备</td><td align="right">基于 erlang 开发，所以并发能力很强，性能极其好，延时很低</td><td align="right">MQ 功能较为完善，还是分布式的，扩展性好</td><td align="right">功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准</td></tr><tr><td align="left">优劣势总结</td><td align="right">非常成熟，功能强大，在业内大量的公司以及项目中都有应用。偶尔会有较低概率丢失消息，而且现在社区以及国内应用都越来越少，官方社区现在对 ActiveMQ 5.x 维护越来越少，几个月才发布一个版本而且确实主要是基于解耦和异步来用的，较少在大规模吞吐的场景中使用</td><td align="right">erlang 语言开发，性能极其好，延时很低；吞吐量到万级，MQ 功能比较完备而且开源提供的管理界面非常棒，用起来很好用。社区相对比较活跃，几乎每个月都发布几个版本分在国内一些互联网公司近几年用 rabbitmq 也比较多一些但是问题也是显而易见的，RabbitMQ 确实吞吐量会低一些，这是因为他做的实现机制比较重。而且 erlang 开发，国内有几个公司有实力做 erlang 源码级别的研究和定制？如果说你没这个实力的话，确实偶尔会有一些问题，你很难去看懂源码，你公司对这个东西的掌控很弱，基本职能依赖于开源社区的快速维护和修复 bug。而且 rabbitmq 集群动态扩展会很麻烦，不过这个我觉得还好。其实主要是 erlang 语言本身带来的问题。很难读源码，很难定制和掌控。</td><td align="right">接口简单易用，而且毕竟在阿里大规模应用过，有阿里品牌保障。日处理消息上百亿之多，可以做到大规模吞吐，性能也非常好，分布式扩展也很方便，社区维护还可以，可靠性和可用性都是 ok 的，还可以支撑大规模的 topic 数量，支持复杂 MQ 业务场景。而且一个很大的优势在于，阿里出品都是 java 系的，我们可以自己阅读源码，定制自己公司的 MQ，可以掌控。社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准 JMS 规范走的有些系统要迁移需要修改大量代码。还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用 RocketMQ 挺好的</td><td align="right">kafka 的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms 级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时 kafka 最好是支撑较少的 topic 数量即可，保证其超高吞吐量。而且 kafka 唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。</td></tr></tbody></table><blockquote><p>这部分内容，我这里不给出答案，大家可以自行根据自己学习的消息队列查阅相关内容，我可能会在后面的文章中介绍到这部分内容。另外，下面这些问题在视频《Java 工程师面试突击第 1 季-中华石杉老师》中都有提到，如果大家没有资源的话，可以在我的公众号“Java 面试通关手册”后台回复关键字“1”即可！</p></blockquote><h3 id="1-4-关于消息队列其他一些常见的问题展望"><a href="#1-4-关于消息队列其他一些常见的问题展望" class="headerlink" title="1.4 关于消息队列其他一些常见的问题展望"></a>1.4 关于消息队列其他一些常见的问题展望</h3><ol><li>引入消息队列之后如何保证高可用性？</li><li>如何保证消息不被重复消费呢？</li><li>如何保证消息的可靠性传输（如何处理消息丢失的问题）？</li><li>我该怎么保证从消息队列里拿到的数据按顺序执行？</li><li>如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？</li><li>如果让你来开发一个消息队列中间件，你会怎么设计架构？</li></ol><h2 id="2-谈谈-InnoDB-和-MyIsam-两者的区别"><a href="#2-谈谈-InnoDB-和-MyIsam-两者的区别" class="headerlink" title="2 谈谈 InnoDB 和 MyIsam 两者的区别"></a>2 谈谈 InnoDB 和 MyIsam 两者的区别</h2><h3 id="2-1-两者的对比"><a href="#2-1-两者的对比" class="headerlink" title="2.1 两者的对比"></a>2.1 两者的对比</h3><ol><li><strong>count 运算上的区别：</strong> 因为 MyISAM 缓存有表 meta-data（行数等），因此在做 COUNT(*)时对于一个结构很好的查询是不需要消耗多少资源的。而对于 InnoDB 来说，则没有这种缓存</li><li><strong>是否支持事务和崩溃后的安全恢复：</strong> MyISAM 强调的是性能，每次查询具有原子性，其执行速度比 InnoDB 类型更快，但是不提供事务支持。但是 InnoDB 提供事务支持，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</li><li><strong>是否支持外键：</strong> MyISAM 不支持，而 InnoDB 支持。</li></ol><h3 id="2-2-关于两者的总结"><a href="#2-2-关于两者的总结" class="headerlink" title="2.2 关于两者的总结"></a>2.2 关于两者的总结</h3><p>MyISAM 更适合读密集的表，而 InnoDB 更适合写密集的表。 在数据库做主从分离的情况下，经常选择 MyISAM 作为主库的存储引擎。</p><p>一般来说，如果需要事务支持，并且有较高的并发读取频率(MyISAM 的表锁的粒度太大，所以当该表写并发量较高时，要等待的查询就会很多了)，InnoDB 是不错的选择。如果你的数据量很大（MyISAM 支持压缩特性可以减少磁盘的空间占用），而且不需要支持事务时，MyISAM 是最好的选择。</p><h2 id="3-聊聊-Java-中的集合吧"><a href="#3-聊聊-Java-中的集合吧" class="headerlink" title="3 聊聊 Java 中的集合吧!"></a>3 聊聊 Java 中的集合吧!</h2><h3 id="3-1-Arraylist-与-LinkedList-有什么不同-注意加上从数据结构分析的内容"><a href="#3-1-Arraylist-与-LinkedList-有什么不同-注意加上从数据结构分析的内容" class="headerlink" title="3.1 Arraylist 与 LinkedList 有什么不同?(注意加上从数据结构分析的内容)"></a>3.1 Arraylist 与 LinkedList 有什么不同?(注意加上从数据结构分析的内容)</h3><ul><li><strong>1. 是否保证线程安全：</strong> ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li><li><strong>2. 底层数据结构：</strong> Arraylist 底层使用的是 Object 数组；LinkedList 底层使用的是双向链表数据结构（注意双向链表和双向循环链表的区别：）；</li><li><strong>3. 插入和删除是否受元素位置的影响：</strong> ① <strong>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位&#x2F;向前移一位的操作。 ② <strong>LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O(1) 而数组为近似 O(n) 。</strong></li><li><strong>4. 是否支持快速随机访问：</strong> LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象（对应于<code>get(int index)</code>方法）。</li><li><strong>5. 内存空间占用：</strong> ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ul><p><strong>补充内容:RandomAccess 接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RandomAccess</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看源码我们发现实际上 RandomAccess 接口中什么都没有定义。所以，在我看来 RandomAccess 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。</p><p>在 binarySearch() 方法中，它要判断传入的 list 是否 RamdomAccess 的实例，如果是，调用 indexedBinarySearch() 方法，如果不是，那么调用 iteratorBinarySearch() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt;<br><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(List&lt;? extends Comparable&lt;? <span class="hljs-built_in">super</span> T&gt;&gt; list, T key)</span> &#123;<br>    <span class="hljs-keyword">if</span> (list <span class="hljs-keyword">instanceof</span> RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)<br>        <span class="hljs-keyword">return</span> Collections.indexedBinarySearch(list, key);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> Collections.iteratorBinarySearch(list, key);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>ArraysList 实现了 RandomAccess 接口， 而 LinkedList 没有实现。为什么呢？我觉得还是和底层数据结构有关！ArraysList 底层是数组，而 LinkedList 底层是链表。数组天然支持随机访问，时间复杂度为 O(1) ，所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O(n) ，所以不支持快速随机访问。，ArraysList 实现了 RandomAccess 接口，就表明了他具有快速随机访问功能。 RandomAccess 接口只是标识，并不是说 ArraysList 实现 RandomAccess 接口才具有快速随机访问功能的！</p><p><strong>下面再总结一下 list 的遍历方式选择：</strong></p><ul><li>实现了 RandomAccess 接口的 list，优先选择普通 for 循环 ，其次 foreach,</li><li>未实现 RandomAccess 接口的 ist， 优先选择 iterator 遍历（foreach 遍历底层也是通过 iterator 实现的），大 size 的数据，千万不要使用普通 for 循环</li></ul><blockquote><p>Java 中的集合这类问题几乎是面试必问的，问到这类问题的时候，HashMap 又是几乎必问的问题，所以大家一定要引起重视！</p></blockquote><h3 id="3-2-HashMap-的底层实现"><a href="#3-2-HashMap-的底层实现" class="headerlink" title="3.2 HashMap 的底层实现"></a>3.2 HashMap 的底层实现</h3><h4 id="1-JDK1-8-之前"><a href="#1-JDK1-8-之前" class="headerlink" title="1)JDK1.8 之前"></a>1)JDK1.8 之前</h4><p>JDK1.8 之前 HashMap 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。<strong>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的时数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p><p><strong>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</strong></p><p><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></p><p>JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-comment">// key.hashCode()：返回散列值也就是hashcode</span><br>    <span class="hljs-comment">// ^ ：按位异或</span><br>    <span class="hljs-comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span><br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>对比一下 JDK1.7 的 HashMap 的 hash 方法源码.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(<span class="hljs-type">int</span> h)</span> &#123;<br>    <span class="hljs-comment">// This function ensures that hashCodes that differ only by</span><br>    <span class="hljs-comment">// constant multiples at each bit position have a bounded</span><br>    <span class="hljs-comment">// number of collisions (approximately 8 at default load factor).</span><br><br>    h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);<br>    <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p><p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/jdk1.8%E4%B9%8B%E5%89%8D%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84-HashMap.jpg" alt="jdk1.8之前的内部结构-HashMap"></p><h4 id="2-JDK1-8-之后"><a href="#2-JDK1-8-之后" class="headerlink" title="2)JDK1.8 之后"></a>2)JDK1.8 之后</h4><p>相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间。</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/JDK1.8%E4%B9%8B%E5%90%8E%E7%9A%84HashMap%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="jdk1.8之后的内部结构-HashMap"></p><p>TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p><blockquote><p>问完 HashMap 的底层原理之后，面试官可能就会紧接着问你 HashMap 底层数据结构相关的问题！</p></blockquote><h3 id="3-3-既然谈到了红黑树-你给我手绘一个出来吧-然后简单讲一下自己对于红黑树的理解"><a href="#3-3-既然谈到了红黑树-你给我手绘一个出来吧-然后简单讲一下自己对于红黑树的理解" class="headerlink" title="3.3 既然谈到了红黑树,你给我手绘一个出来吧,然后简单讲一下自己对于红黑树的理解"></a>3.3 既然谈到了红黑树,你给我手绘一个出来吧,然后简单讲一下自己对于红黑树的理解</h3><p><img src="https://user-gold-cdn.xitu.io/2018/11/14/16711ac29c138cba?w=851&h=614&f=jpeg&s=34458" alt="红黑树"></p><p><strong>红黑树特点:</strong></p><ol><li>每个节点非红即黑；</li><li>根节点总是黑色的；</li><li>每个叶子节点都是黑色的空节点（NIL 节点）；</li><li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；</li><li>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）</li></ol><p><strong>红黑树的应用：</strong></p><p>TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。</p><p><strong>为什么要用红黑树</strong></p><p>简单来说红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p><h3 id="3-4-红黑树这么优秀-为何不直接使用红黑树得了"><a href="#3-4-红黑树这么优秀-为何不直接使用红黑树得了" class="headerlink" title="3.4 红黑树这么优秀,为何不直接使用红黑树得了?"></a>3.4 红黑树这么优秀,为何不直接使用红黑树得了?</h3><p>说一下自己对于这个问题的看法：我们知道红黑树属于（自）平衡二叉树，但是为了保持“平衡”是需要付出代价的，红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，这费事啊。你说说我们引入红黑树就是为了查找数据快，如果链表长度很短的话，根本不需要引入红黑树的，你引入之后还要付出代价维持它的平衡。但是链表过长就不一样了。至于为什么选 8 这个值呢？通过概率统计所得，这个值是综合查询成本和新增元素成本得出的最好的一个值。</p><h3 id="3-5-HashMap-和-Hashtable-的区别-x2F-HashSet-和-HashMap-区别"><a href="#3-5-HashMap-和-Hashtable-的区别-x2F-HashSet-和-HashMap-区别" class="headerlink" title="3.5 HashMap 和 Hashtable 的区别&#x2F;HashSet 和 HashMap 区别"></a>3.5 HashMap 和 Hashtable 的区别&#x2F;HashSet 和 HashMap 区别</h3><p><strong>HashMap 和 Hashtable 的区别</strong></p><ol><li><strong>线程是否安全：</strong> HashMap 是非线程安全的，Hashtable 是线程安全的；Hashtable 内部的方法基本都经过 <code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</li><li><strong>效率：</strong> 因为线程安全的问题，HashMap 要比 Hashtable 效率高一点。另外，Hashtable 基本被淘汰，不要在代码中使用它；</li><li><strong>对 Null key 和 Null value 的支持：</strong> HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 Hashtable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。</li><li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ① 创建时如果不指定容量初始值，Hashtable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小（HashMap 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 HashMap 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</li><li><strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li></ol><p><strong>HashSet 和 HashMap 区别</strong></p><p>如果你看过 HashSet 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了 clone() 方法、writeObject()方法、readObject()方法是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。）</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/2/161e717d734f3b23?w=896&h=363&f=jpeg&s=205536" alt="HashSet 和 HashMap 区别"></p><h1 id="三-终结篇"><a href="#三-终结篇" class="headerlink" title="三 终结篇"></a>三 终结篇</h1><h2 id="1-Object-类有哪些方法"><a href="#1-Object-类有哪些方法" class="headerlink" title="1. Object 类有哪些方法?"></a>1. Object 类有哪些方法?</h2><p>这个问题，面试中经常出现。我觉得不论是出于应付面试还是说更好地掌握 Java 这门编程语言，大家都要掌握！</p><h3 id="1-1-Object-类的常见方法总结"><a href="#1-1-Object-类的常见方法总结" class="headerlink" title="1.1 Object 类的常见方法总结"></a>1.1 Object 类的常见方法总结</h3><p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getClass()<span class="hljs-comment">//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> <span class="hljs-comment">//native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span><span class="hljs-comment">//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。</span><br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException<span class="hljs-comment">//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。</span><br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span><span class="hljs-comment">//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">()</span><span class="hljs-comment">//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyAll</span><span class="hljs-params">()</span><span class="hljs-comment">//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException<span class="hljs-comment">//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, <span class="hljs-type">int</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException<span class="hljs-comment">//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException<span class="hljs-comment">//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span><br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123; &#125;<span class="hljs-comment">//实例被垃圾回收器回收的时候触发的操作</span><br><br></code></pre></td></tr></table></figure><blockquote><p>问完上面这个问题之后，面试官很可能紧接着就会问你“hashCode 与 equals”相关的问题。</p></blockquote><h3 id="1-2-hashCode-与-equals"><a href="#1-2-hashCode-与-equals" class="headerlink" title="1.2 hashCode 与 equals"></a>1.2 hashCode 与 equals</h3><p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写 equals 时必须重写 hashCode 方法？”</p><h4 id="1-2-1-hashCode-介绍"><a href="#1-2-1-hashCode-介绍" class="headerlink" title="1.2.1 hashCode()介绍"></a>1.2.1 hashCode()介绍</h4><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在 JDK 的 Object.java 中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。另外需要注意的是： Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p><h4 id="1-2-2-为什么要有-hashCode"><a href="#1-2-2-为什么要有-hashCode" class="headerlink" title="1.2.2 为什么要有 hashCode"></a>1.2.2 为什么要有 hashCode</h4><p><strong>我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</strong></p><p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的 Java 启蒙书《Head fist java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><h4 id="1-2-3-hashCode-与-equals-的相关规定"><a href="#1-2-3-hashCode-与-equals-的相关规定" class="headerlink" title="1.2.3 hashCode()与 equals()的相关规定"></a>1.2.3 hashCode()与 equals()的相关规定</h4><ol><li>如果两个对象相等，则 hashcode 一定也是相同的</li><li>两个对象相等，对两个对象分别调用 equals 方法都返回 true</li><li>两个对象有相同的 hashcode 值，它们也不一定是相等的</li><li><strong>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</strong></li><li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li></ol><h4 id="1-2-4-为什么两个对象有相同的-hashcode-值-它们也不一定是相等的"><a href="#1-2-4-为什么两个对象有相同的-hashcode-值-它们也不一定是相等的" class="headerlink" title="1.2.4 为什么两个对象有相同的 hashcode 值,它们也不一定是相等的?"></a>1.2.4 为什么两个对象有相同的 hashcode 值,它们也不一定是相等的?</h4><p>在这里解释一位小伙伴的问题。以下内容摘自《Head Fisrt Java》。</p><p>因为 hashCode() 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 hashCode）。</p><p>我们刚刚也提到了 HashSet,如果 HashSet 在对比的时候，同样的 hashcode 有多个对象，它会使用 equals() 来判断是否真的相同。也就是说 hashcode 只是用来缩小查找成本。</p><blockquote><p>&#x3D;&#x3D;与 equals 的对比也是比较常问的基础问题之一！</p></blockquote><h3 id="1-3-x3D-x3D-与-equals"><a href="#1-3-x3D-x3D-与-equals" class="headerlink" title="1.3 &#x3D;&#x3D;与 equals"></a>1.3 &#x3D;&#x3D;与 equals</h3><p><strong>&#x3D;&#x3D;</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型&#x3D;&#x3D;比较的是值，引用数据类型&#x3D;&#x3D;比较的是内存地址)</p><p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p><ul><li>情况 1：类没有覆盖 equals()方法。则通过 equals()比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象。</li><li>情况 2：类覆盖了 equals()方法。一般，我们都覆盖 equals()方法来两个对象的内容相等；若它们的内容相等，则返回 true(即，认为这两个对象相等)。</li></ul><p><strong>举个例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;ab&quot;</span>); <span class="hljs-comment">// a 为一个引用</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;ab&quot;</span>); <span class="hljs-comment">// b为另一个引用,对象的内容一样</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">aa</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>; <span class="hljs-comment">// 放在常量池中</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>; <span class="hljs-comment">// 从常量池中查找</span><br>        <span class="hljs-keyword">if</span> (aa == bb) <span class="hljs-comment">// true</span><br>            System.out.println(<span class="hljs-string">&quot;aa==bb&quot;</span>);<br>        <span class="hljs-keyword">if</span> (a == b) <span class="hljs-comment">// false，非同一对象</span><br>            System.out.println(<span class="hljs-string">&quot;a==b&quot;</span>);<br>        <span class="hljs-keyword">if</span> (a.equals(b)) <span class="hljs-comment">// true</span><br>            System.out.println(<span class="hljs-string">&quot;aEQb&quot;</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">42</span> == <span class="hljs-number">42.0</span>) &#123; <span class="hljs-comment">// true</span><br>            System.out.println(<span class="hljs-string">&quot;true&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>String 中的 equals()方法是被重写过的，因为 Object 的 equals()方法是比较的对象的内存地址，而 String 的 equals()方法比较的是对象的值。</li><li>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</li></ul><blockquote><p>在<a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247484625&idx=1&sn=9c4fa1f7d4291a5fbd7daa44bac2b012&chksm=fd9852b0caefdba6edcf9a827aa4a17ddc97bf6ad2e5ee6f7e1aa1b443b54444d05d2b76732b&token=723699735&lang=zh_CN#rd">【备战春招&#x2F;秋招系列 5】美团面经总结进阶篇 （附详解答案）</a> 这篇文章中，我们已经提到了一下关于 HashMap 在面试中常见的问题：HashMap 的底层实现、简单讲一下自己对于红黑树的理解、红黑树这么优秀，为何不直接使用红黑树得了、HashMap 和 Hashtable 的区别&#x2F;HashSet 和 HashMap 区别。HashMap 和 ConcurrentHashMap 这俩兄弟在一般只要面试中问到集合相关的问题就一定会被问到，所以各位务必引起重视！</p></blockquote><h2 id="2-ConcurrentHashMap-相关问题"><a href="#2-ConcurrentHashMap-相关问题" class="headerlink" title="2 ConcurrentHashMap 相关问题"></a>2 ConcurrentHashMap 相关问题</h2><h3 id="2-1-ConcurrentHashMap-和-Hashtable-的区别"><a href="#2-1-ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="2.1 ConcurrentHashMap 和 Hashtable 的区别"></a>2.1 ConcurrentHashMap 和 Hashtable 的区别</h3><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p><ul><li><strong>底层数据结构：</strong> JDK1.7 的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 HashMap1.8 的结构一样，数组+链表&#x2F;红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li><li><strong>实现线程安全的方式（重要）：</strong> ① <strong>在 JDK1.7 的时候，ConcurrentHashMap（分段锁）</strong> 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配 16 个 Segment，比 Hashtable 效率提高 16 倍。） <strong>到了 JDK1.8 的时候已经摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6 以后 对 synchronized 锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 HashMap，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② **Hashtable(同一把锁)**：使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li></ul><p><strong>两者的对比图：</strong></p><p>图片来源：<a href="http://www.cnblogs.com/chengxiao/p/6842045.html">http://www.cnblogs.com/chengxiao/p/6842045.html</a></p><p>Hashtable：<br><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-22/50656681.jpg"></p><p>JDK1.7 的 ConcurrentHashMap：<br><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-22/33120488.jpg"><br>JDK1.8 的 ConcurrentHashMap（TreeBin: 红黑二叉树节点<br>Node: 链表节点）：<br><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-22/97739220.jpg"></p><h3 id="2-2-ConcurrentHashMap-线程安全的具体实现方式-x2F-底层具体实现"><a href="#2-2-ConcurrentHashMap-线程安全的具体实现方式-x2F-底层具体实现" class="headerlink" title="2.2 ConcurrentHashMap 线程安全的具体实现方式&#x2F;底层具体实现"></a>2.2 ConcurrentHashMap 线程安全的具体实现方式&#x2F;底层具体实现</h3><h4 id="JDK1-7-上面有示意图"><a href="#JDK1-7-上面有示意图" class="headerlink" title="JDK1.7(上面有示意图)"></a>JDK1.7(上面有示意图)</h4><p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p><p><strong>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成</strong>。</p><p>Segment 实现了 ReentrantLock，所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Segment</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和 HashMap 类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个 HashEntry 数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 的锁。</p><h4 id="JDK1-8-上面有示意图"><a href="#JDK1-8-上面有示意图" class="headerlink" title="JDK1.8(上面有示意图)"></a>JDK1.8(上面有示意图)</h4><p>ConcurrentHashMap 取消了 Segment 分段锁，采用 CAS 和 synchronized 来保证并发安全。数据结构跟 HashMap1.8 的结构类似，数组+链表&#x2F;红黑二叉树。</p><p>synchronized 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。</p><h2 id="3-谈谈-synchronized-和-ReentrantLock-的区别"><a href="#3-谈谈-synchronized-和-ReentrantLock-的区别" class="headerlink" title="3 谈谈 synchronized 和 ReentrantLock 的区别"></a>3 谈谈 synchronized 和 ReentrantLock 的区别</h2><p><strong>① 两者都是可重入锁</strong></p><p>两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。</p><p><strong>② synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</strong></p><p>synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try&#x2F;finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p><p><strong>③ ReentrantLock 比 synchronized 增加了一些高级功能</strong></p><p>相比 synchronized，ReentrantLock 增加了一些高级功能。主要来说主要有三点：<strong>① 等待可中断；② 可实现公平锁；③ 可实现选择性通知（锁可以绑定多个条件）</strong></p><ul><li><strong>ReentrantLock 提供了一种能够中断等待锁的线程的机制</strong>，通过 lock.lockInterruptibly() 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li><li><strong>ReentrantLock 可以指定是公平锁还是非公平锁。而 synchronized 只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</strong> ReentrantLock 默认情况是非公平的，可以通过 ReentrantLock 类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li><li>synchronized 关键字与 wait()和 notify&#x2F;notifyAll()方法相结合可以实现等待&#x2F;通知机制，ReentrantLock 类当然也可以实现，但是需要借助于 Condition 接口与 newCondition() 方法。Condition 是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个 Lock 对象中可以创建多个 Condition 实例（即对象监视器），<strong>线程对象可以注册在指定的 Condition 中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用 notify&#x2F;notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用 ReentrantLock 类结合 Condition 实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是 Condition 接口默认提供的。而 synchronized 关键字就相当于整个 Lock 对象中只有一个 Condition 实例，所有的线程都注册在它一个身上。如果执行 notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而 Condition 实例的 signalAll()方法 只会唤醒注册在该 Condition 实例中的所有等待线程。</li></ul><p>如果你想使用上述功能，那么选择 ReentrantLock 是一个不错的选择。</p><p><strong>④ 两者的性能已经相差无几</strong></p><p>在 JDK1.6 之前，synchronized 的性能是比 ReentrantLock 差很多。具体表示为：synchronized 关键字吞吐量随线程数的增加，下降得非常严重。而 ReentrantLock 基本保持一个比较稳定的水平。我觉得这也侧面反映了， synchronized 关键字还有非常大的优化余地。后续的技术发展也证明了这一点，我们上面也讲了在 JDK1.6 之后 JVM 团队对 synchronized 关键字做了很多优化。JDK1.6 之后，synchronized 和 ReentrantLock 的性能基本是持平了。所以网上那些说因为性能才选择 ReentrantLock 的文章都是错的！JDK1.6 之后，性能已经不是选择 synchronized 和 ReentrantLock 的影响因素了！而且虚拟机在未来的性能改进中会更偏向于原生的 synchronized，所以还是提倡在 synchronized 能满足你的需求的情况下，优先考虑使用 synchronized 关键字来进行同步！优化后的 synchronized 和 ReentrantLock 一样，在很多地方都是用到了 CAS 操作。</p><h2 id="4-线程池了解吗"><a href="#4-线程池了解吗" class="headerlink" title="4 线程池了解吗?"></a>4 线程池了解吗?</h2><h3 id="4-1-为什么要用线程池"><a href="#4-1-为什么要用线程池" class="headerlink" title="4.1 为什么要用线程池?"></a>4.1 为什么要用线程池?</h3><p>线程池提供了一种限制和管理资源（包括执行一个任务）。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。</p><p>这里借用《Java 并发编程的艺术》提到的来说一下使用线程池的好处：</p><ul><li><strong>降低资源消耗。</strong> 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度。</strong> 当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性。</strong> 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h3 id="4-2-Java-提供了哪几种线程池-他们各自的使用场景是什么"><a href="#4-2-Java-提供了哪几种线程池-他们各自的使用场景是什么" class="headerlink" title="4.2 Java 提供了哪几种线程池?他们各自的使用场景是什么?"></a>4.2 Java 提供了哪几种线程池?他们各自的使用场景是什么?</h3><h4 id="Java-主要提供了下面-4-种线程池"><a href="#Java-主要提供了下面-4-种线程池" class="headerlink" title="Java 主要提供了下面 4 种线程池"></a>Java 主要提供了下面 4 种线程池</h4><ul><li><strong>FixedThreadPool：</strong> 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li><li><strong>SingleThreadExecutor：</strong> 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li><li><strong>CachedThreadPool：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li><li><strong>ScheduledThreadPoolExecutor：</strong> 主要用来在给定的延迟后运行任务，或者定期执行任务。ScheduledThreadPoolExecutor 又分为：ScheduledThreadPoolExecutor（包含多个线程）和 SingleThreadScheduledExecutor （只包含一个线程）两种。</li></ul><h4 id="各种线程池的适用场景介绍"><a href="#各种线程池的适用场景介绍" class="headerlink" title="各种线程池的适用场景介绍"></a>各种线程池的适用场景介绍</h4><ul><li><strong>FixedThreadPool：</strong> 适用于为了满足资源管理需求，而需要限制当前线程数量的应用场景。它适用于负载比较重的服务器；</li><li><strong>SingleThreadExecutor：</strong> 适用于需要保证顺序地执行各个任务并且在任意时间点，不会有多个线程是活动的应用场景；</li><li><strong>CachedThreadPool：</strong> 适用于执行很多的短期异步任务的小程序，或者是负载较轻的服务器；</li><li><strong>ScheduledThreadPoolExecutor：</strong> 适用于需要多个后台执行周期任务，同时为了满足资源管理需求而需要限制后台线程的数量的应用场景；</li><li><strong>SingleThreadScheduledExecutor：</strong> 适用于需要单个后台线程执行周期任务，同时保证顺序地执行各个任务的应用场景。</li></ul><h3 id="4-3-创建的线程池的方式"><a href="#4-3-创建的线程池的方式" class="headerlink" title="4.3 创建的线程池的方式"></a>4.3 创建的线程池的方式</h3><p><strong>（1） 使用 Executors 创建</strong></p><p>我们上面刚刚提到了 Java 提供的几种线程池，通过 Executors 工具类我们可以很轻松的创建我们上面说的几种线程池。但是实际上我们一般都不是直接使用 Java 提供好的线程池，另外在《阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 构造函数 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Executors 返回线程池对象的弊端如下：<br><br>FixedThreadPool 和 SingleThreadExecutor ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致OOM。<br>CachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。<br><br></code></pre></td></tr></table></figure><p><strong>（2） ThreadPoolExecutor 的构造函数创建</strong></p><p>我们可以自己直接调用 ThreadPoolExecutor 的构造函数来自己创建线程池。在创建的同时，给 BlockQueue 指定容量就可以了。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">13</span>, <span class="hljs-number">13</span>,<br>        <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>(<span class="hljs-number">13</span>));<br></code></pre></td></tr></table></figure><p>这种情况下，一旦提交的线程数超过当前可用线程数时，就会抛出 java.util.concurrent.RejectedExecutionException，这是因为当前线程池使用的队列是有边界队列，队列已经满了便无法继续处理新的请求。但是异常（Exception）总比发生错误（Error）要好。</p><p><strong>（3） 使用开源类库</strong></p><p>Hollis 大佬之前在他的文章中也提到了：“除了自己定义 ThreadPoolExecutor 外。还有其他方法。这个时候第一时间就应该想到开源类库，如 apache 和 guava 等。”他推荐使用 guava 提供的 ThreadFactoryBuilder 来创建线程池。下面是参考他的代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExecutorsDemo</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">namedThreadFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactoryBuilder</span>()<br>        .setNameFormat(<span class="hljs-string">&quot;demo-pool-%d&quot;</span>).build();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">5</span>, <span class="hljs-number">200</span>,<br>        <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(<span class="hljs-number">1024</span>), namedThreadFactory, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy());<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;<br>            pool.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SubThread</span>());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上述方式创建线程时，不仅可以避免 OOM 的问题，还可以自定义线程名称，更加方便的出错的时候溯源。</p><h2 id="5-Nginx"><a href="#5-Nginx" class="headerlink" title="5 Nginx"></a>5 Nginx</h2><h3 id="5-1-简单介绍一下-Nginx"><a href="#5-1-简单介绍一下-Nginx" class="headerlink" title="5.1 简单介绍一下 Nginx"></a>5.1 简单介绍一下 Nginx</h3><p>Nginx 是一款轻量级的 Web 服务器&#x2F;反向代理服务器及电子邮件（IMAP&#x2F;POP3）代理服务器。 Nginx 主要提供反向代理、负载均衡、动静分离(静态资源服务)等服务。下面我简单地介绍一下这些名词。</p><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>谈到反向代理，就不得不提一下正向代理。无论是正向代理，还是反向代理，说到底，就是代理模式的衍生版本罢了</p><ul><li><strong>正向代理：</strong>某些情况下，代理我们用户去访问服务器，需要用户手动的设置代理服务器的 ip 和端口号。正向代理比较常见的一个例子就是 VPN 了。</li><li><strong>反向代理：</strong> 是用来代理服务器的，代理我们要访问的目标服务器。代理服务器接受请求，然后将请求转发给内部网络的服务器，并将从服务器上得到的结果返回给客户端，此时代理服务器对外就表现为一个服务器。</li></ul><p>通过下面两幅图，大家应该更好理解（图源：<a href="http://blog.720ui.com/2016/nginx_action_05_proxy/%EF%BC%89%EF%BC%9A">http://blog.720ui.com/2016/nginx_action_05_proxy/）：</a></p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-15/60925795.jpg" alt="正向代理"></p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-15/62563930.jpg" alt="反向代理"></p><p>所以，简单的理解，就是正向代理是为客户端做代理，代替客户端去访问服务器，而反向代理是为服务器做代理，代替服务器接受客户端请求。</p><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>在高并发情况下需要使用，其原理就是将并发请求分摊到多个服务器执行，减轻每台服务器的压力，多台服务器(集群)共同完成工作任务，从而提高了数据的吞吐量。</p><p>Nginx 支持的 weight 轮询（默认）、ip_hash、fair、url_hash 这四种负载均衡调度算法，感兴趣的可以自行查阅。</p><p>负载均衡相比于反向代理更侧重的是将请求分担到多台服务器上去，所以谈论负载均衡只有在提供某服务的服务器大于两台时才有意义。</p><h4 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h4><p>动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路。</p><h3 id="5-2-为什么要用-Nginx"><a href="#5-2-为什么要用-Nginx" class="headerlink" title="5.2 为什么要用 Nginx?"></a>5.2 为什么要用 Nginx?</h3><blockquote><p>这部分内容参考极客时间—<a href="https://time.geekbang.org/course/intro/138?code=AycjiiQk6uQRxnVJzBupFkrGkvZlmYELPRsZbWzaAHE=" title="Nginx核心知识100讲的内容">Nginx 核心知识 100 讲的内容</a>。</p></blockquote><p>如果面试官问你这个问题，就一定想看你知道 Nginx 服务器的一些优点吗。</p><p>Nginx 有以下 5 个优点：</p><ol><li>高并发、高性能（这是其他 web 服务器不具有的）</li><li>可扩展性好（模块化设计，第三方插件生态圈丰富）</li><li>高可靠性（可以在服务器行持续不间断的运行数年）</li><li>热部署（这个功能对于 Nginx 来说特别重要，热部署指可以在不停止 Nginx 服务的情况下升级 Nginx）</li><li>BSD 许可证（意味着我们可以将源代码下载下来进行修改然后使用自己的版本）</li></ol><h3 id="5-3-Nginx-的四个主要组成部分了解吗"><a href="#5-3-Nginx-的四个主要组成部分了解吗" class="headerlink" title="5.3 Nginx 的四个主要组成部分了解吗?"></a>5.3 Nginx 的四个主要组成部分了解吗?</h3><blockquote><p>这部分内容参考极客时间—<a href="https://time.geekbang.org/course/intro/138?code=AycjiiQk6uQRxnVJzBupFkrGkvZlmYELPRsZbWzaAHE=" title="Nginx核心知识100讲的内容">Nginx 核心知识 100 讲的内容</a>。</p></blockquote><ul><li>Nginx 二进制可执行文件：由各模块源码编译出一个文件</li><li>nginx.conf 配置文件：控制 Nginx 行为</li><li>acess.log 访问日志： 记录每一条 HTTP 请求信息</li><li>error.log 错误日志：定位问题</li></ul>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pageCache</title>
    <link href="/2022/12/05/netty/pageCache/"/>
    <url>/2022/12/05/netty/pageCache/</url>
    
    <content type="html"><![CDATA[<h1 id="pageCache"><a href="#pageCache" class="headerlink" title="pageCache"></a>pageCache</h1><p>对数据进行预读, 例如read() 每次读32KB的数据, 内核会将32～64KB的数据也读取到pageCache中</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>缓存最近被访问的数据</li><li>预读功能</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>不适合读取大文件</li></ul><h3 id="大文件读取"><a href="#大文件读取" class="headerlink" title="大文件读取"></a>大文件读取</h3><p>异步IO + 直接IO方式</p><ul><li>用户进程发起异步IO请求获取数据</li><li>内核态中进行同步IO获取数据</li></ul>]]></content>
    
    
    <categories>
      
      <category>netty</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>netty-零拷贝</title>
    <link href="/2022/11/28/netty/zeroCopy/"/>
    <url>/2022/11/28/netty/zeroCopy/</url>
    
    <content type="html"><![CDATA[<h1 id="数据传输方式"><a href="#数据传输方式" class="headerlink" title="数据传输方式"></a>数据传输方式</h1><h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><p>用户进程发起一个读请求, 内核收到读请求后, 先查看内核空间中是否有存在的数据, 如果已经存在的话, 则直接将数据copy给进程的缓冲区.此时如果数据不存在的话, 则由内核向磁盘发起指令, 要求磁盘读取数据, 磁盘控制器直接把数据写入到内核中的READ缓冲区中, 通过DMA完成. 包含了两次切换<br>上下文切换次数  </p><ul><li>用户态 -&gt; 内核态</li><li>内核态度 -&gt; 用户态</li></ul><p>数据拷贝次数  </p><ul><li>将磁盘中数据copy到内核缓冲区中, 通过DMA 来完成</li><li>将内核缓冲区的数据copy到用户缓冲区中, 此时用户进程可以使用这部分数据, 由CPU完成</li></ul><h2 id="write"><a href="#write" class="headerlink" title="write"></a>write</h2><p>进程如果需要发送一个请求数据, 需要先将用户的缓冲区数据copy到内核的socket缓冲区中, 然后内核通过DMA将数据copy到网卡中, 完成发送<br>上下文切换次数  </p><ul><li>用户态 -&gt; 内核态  </li><li>内核态度 -&gt; 用户态数据</li></ul><p>数据拷贝次数</p><ul><li>将拷贝到用户缓冲区的数据copy到内核的socket 缓冲区中,由CPU完成</li><li>内核缓冲区的数据copy 到网卡的缓冲区中, 通过DMA来完成</li></ul><h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h2><p>在进行IO设备和数据传输的的时候, 数据搬运工作通过DMA控制器来完成, CPU 不负责去处理数据搬运的工作</p><h3 id="搬运过程"><a href="#搬运过程" class="headerlink" title="搬运过程"></a>搬运过程</h3><p>收到磁盘的信号, 将磁盘缓冲区中的数据copy到内核缓冲区中, 此时不再占用CPU资源, 等DMA 读取到了足够多的数据, 发送中断信号给CPU, CPU 收到DMA的信号后, 将内核中的数据copy 到用户空间中, 系统调用返回</p><h1 id="实现零拷贝"><a href="#实现零拷贝" class="headerlink" title="实现零拷贝"></a>实现零拷贝</h1><ul><li>mmap + write</li><li>sendfile</li></ul><h2 id="mmap-write"><a href="#mmap-write" class="headerlink" title="mmap(write)"></a>mmap(write)</h2><p>mmap 是一种文件映射的方法, 可以将一个文件或者其他对象的地址映射到<code>进程</code>的地址空间上, 可以用来减少<code>内核中READ缓冲区到用户缓冲区</code>的一次拷贝, 可以将内核READ缓冲区的数据直接写到内核的socket缓冲区中</p><ul><li>用户进程调用mmap, DMA会将数据copy到内核缓冲区中, 接着用户进程和内核进程共享该缓冲区  <ul><li>上下文切换  <ul><li>用户态 -&gt; 内核态</li><li>内核态 -&gt; 用户态</li></ul></li></ul></li><li>用户调用write方法, 将内核缓冲区的数据写到socket缓冲区中<ul><li>CPU 来将缓冲区数据copy 到 socket缓冲区中</li><li>上下文切换<ul><li>用户态 -&gt; 内核态</li></ul></li></ul></li><li>socket缓冲区数据中copy 到网卡中<ul><li>DMA 来操作完成</li><li>上下文切换<ul><li>内核态 -&gt; 用户态</li></ul></li></ul></li></ul><h2 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">sendfile</span><span class="hljs-params">(<span class="hljs-type">int</span> out_fd, <span class="hljs-type">int</span> in_fd, <span class="hljs-type">off_t</span> *offset, <span class="hljs-type">size_t</span> count)</span>;<br></code></pre></td></tr></table></figure><p>通过sendfile 函数来代理 read() write()函数, 可以降低系统调用, 将上下文切换从4次换成2次  </p><ul><li>用户进程调用sendfile</li><li>内核态收到sendfile 进行数据处理<ul><li>通过DMA 将数据写入到内核缓冲区</li><li>CPU 拷贝将内核缓冲区数据copy 到socket缓冲区</li><li>DMA 拷贝将socket缓冲区数据copy 到网卡上</li></ul></li><li>上下文切换<ul><li>用户态 -&gt; 内核态</li></ul></li><li>数据拷贝次数<ul><li>两次DMA 数据copy, 一次CPU 数据copy</li></ul></li></ul><h2 id="SG-DMA-技术"><a href="#SG-DMA-技术" class="headerlink" title="SG-DMA 技术"></a>SG-DMA 技术</h2><ul><li>用户进程调用sendfile</li><li>内核态收到sendfile 进行数据处理<ul><li>磁盘文件通过DMA copy 到缓冲区中</li><li>缓冲区描述符和数据长度传到socket缓冲区中, 此时SG-DMA控制器可以直接将内核缓冲区的数据copy 到网卡中, 此过程不需要将内核缓冲区的数据copy到socket缓冲区中</li></ul></li><li>上下文切换<ul><li>用户态 -&gt; 内核态</li><li>内核态 -&gt; 用户态</li></ul></li><li>数据拷贝次数<ul><li>两次DMA 数据copy</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>零拷贝指的是全程不需要CPU 进行参与, 所有数据都是通过DMA来进行传输的</li><li>全程只需要2次上下文切换, 2次DMA数据copy</li></ul>]]></content>
    
    
    <categories>
      
      <category>netty</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>zk 集群方式启动选举</title>
    <link href="/2022/11/22/zk/groupMode/"/>
    <url>/2022/11/22/zk/groupMode/</url>
    
    <content type="html"><![CDATA[<h1 id="集群模式启动过程概览"><a href="#集群模式启动过程概览" class="headerlink" title="集群模式启动过程概览"></a>集群模式启动过程概览</h1><p>在集群模式当中指定的main方法为QuorumPeerMain</p><h2 id="读取配置文件"><a href="#读取配置文件" class="headerlink" title="读取配置文件"></a>读取配置文件</h2><p>读取指定的配置文件内容, 将配置文件内容转换成QuorumPeerConfig对象</p><ul><li>配置了三个端口<ul><li>面向客户端的端口  clientPort</li><li>用于数据同步的端口 server.1&#x3D;ip:synPort:electionPort</li><li>用于选举时的端口  server.1&#x3D;ip:synPort:electionPort</li></ul></li></ul><h2 id="开启定时脚本清除"><a href="#开启定时脚本清除" class="headerlink" title="开启定时脚本清除"></a>开启定时脚本清除</h2><p>对log 以及 snapshot 目录下的文件可以通过配置的方式开启定时清除</p><h2 id="开始入口"><a href="#开始入口" class="headerlink" title="开始入口"></a>开始入口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runFromConfig</span><span class="hljs-params">(QuorumPeerConfig config)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>     <span class="hljs-keyword">try</span> &#123;<br>         ManagedUtil.registerLog4jMBeans();<br>     &#125; <span class="hljs-keyword">catch</span> (JMException e) &#123;<br>         LOG.warn(<span class="hljs-string">&quot;Unable to register log4j JMX control&quot;</span>, e);<br>     &#125;<br><br>     LOG.info(<span class="hljs-string">&quot;Starting quorum peer&quot;</span>);<br>     <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-type">ServerCnxnFactory</span> <span class="hljs-variable">cnxnFactory</span> <span class="hljs-operator">=</span> ServerCnxnFactory.createFactory();<br>         cnxnFactory.configure(config.getClientPortAddress(),<br>                 config.getMaxClientCnxns());<br><br>         quorumPeer = getQuorumPeer();<br><br>         quorumPeer.setQuorumPeers(config.getServers());<br>         quorumPeer.setTxnFactory(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileTxnSnapLog</span>(<br>                 <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(config.getDataDir()),<br>                 <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(config.getDataLogDir())));<br>         quorumPeer.setElectionType(config.getElectionAlg());<br>         quorumPeer.setMyid(config.getServerId());<br>         quorumPeer.setTickTime(config.getTickTime());<br>         quorumPeer.setInitLimit(config.getInitLimit());<br>         quorumPeer.setSyncLimit(config.getSyncLimit());<br>         quorumPeer.setQuorumListenOnAllIPs(config.getQuorumListenOnAllIPs());<br>         quorumPeer.setCnxnFactory(cnxnFactory);<br>         quorumPeer.setQuorumVerifier(config.getQuorumVerifier());<br>         quorumPeer.setClientPortAddress(config.getClientPortAddress());<br>         quorumPeer.setMinSessionTimeout(config.getMinSessionTimeout());<br>         quorumPeer.setMaxSessionTimeout(config.getMaxSessionTimeout());<br>         quorumPeer.setZKDatabase(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ZKDatabase</span>(quorumPeer.getTxnFactory()));<br>         quorumPeer.setLearnerType(config.getPeerType());<br>         quorumPeer.setSyncEnabled(config.getSyncEnabled());<br><br>         <span class="hljs-comment">// sets quorum sasl authentication configurations</span><br>         quorumPeer.setQuorumSaslEnabled(config.quorumEnableSasl);<br>         <span class="hljs-keyword">if</span> (quorumPeer.isQuorumSaslAuthEnabled()) &#123;<br>             quorumPeer.setQuorumServerSaslRequired(config.quorumServerRequireSasl);<br>             quorumPeer.setQuorumLearnerSaslRequired(config.quorumLearnerRequireSasl);<br>             quorumPeer.setQuorumServicePrincipal(config.quorumServicePrincipal);<br>             quorumPeer.setQuorumServerLoginContext(config.quorumServerLoginContext);<br>             quorumPeer.setQuorumLearnerLoginContext(config.quorumLearnerLoginContext);<br>         &#125;<br><br>         quorumPeer.setQuorumCnxnThreadsSize(config.quorumCnxnThreadsSize);<br>         quorumPeer.initialize();<br><br>         quorumPeer.start();<br>         quorumPeer.join();<br>     &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>         <span class="hljs-comment">// warn, but generally this is ok</span><br>         LOG.warn(<span class="hljs-string">&quot;Quorum Peer interrupted&quot;</span>, e);<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><ul><li>ServerCnxnFactory 默认使用NIOServerCnxnFactory</li><li>NIOServerCnxnFactory 配置好面向客户端使用的端口和最大连接数</li></ul><h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>    loadDataBase();<br>    cnxnFactory.start();        <br>    startLeaderElection();<br>    <span class="hljs-built_in">super</span>.start();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="加载缓存数据"><a href="#加载缓存数据" class="headerlink" title="加载缓存数据"></a>加载缓存数据</h3><h3 id="bind客户端监听端口"><a href="#bind客户端监听端口" class="headerlink" title="bind客户端监听端口"></a>bind客户端监听端口</h3><h3 id="投票前准备好数据-绑定选举的端口"><a href="#投票前准备好数据-绑定选举的端口" class="headerlink" title="投票前准备好数据, 绑定选举的端口"></a>投票前准备好数据, 绑定选举的端口</h3><p><img src="/img/zk/select.jpg"><br>选举算法配置参数为electionAlg,默认为3,因此采用 QuorumCnxManager</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Election <span class="hljs-title function_">createElectionAlgorithm</span><span class="hljs-params">(<span class="hljs-type">int</span> electionAlgorithm)</span>&#123;<br>    Election le=<span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> use a factory rather than a switch</span><br>    <span class="hljs-keyword">switch</span> (electionAlgorithm) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>        le = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LeaderElection</span>(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        le = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AuthFastLeaderElection</span>(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        le = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AuthFastLeaderElection</span>(<span class="hljs-built_in">this</span>, <span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>        qcm = createCnxnManager();<br>        QuorumCnxManager.<span class="hljs-type">Listener</span> <span class="hljs-variable">listener</span> <span class="hljs-operator">=</span> qcm.listener;<br>        <span class="hljs-keyword">if</span>(listener != <span class="hljs-literal">null</span>)&#123;<br>            listener.start();<br>            le = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FastLeaderElection</span>(<span class="hljs-built_in">this</span>, qcm);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            LOG.error(<span class="hljs-string">&quot;Null listener when initializing cnx manager&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">assert</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> le;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="绑定选举端口"><a href="#绑定选举端口" class="headerlink" title="绑定选举端口"></a>绑定选举端口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">numRetries</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>     InetSocketAddress addr;<br>     <span class="hljs-keyword">while</span>((!shutdown) &amp;&amp; (numRetries &lt; <span class="hljs-number">3</span>))&#123;<br>         <span class="hljs-keyword">try</span> &#123;<br>             ss = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>();<br>             ss.setReuseAddress(<span class="hljs-literal">true</span>);<br>             <span class="hljs-keyword">if</span> (listenOnAllIPs) &#123;<br>                 <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> view.get(QuorumCnxManager.<span class="hljs-built_in">this</span>.mySid)<br>                     .electionAddr.getPort();<br>                 addr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(port);<br>             &#125; <span class="hljs-keyword">else</span> &#123;<br>                 addr = view.get(QuorumCnxManager.<span class="hljs-built_in">this</span>.mySid)<br>                     .electionAddr;<br>             &#125;<br>             LOG.info(<span class="hljs-string">&quot;My election bind port: &quot;</span> + addr.toString());<br>             setName(view.get(QuorumCnxManager.<span class="hljs-built_in">this</span>.mySid)<br>                     .electionAddr.toString());<br>             ss.bind(addr);<br>             <span class="hljs-keyword">while</span> (!shutdown) &#123;<br>                 <span class="hljs-type">Socket</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> ss.accept();<br>                 setSockOpts(client);<br>                 LOG.info(<span class="hljs-string">&quot;Received connection request &quot;</span><br>                         + client.getRemoteSocketAddress());<br><br>                 <span class="hljs-comment">// Receive and handle the connection request</span><br>                 <span class="hljs-comment">// asynchronously if the quorum sasl authentication is</span><br>                 <span class="hljs-comment">// enabled. This is required because sasl server</span><br>                 <span class="hljs-comment">// authentication process may take few seconds to finish,</span><br>                 <span class="hljs-comment">// this may delay next peer connection requests.</span><br>                 <span class="hljs-keyword">if</span> (quorumSaslAuthEnabled) &#123;<br>                     receiveConnectionAsync(client);<br>                 &#125; <span class="hljs-keyword">else</span> &#123;<br>                     receiveConnection(client);<br>                 &#125;<br><br>                 numRetries = <span class="hljs-number">0</span>;<br>             &#125;<br>         &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>             LOG.error(<span class="hljs-string">&quot;Exception while listening&quot;</span>, e);<br>             numRetries++;<br>             <span class="hljs-keyword">try</span> &#123;<br>                 ss.close();<br>                 Thread.sleep(<span class="hljs-number">1000</span>);<br>             &#125; <span class="hljs-keyword">catch</span> (IOException ie) &#123;<br>                 LOG.error(<span class="hljs-string">&quot;Error closing server socket&quot;</span>, ie);<br>             &#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;<br>                 LOG.error(<span class="hljs-string">&quot;Interrupted while sleeping. &quot;</span> +<br>                           <span class="hljs-string">&quot;Ignoring exception&quot;</span>, ie);<br>             &#125;<br>         &#125;<br>     &#125;<br>     LOG.info(<span class="hljs-string">&quot;Leaving listener&quot;</span>);<br>     <span class="hljs-keyword">if</span> (!shutdown) &#123;<br>         LOG.error(<span class="hljs-string">&quot;As I&#x27;m leaving the listener thread, &quot;</span><br>                 + <span class="hljs-string">&quot;I won&#x27;t be able to participate in leader &quot;</span><br>                 + <span class="hljs-string">&quot;election any longer: &quot;</span><br>                 + view.get(QuorumCnxManager.<span class="hljs-built_in">this</span>.mySid).electionAddr);<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h4 id="处理接受到的请求"><a href="#处理接受到的请求" class="headerlink" title="处理接受到的请求"></a>处理接受到的请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//If wins the challenge, then close the new connection.</span><br> <span class="hljs-comment">//保证只有sid大的发给小的</span><br> <span class="hljs-keyword">if</span> (sid &lt; <span class="hljs-built_in">this</span>.mySid) &#123;<br>     <span class="hljs-comment">/*</span><br><span class="hljs-comment">      * This replica might still believe that the connection to sid is</span><br><span class="hljs-comment">      * up, so we have to shut down the workers before trying to open a</span><br><span class="hljs-comment">      * new connection.</span><br><span class="hljs-comment">      */</span><br>     <span class="hljs-type">SendWorker</span> <span class="hljs-variable">sw</span> <span class="hljs-operator">=</span> senderWorkerMap.get(sid);<br>     <span class="hljs-keyword">if</span> (sw != <span class="hljs-literal">null</span>) &#123;<br>         sw.finish();<br>     &#125;<br><br>     <span class="hljs-comment">/*</span><br><span class="hljs-comment">      * Now we start a new connection</span><br><span class="hljs-comment">      */</span><br>     LOG.debug(<span class="hljs-string">&quot;Create new connection to server: &quot;</span> + sid);<br>     closeSocket(sock);<br>     connectOne(sid);<br><br>     <span class="hljs-comment">// Otherwise start worker threads to receive data.</span><br> &#125; <span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-comment">//sendWorker 绑定socket</span><br>     <span class="hljs-type">SendWorker</span> <span class="hljs-variable">sw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SendWorker</span>(sock, sid);<br>     <span class="hljs-comment">//recvWorker 绑定socket</span><br>     <span class="hljs-type">RecvWorker</span> <span class="hljs-variable">rw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RecvWorker</span>(sock, din, sid, sw);<br>     sw.setRecv(rw);<br><br>     <span class="hljs-type">SendWorker</span> <span class="hljs-variable">vsw</span> <span class="hljs-operator">=</span> senderWorkerMap.get(sid);<br>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">      * 如果以前有绑定过相同的sid, 则将以前的sendWorker进行下掉</span><br><span class="hljs-comment">      * 由于关联了recvWorker, 在进行finish的同时,recvWorker也会结束</span><br><span class="hljs-comment">      */</span><br>     <span class="hljs-keyword">if</span>(vsw != <span class="hljs-literal">null</span>)<br>         vsw.finish();<br><br>     senderWorkerMap.put(sid, sw);<br>     queueSendMap.putIfAbsent(sid, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;ByteBuffer&gt;(SEND_CAPACITY));<br><br>     sw.start();<br>     rw.start();<br><br>     <span class="hljs-keyword">return</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="zk选举发送接收线程概览"><a href="#zk选举发送接收线程概览" class="headerlink" title="zk选举发送接收线程概览"></a>zk选举发送接收线程概览</h4><p><img src="/img/zk/send.recv.dispose.thrad.jpg"></p><ul><li>通过sendWorker、recvWorker、WorkerSender、WorkerReceiver去处理发送 选举时的相关请求</li></ul><h5 id="sendWorker"><a href="#sendWorker" class="headerlink" title="sendWorker"></a>sendWorker</h5><p>用于选举投票时发送数据</p><h6 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">SendWorker(Socket sock, Long sid) &#123;<br>    <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;SendWorker:&quot;</span> + sid);<br>    <span class="hljs-built_in">this</span>.sid = sid;<br>    <span class="hljs-built_in">this</span>.sock = sock;<br>    recvWorker = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        dout = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(sock.getOutputStream());<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        LOG.error(<span class="hljs-string">&quot;Unable to access socket output stream&quot;</span>, e);<br>        closeSocket(sock);<br>        running = <span class="hljs-literal">false</span>;<br>    &#125;<br>    LOG.debug(<span class="hljs-string">&quot;Address of remote peer: &quot;</span> + <span class="hljs-built_in">this</span>.sid);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>绑定socket 连接</li><li>绑定svrId</li></ul><h6 id="主要处理内容"><a href="#主要处理内容" class="headerlink" title="主要处理内容"></a>主要处理内容</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    threadCnt.incrementAndGet();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * If there is nothing in the queue to send, then we</span><br><span class="hljs-comment">         * send the lastMessage to ensure that the last message</span><br><span class="hljs-comment">         * was received by the peer. The message could be dropped</span><br><span class="hljs-comment">         * in case self or the peer shutdown their connection</span><br><span class="hljs-comment">         * (and exit the thread) prior to reading/processing</span><br><span class="hljs-comment">         * the last message. Duplicate messages are handled correctly</span><br><span class="hljs-comment">         * by the peer.</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * If the send queue is non-empty, then we have a recent</span><br><span class="hljs-comment">         * message than that stored in lastMessage. To avoid sending</span><br><span class="hljs-comment">         * stale message, we should send the message in the send queue.</span><br><span class="hljs-comment">         */</span><br>        ArrayBlockingQueue&lt;ByteBuffer&gt; bq = queueSendMap.get(sid);<br>        <span class="hljs-keyword">if</span> (bq == <span class="hljs-literal">null</span> || isSendQueueEmpty(bq)) &#123;<br>           <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> lastMessageSent.get(sid);<br>           <span class="hljs-keyword">if</span> (b != <span class="hljs-literal">null</span>) &#123;<br>               LOG.debug(<span class="hljs-string">&quot;Attempting to send lastMessage to sid=&quot;</span> + sid);<br>               send(b);<br>           &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        LOG.error(<span class="hljs-string">&quot;Failed to send last message. Shutting down thread.&quot;</span>, e);<br>        <span class="hljs-built_in">this</span>.finish();<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (running &amp;&amp; !shutdown &amp;&amp; sock != <span class="hljs-literal">null</span>) &#123;<br><br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//通过sid从queueSendMap获取需要发送的数据, 选举时需要给外部发送请求的数据放在该队列里面</span><br>                ArrayBlockingQueue&lt;ByteBuffer&gt; bq = queueSendMap<br>                        .get(sid);<br>                <span class="hljs-keyword">if</span> (bq != <span class="hljs-literal">null</span>) &#123;<br>                    b = pollSendQueue(bq, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    LOG.error(<span class="hljs-string">&quot;No queue of incoming messages for &quot;</span> +<br>                              <span class="hljs-string">&quot;server &quot;</span> + sid);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span>(b != <span class="hljs-literal">null</span>)&#123;<br>                    lastMessageSent.put(sid, b);<br>                    <span class="hljs-comment">//发送数据</span><br>                    send(b);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                LOG.warn(<span class="hljs-string">&quot;Interrupted while waiting for message on queue&quot;</span>,<br>                        e);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        LOG.warn(<span class="hljs-string">&quot;Exception when using channel: for id &quot;</span> + sid<br>                 + <span class="hljs-string">&quot; my id = &quot;</span> + QuorumCnxManager.<span class="hljs-built_in">this</span>.mySid<br>                 + <span class="hljs-string">&quot; error = &quot;</span> + e);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.finish();<br>    LOG.warn(<span class="hljs-string">&quot;Send worker leaving thread&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>sendWorker 就是通过queueSendMap 获取到数据, 然后将数据进行发送</li><li>lastMessageSent 是为了防止接收方接受到消息之前或者处理消息是不可用了, 则进行重复发送, 同时接收方接受到同样的消息时, 需要进行处理</li></ul><p>####### send逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(ByteBuffer b)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">byte</span>[] msgBytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[b.capacity()];<br>    <span class="hljs-keyword">try</span> &#123;<br>        b.position(<span class="hljs-number">0</span>);<br>        b.get(msgBytes);<br>    &#125; <span class="hljs-keyword">catch</span> (BufferUnderflowException be) &#123;<br>        LOG.error(<span class="hljs-string">&quot;BufferUnderflowException &quot;</span>, be);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    dout.writeInt(b.capacity());<br>    dout.write(b.array());<br>    dout.flush();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="recvWorker"><a href="#recvWorker" class="headerlink" title="recvWorker"></a>recvWorker</h5><p>用于选举投票时处理接受请求并处理数据</p><h6 id="构造-1"><a href="#构造-1" class="headerlink" title="构造"></a>构造</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">RecvWorker(Socket sock, DataInputStream din, Long sid, SendWorker sw) &#123;<br>    <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;RecvWorker:&quot;</span> + sid);<br>    <span class="hljs-built_in">this</span>.sid = sid;<br>    <span class="hljs-built_in">this</span>.sock = sock;<br>    <span class="hljs-built_in">this</span>.sw = sw;<br>    <span class="hljs-built_in">this</span>.din = din;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// OK to wait until socket disconnects while reading.</span><br>        sock.setSoTimeout(<span class="hljs-number">0</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        LOG.error(<span class="hljs-string">&quot;Error while accessing socket for &quot;</span> + sid, e);<br>        closeSocket(sock);<br>        running = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="run"><a href="#run" class="headerlink" title="run"></a>run</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    threadCnt.incrementAndGet();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (running &amp;&amp; !shutdown &amp;&amp; sock != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * Reads the first int to determine the length of the</span><br><span class="hljs-comment">             * message</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> din.readInt();<br>            <span class="hljs-keyword">if</span> (length &lt;= <span class="hljs-number">0</span> || length &gt; PACKETMAXSIZE) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<br>                        <span class="hljs-string">&quot;Received packet with invalid packet: &quot;</span><br>                                + length);<br>            &#125;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * Allocates a new ByteBuffer to receive the message</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-type">byte</span>[] msgArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[length];<br>            din.readFully(msgArray, <span class="hljs-number">0</span>, length);<br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(msgArray);<br>            addToRecvQueue(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(message.duplicate(), sid));<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        LOG.warn(<span class="hljs-string">&quot;Connection broken for id &quot;</span> + sid + <span class="hljs-string">&quot;, my id = &quot;</span><br>                 + QuorumCnxManager.<span class="hljs-built_in">this</span>.mySid + <span class="hljs-string">&quot;, error = &quot;</span> , e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        LOG.warn(<span class="hljs-string">&quot;Interrupting SendWorker&quot;</span>);<br>        sw.finish();<br>        <span class="hljs-keyword">if</span> (sock != <span class="hljs-literal">null</span>) &#123;<br>            closeSocket(sock);<br>        &#125;<br>    &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>处理接受到的请求数据, 将接受到的请求数据放到recvQueue 中</li></ul><h6 id="addToRecvQueue"><a href="#addToRecvQueue" class="headerlink" title="addToRecvQueue"></a>addToRecvQueue</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addToRecvQueue</span><span class="hljs-params">(Message msg)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span>(recvQLock) &#123;<br>        <span class="hljs-keyword">if</span> (recvQueue.remainingCapacity() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                recvQueue.remove();<br>            &#125; <span class="hljs-keyword">catch</span> (NoSuchElementException ne) &#123;<br>                <span class="hljs-comment">// element could be removed by poll()</span><br>                 LOG.debug(<span class="hljs-string">&quot;Trying to remove from an empty &quot;</span> +<br>                     <span class="hljs-string">&quot;recvQueue. Ignoring exception &quot;</span> + ne);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            recvQueue.add(msg);<br>        &#125; <span class="hljs-keyword">catch</span> (IllegalStateException ie) &#123;<br>            <span class="hljs-comment">// This should never happen</span><br>            LOG.error(<span class="hljs-string">&quot;Unable to insert element in the recvQueue &quot;</span> + ie);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果接受到的队列满了, 则删除队首元素, 在往recvQueue 去添加数据</li></ul><h5 id="WorkerSender"><a href="#WorkerSender" class="headerlink" title="WorkerSender"></a>WorkerSender</h5><h6 id="构造-2"><a href="#构造-2" class="headerlink" title="构造"></a>构造</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">WorkerSender(QuorumCnxManager manager)&#123;<br>    <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;WorkerSender&quot;</span>);<br>    <span class="hljs-built_in">this</span>.stop = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">this</span>.manager = manager;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="处理逻辑"><a href="#处理逻辑" class="headerlink" title="处理逻辑"></a>处理逻辑</h6><p>####### 从sendQueue中获取数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">while</span> (!stop) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ToSend</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> sendqueue.poll(<span class="hljs-number">3000</span>, TimeUnit.MILLISECONDS);<br>            <span class="hljs-keyword">if</span>(m == <span class="hljs-literal">null</span>) <span class="hljs-keyword">continue</span>;<br><br>            process(m);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    LOG.info(<span class="hljs-string">&quot;WorkerSender is down&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>####### 处理消息并发送</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(ToSend m)</span> &#123;<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">requestBuffer</span> <span class="hljs-operator">=</span> buildMsg(m.state.ordinal(),<br>                                            m.leader,<br>                                            m.zxid,<br>                                            m.electionEpoch,<br>                                            m.peerEpoch);<br>    manager.toSend(m.sid, requestBuffer);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">toSend</span><span class="hljs-params">(Long sid, ByteBuffer b)</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * If sending message to myself, then simply enqueue it (loopback).</span><br><span class="hljs-comment">     * 如果是要发送给自己的, 则将内容直接放到接收队列中去</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.mySid == sid) &#123;<br>         b.position(<span class="hljs-number">0</span>);<br>         addToRecvQueue(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(b.duplicate(), sid));<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Otherwise send to the corresponding thread to send.</span><br><span class="hljs-comment">         */</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-comment">/*</span><br><span class="hljs-comment">          * Start a new connection if doesn&#x27;t have one already.</span><br><span class="hljs-comment">          * 查看对方id 是否存在要发送的缓存queue, 如果没有的话, 创建一个新的queue, 已经有的话往缓存queue中添加数据,</span><br><span class="hljs-comment">          *  worker 则从queueSendMap中获取对应的数据去进行消费</span><br><span class="hljs-comment">          */</span><br>         ArrayBlockingQueue&lt;ByteBuffer&gt; bq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;ByteBuffer&gt;(SEND_CAPACITY);<br>         ArrayBlockingQueue&lt;ByteBuffer&gt; bqExisting = queueSendMap.putIfAbsent(sid, bq);<br>         <span class="hljs-keyword">if</span> (bqExisting != <span class="hljs-literal">null</span>) &#123;<br>             addToSendQueue(bqExisting, b);<br>         &#125; <span class="hljs-keyword">else</span> &#123;<br>             addToSendQueue(bq, b);<br>         &#125;<br>         connectOne(sid);<br><br>    &#125;<br>&#125;<br>...<br><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connectOne</span><span class="hljs-params">(<span class="hljs-type">long</span> sid)</span>&#123;<br>  <span class="hljs-keyword">if</span> (!connectedToPeer(sid))&#123;<br>    ...<br>    <span class="hljs-type">Socket</span> <span class="hljs-variable">sock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>();<br>    setSockOpts(sock);<br>    sock.connect(view.get(sid).electionAddr, cnxTO);<br>    ...<br>    initiateConnection(sock, sid);  <br>    ...<br>  &#125;  <br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initiateConnection</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Socket sock, <span class="hljs-keyword">final</span> Long sid)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        startConnection(sock, sid);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        ...<br>    &#125;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startConnection</span><span class="hljs-params">(Socket sock, Long sid)</span><br>            <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">dout</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">DataInputStream</span> <span class="hljs-variable">din</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// Sending id and challenge</span><br>        dout = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(sock.getOutputStream());<br>        dout.writeLong(<span class="hljs-built_in">this</span>.mySid);<br>        dout.flush();<br><br>        din = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(sock.getInputStream()));<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        LOG.warn(<span class="hljs-string">&quot;Ignoring exception reading or writing challenge: &quot;</span>, e);<br>        closeSocket(sock);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;   <br>    <span class="hljs-keyword">if</span> (sid &gt; <span class="hljs-built_in">this</span>.mySid) &#123;<br>        LOG.info(<span class="hljs-string">&quot;Have smaller server identifier, so dropping the &quot;</span> +<br>                 <span class="hljs-string">&quot;connection: (&quot;</span> + sid + <span class="hljs-string">&quot;, &quot;</span> + <span class="hljs-built_in">this</span>.mySid + <span class="hljs-string">&quot;)&quot;</span>);<br>        closeSocket(sock);<br>        <span class="hljs-comment">// Otherwise proceed with the connection</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">SendWorker</span> <span class="hljs-variable">sw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SendWorker</span>(sock, sid);<br>        <span class="hljs-type">RecvWorker</span> <span class="hljs-variable">rw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RecvWorker</span>(sock, din, sid, sw);<br>        sw.setRecv(rw);<br><br>        <span class="hljs-type">SendWorker</span> <span class="hljs-variable">vsw</span> <span class="hljs-operator">=</span> senderWorkerMap.get(sid);<br><br>        <span class="hljs-keyword">if</span>(vsw != <span class="hljs-literal">null</span>)<br>            vsw.finish();<br><br>        senderWorkerMap.put(sid, sw);<br>        queueSendMap.putIfAbsent(sid, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;ByteBuffer&gt;(SEND_CAPACITY));<br><br>        sw.start();<br>        rw.start();<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>根据要接受方的sid 从queueSendMap中查看是否有发送的消息队列<ul><li>没有则创建, 将需要发送的数据放到队列中</li><li>有的话, 则用已有的队列去进行获取发送</li></ul></li><li>根据sid 查看和对方是有有sendWorker线程, 该线程会一直去消费queueSendMap 中的消息队列<ul><li>sendWorker 会由于对方请求断了, 从而将线程给中断</li></ul></li><li>如果没有的话创建和对方的连接<ul><li>如果自己的对方的id 比自己的大的话, 则关闭连接, sid大的给小的去发送请求</li><li>创建sendWorker 和 recvWorker 线程, 两个线程绑定对应的socket</li></ul></li></ul><h5 id="WorkerReceiver"><a href="#WorkerReceiver" class="headerlink" title="WorkerReceiver"></a>WorkerReceiver</h5><h6 id="构造-3"><a href="#构造-3" class="headerlink" title="构造"></a>构造</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">WorkerReceiver(QuorumCnxManager manager) &#123;<br>    <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;WorkerReceiver&quot;</span>);<br>    <span class="hljs-built_in">this</span>.stop = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">this</span>.manager = manager;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br>     Message response;<br>     <span class="hljs-keyword">while</span> (!stop) &#123;<br>         <span class="hljs-comment">// Sleeps on receive</span><br>         <span class="hljs-keyword">try</span>&#123;<br>             <span class="hljs-comment">//从qcm中获取响应</span><br>             response = manager.pollRecvQueue(<span class="hljs-number">3000</span>, TimeUnit.MILLISECONDS);<br>             <span class="hljs-keyword">if</span>(response == <span class="hljs-literal">null</span>) <span class="hljs-keyword">continue</span>;<br><br>             <span class="hljs-comment">/*</span><br><span class="hljs-comment">              * If it is from an observer, respond right away.</span><br><span class="hljs-comment">              * Note that the following predicate assumes that</span><br><span class="hljs-comment">              * if a server is not a follower, then it must be</span><br><span class="hljs-comment">              * an observer. If we ever have any other type of</span><br><span class="hljs-comment">              * learner in the future, we&#x27;ll have to change the</span><br><span class="hljs-comment">              * way we check for observers.</span><br><span class="hljs-comment">              * 如果请求是来自于observer则立马进行响应, 因为observer 不需要进行选举投票</span><br><span class="hljs-comment">              */</span><br>             <span class="hljs-keyword">if</span>(!self.getVotingView().containsKey(response.sid))&#123;<br>                 <span class="hljs-type">Vote</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> self.getCurrentVote();<br>                 <span class="hljs-type">ToSend</span> <span class="hljs-variable">notmsg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ToSend</span>(ToSend.mType.notification,<br>                         current.getId(),<br>                         current.getZxid(),<br>                         logicalclock.get(),<br>                         self.getPeerState(),<br>                         response.sid,<br>                         current.getPeerEpoch());<br><br>                 sendqueue.offer(notmsg);<br>             &#125; <span class="hljs-keyword">else</span> &#123;<br>                 <span class="hljs-comment">// Receive new message</span><br>                 <span class="hljs-keyword">if</span> (LOG.isDebugEnabled()) &#123;<br>                     LOG.debug(<span class="hljs-string">&quot;Receive new notification message. My id = &quot;</span><br>                             + self.getId());<br>                 &#125;<br><br>                 <span class="hljs-comment">/*</span><br><span class="hljs-comment">                  * We check for 28 bytes for backward compatibility</span><br><span class="hljs-comment">                  */</span><br>                 <span class="hljs-keyword">if</span> (response.buffer.capacity() &lt; <span class="hljs-number">28</span>) &#123;<br>                     LOG.error(<span class="hljs-string">&quot;Got a short response: &quot;</span><br>                             + response.buffer.capacity());<br>                     <span class="hljs-keyword">continue</span>;<br>                 &#125;<br>                 <span class="hljs-type">boolean</span> <span class="hljs-variable">backCompatibility</span> <span class="hljs-operator">=</span> (response.buffer.capacity() == <span class="hljs-number">28</span>);<br>                 response.buffer.clear();<br><br>                 <span class="hljs-comment">// Instantiate Notification and set its attributes</span><br>                 <span class="hljs-type">Notification</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Notification</span>();<br><br>                 <span class="hljs-comment">// State of peer that sent this message</span><br>                 QuorumPeer.<span class="hljs-type">ServerState</span> <span class="hljs-variable">ackstate</span> <span class="hljs-operator">=</span> QuorumPeer.ServerState.LOOKING;<br>                 <span class="hljs-keyword">switch</span> (response.buffer.getInt()) &#123;<br>                 <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                     ackstate = QuorumPeer.ServerState.LOOKING;<br>                     <span class="hljs-keyword">break</span>;<br>                 <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                     ackstate = QuorumPeer.ServerState.FOLLOWING;<br>                     <span class="hljs-keyword">break</span>;<br>                 <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                     ackstate = QuorumPeer.ServerState.LEADING;<br>                     <span class="hljs-keyword">break</span>;<br>                 <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                     ackstate = QuorumPeer.ServerState.OBSERVING;<br>                     <span class="hljs-keyword">break</span>;<br>                 <span class="hljs-keyword">default</span>:<br>                     <span class="hljs-keyword">continue</span>;<br>                 &#125;<br><br>                 n.leader = response.buffer.getLong();<br>                 n.zxid = response.buffer.getLong();<br>                 n.electionEpoch = response.buffer.getLong();<br>                 n.state = ackstate;<br>                 n.sid = response.sid;<br>                 <span class="hljs-keyword">if</span>(!backCompatibility)&#123;<br>                     n.peerEpoch = response.buffer.getLong();<br>                 &#125; <span class="hljs-keyword">else</span> &#123;<br>                     <span class="hljs-keyword">if</span>(LOG.isInfoEnabled())&#123;<br>                         LOG.info(<span class="hljs-string">&quot;Backward compatibility mode, server id=&quot;</span> + n.sid);<br>                     &#125;<br>                     n.peerEpoch = ZxidUtils.getEpochFromZxid(n.zxid);<br>                 &#125;<br><br>                 <span class="hljs-comment">/*</span><br><span class="hljs-comment">                  * Version added in 3.4.6</span><br><span class="hljs-comment">                  */</span><br><br>                 n.version = (response.buffer.remaining() &gt;= <span class="hljs-number">4</span>) ?<br>                              response.buffer.getInt() : <span class="hljs-number">0x0</span>;<br><br>                 <span class="hljs-comment">/*</span><br><span class="hljs-comment">                  * Print notification info</span><br><span class="hljs-comment">                  */</span><br>                 <span class="hljs-keyword">if</span>(LOG.isInfoEnabled())&#123;<br>                     printNotification(n);<br>                 &#125;<br><br>                 <span class="hljs-comment">/*</span><br><span class="hljs-comment">                  * If this server is looking, then send proposed leader</span><br><span class="hljs-comment">                  * 当前机器的状态是LOIOKING, 则将收到的响应加入到recvQueue中, 用于参与投票选举</span><br><span class="hljs-comment">                  */</span><br><br>                 <span class="hljs-keyword">if</span>(self.getPeerState() == QuorumPeer.ServerState.LOOKING)&#123;<br>                     recvqueue.offer(n);<br><br>                     <span class="hljs-comment">/*</span><br><span class="hljs-comment">                      * Send a notification back if the peer that sent this</span><br><span class="hljs-comment">                      * message is also looking and its logical clock is</span><br><span class="hljs-comment">                      * lagging behind.</span><br><span class="hljs-comment">                      * 如果对方的状态也是LOOKING 并且自己的epoch 要比对方的大</span><br><span class="hljs-comment">                      *  则将当前自己认为的投票对象响应回去</span><br><span class="hljs-comment">                      */</span><br>                     <span class="hljs-keyword">if</span>((ackstate == QuorumPeer.ServerState.LOOKING)<br>                             &amp;&amp; (n.electionEpoch &lt; logicalclock.get()))&#123;<br>                         <span class="hljs-type">Vote</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> getVote();<br>                         <span class="hljs-type">ToSend</span> <span class="hljs-variable">notmsg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ToSend</span>(ToSend.mType.notification,<br>                                 v.getId(),<br>                                 v.getZxid(),<br>                                 logicalclock.get(),<br>                                 self.getPeerState(),<br>                                 response.sid,<br>                                 v.getPeerEpoch());<br>                         sendqueue.offer(notmsg);<br>                     &#125;<br>                 &#125; <span class="hljs-keyword">else</span> &#123;<br>                     <span class="hljs-comment">/*</span><br><span class="hljs-comment">                      * If this server is not looking, but the one that sent the ack</span><br><span class="hljs-comment">                      * is looking, then send back what it believes to be the leader.</span><br><span class="hljs-comment">                      * 如果ack 回来的状态是LOOKING 则将当前机器认为的leader状态进行响应, 数据放到sendQueue中</span><br><span class="hljs-comment">                      */</span><br>                     <span class="hljs-type">Vote</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> self.getCurrentVote();<br>                     <span class="hljs-keyword">if</span>(ackstate == QuorumPeer.ServerState.LOOKING)&#123;<br>                         <span class="hljs-keyword">if</span>(LOG.isDebugEnabled())&#123;<br>                             LOG.debug(<span class="hljs-string">&quot;Sending new notification. My id =  &quot;</span> +<br>                                     self.getId() + <span class="hljs-string">&quot; recipient=&quot;</span> +<br>                                     response.sid + <span class="hljs-string">&quot; zxid=0x&quot;</span> +<br>                                     Long.toHexString(current.getZxid()) +<br>                                     <span class="hljs-string">&quot; leader=&quot;</span> + current.getId());<br>                         &#125;<br><br>                         ToSend notmsg;<br>                         <span class="hljs-keyword">if</span>(n.version &gt; <span class="hljs-number">0x0</span>) &#123;<br>                             notmsg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ToSend</span>(<br>                                     ToSend.mType.notification,<br>                                     current.getId(),<br>                                     current.getZxid(),<br>                                     current.getElectionEpoch(),<br>                                     self.getPeerState(),<br>                                     response.sid,<br>                                     current.getPeerEpoch());<br><br>                         &#125; <span class="hljs-keyword">else</span> &#123;<br>                             <span class="hljs-type">Vote</span> <span class="hljs-variable">bcVote</span> <span class="hljs-operator">=</span> self.getBCVote();<br>                             notmsg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ToSend</span>(<br>                                     ToSend.mType.notification,<br>                                     bcVote.getId(),<br>                                     bcVote.getZxid(),<br>                                     bcVote.getElectionEpoch(),<br>                                     self.getPeerState(),<br>                                     response.sid,<br>                                     bcVote.getPeerEpoch());<br>                         &#125;<br>                         sendqueue.offer(notmsg);<br>                     &#125;<br>                 &#125;<br>             &#125;<br>         &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>             System.out.println(<span class="hljs-string">&quot;Interrupted Exception while waiting for new message&quot;</span> +<br>                     e.toString());<br>         &#125;<br>     &#125;<br>     LOG.info(<span class="hljs-string">&quot;WorkerReceiver is down&quot;</span>);<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="投票"><a href="#投票" class="headerlink" title="投票"></a>投票</h3><h4 id="更新自己的投票信息"><a href="#更新自己的投票信息" class="headerlink" title="更新自己的投票信息"></a>更新自己的投票信息</h4><ul><li>获取自己的id, zxId, epoch</li><li>给所有参与投票的svr<ul><li>内容为leaderId, zxId, epoch</li><li>将发送的信息放到sendqueue 缓存中<br><img src="/img/zk/election.jpg"></li></ul></li></ul><h4 id="选举逻辑"><a href="#选举逻辑" class="headerlink" title="选举逻辑"></a>选举逻辑</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Vote <span class="hljs-title function_">lookForLeader</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        self.jmxLeaderElectionBean = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LeaderElectionBean</span>();<br>        MBeanRegistry.getInstance().register(<br>                self.jmxLeaderElectionBean, self.jmxLocalPeerBean);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        LOG.warn(<span class="hljs-string">&quot;Failed to register with JMX&quot;</span>, e);<br>        self.jmxLeaderElectionBean = <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (self.start_fle == <span class="hljs-number">0</span>) &#123;<br>       self.start_fle = Time.currentElapsedTime();<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        HashMap&lt;Long, Vote&gt; recvset = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Long, Vote&gt;();<br><br>        HashMap&lt;Long, Vote&gt; outofelection = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Long, Vote&gt;();<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">notTimeout</span> <span class="hljs-operator">=</span> finalizeWait;<br><br>        <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>)&#123;<br>            logicalclock.incrementAndGet();<br>            updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());<br>        &#125;<br><br>        LOG.info(<span class="hljs-string">&quot;New election. My id =  &quot;</span> + self.getId() +<br>                <span class="hljs-string">&quot;, proposed zxid=0x&quot;</span> + Long.toHexString(proposedZxid));<br>        sendNotifications();<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Loop in which we exchange notifications until we find a leader</span><br><span class="hljs-comment">         */</span><br><br>        <span class="hljs-keyword">while</span> ((self.getPeerState() == ServerState.LOOKING) &amp;&amp;<br>                (!stop))&#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * Remove next notification from queue, times out after 2 times</span><br><span class="hljs-comment">             * the termination time</span><br><span class="hljs-comment">             * 从接受队列中获取内容</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-type">Notification</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> recvqueue.poll(notTimeout,<br>                    TimeUnit.MILLISECONDS);<br><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * Sends more notifications if haven&#x27;t received enough.</span><br><span class="hljs-comment">             * Otherwise processes new notification.</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">if</span>(n == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">if</span>(manager.haveDelivered())&#123;<br>                    sendNotifications();<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    manager.connectAll();<br>                &#125;<br><br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 * Exponential backoff</span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">tmpTimeOut</span> <span class="hljs-operator">=</span> notTimeout*<span class="hljs-number">2</span>;<br>                notTimeout = (tmpTimeOut &lt; maxNotificationInterval?<br>                        tmpTimeOut : maxNotificationInterval);<br>                LOG.info(<span class="hljs-string">&quot;Notification time out: &quot;</span> + notTimeout);<br>            &#125;<br>            <span class="hljs-comment">// 只对集群内的svrId进行处理</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(self.getVotingView().containsKey(n.sid)) &#123;<br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 * Only proceed if the vote comes from a replica in the</span><br><span class="hljs-comment">                 * voting view.</span><br><span class="hljs-comment">                 * 对方的状态是looking</span><br><span class="hljs-comment">                 *  对方的逻辑时钟比自己的大</span><br><span class="hljs-comment">                 *    更新逻辑时钟为对方的</span><br><span class="hljs-comment">                 *      确认是否可以进行更新选票(比较逻辑时钟、zxid、svrId), 可以的话将选票信息更新为对端的, 不行的话将选票信息设置为自己的</span><br><span class="hljs-comment">                 *    将自己的选票信息发送给其他svr节点</span><br><span class="hljs-comment">                 *  对方的逻辑时钟比自己的小</span><br><span class="hljs-comment">                 *     忽略</span><br><span class="hljs-comment">                 *     结束</span><br><span class="hljs-comment">                 *  对方的逻辑时钟和自己的相等</span><br><span class="hljs-comment">                 *     确认是否可以进行更新选票</span><br><span class="hljs-comment">                 *       可以的话更新选票信息, 然后通知给其他svr节点</span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-keyword">switch</span> (n.state) &#123;<br>                <span class="hljs-keyword">case</span> LOOKING:<br>                    <span class="hljs-comment">// If notification &gt; current, replace and send messages out</span><br>                    <span class="hljs-keyword">if</span> (n.electionEpoch &gt; logicalclock.get()) &#123;<br>                        logicalclock.set(n.electionEpoch);<br>                        recvset.clear();<br>                        <span class="hljs-keyword">if</span>(totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,<br>                                getInitId(), getInitLastLoggedZxid(), getPeerEpoch())) &#123;<br>                            updateProposal(n.leader, n.zxid, n.peerEpoch);<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            updateProposal(getInitId(),<br>                                    getInitLastLoggedZxid(),<br>                                    getPeerEpoch());<br>                        &#125;<br>                        sendNotifications();<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n.electionEpoch &lt; logicalclock.get()) &#123;<br>                        <span class="hljs-keyword">if</span>(LOG.isDebugEnabled())&#123;<br>                            LOG.debug(<span class="hljs-string">&quot;Notification election epoch is smaller than logicalclock. n.electionEpoch = 0x&quot;</span><br>                                    + Long.toHexString(n.electionEpoch)<br>                                    + <span class="hljs-string">&quot;, logicalclock=0x&quot;</span> + Long.toHexString(logicalclock.get()));<br>                        &#125;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,<br>                            proposedLeader, proposedZxid, proposedEpoch)) &#123;<br>                        updateProposal(n.leader, n.zxid, n.peerEpoch);<br>                        sendNotifications();<br>                    &#125;<br><br>                    <span class="hljs-keyword">if</span>(LOG.isDebugEnabled())&#123;<br>                        LOG.debug(<span class="hljs-string">&quot;Adding vote: from=&quot;</span> + n.sid +<br>                                <span class="hljs-string">&quot;, proposed leader=&quot;</span> + n.leader +<br>                                <span class="hljs-string">&quot;, proposed zxid=0x&quot;</span> + Long.toHexString(n.zxid) +<br>                                <span class="hljs-string">&quot;, proposed election epoch=0x&quot;</span> + Long.toHexString(n.electionEpoch));<br>                    &#125;<br><br>                    recvset.put(n.sid, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vote</span>(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));<br><br>                    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                     * 确定选票是否超过半数以上</span><br><span class="hljs-comment">                     *  如果发现超过半数以上的话</span><br><span class="hljs-comment">                     *      再次从recvQ中获取一下数据, 确定没有请求数据残留, 然后再去判断是否需要更新leader</span><br><span class="hljs-comment">                     *      无法再从recvQ中获取到数据, 然后看选举出来的id是否和自己相等, 相等的话自己就设置为leader, 不是的话, 自己设置为observer</span><br><span class="hljs-comment">                     *         或者是flower, 并将结果状态返回</span><br><span class="hljs-comment">                     */</span><br>                    <span class="hljs-keyword">if</span> (termPredicate(recvset,<br>                            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vote</span>(proposedLeader, proposedZxid,<br>                                    logicalclock.get(), proposedEpoch))) &#123;<br><br>                        <span class="hljs-comment">// Verify if there is any change in the proposed leader</span><br>                        <span class="hljs-keyword">while</span>((n = recvqueue.poll(finalizeWait,<br>                                TimeUnit.MILLISECONDS)) != <span class="hljs-literal">null</span>)&#123;<br>                            <span class="hljs-keyword">if</span>(totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,<br>                                    proposedLeader, proposedZxid, proposedEpoch))&#123;<br>                                recvqueue.put(n);<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br><br>                        <span class="hljs-comment">/*</span><br><span class="hljs-comment">                         * This predicate is true once we don&#x27;t read any new</span><br><span class="hljs-comment">                         * relevant message from the reception queue</span><br><span class="hljs-comment">                         */</span><br>                        <span class="hljs-keyword">if</span> (n == <span class="hljs-literal">null</span>) &#123;<br>                            self.setPeerState((proposedLeader == self.getId()) ?<br>                                    ServerState.LEADING: learningState());<br><br>                            <span class="hljs-type">Vote</span> <span class="hljs-variable">endVote</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vote</span>(proposedLeader,<br>                                                    proposedZxid,<br>                                                    logicalclock.get(),<br>                                                    proposedEpoch);<br>                            leaveInstance(endVote);<br>                            <span class="hljs-keyword">return</span> endVote;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> OBSERVING:<br>                    LOG.debug(<span class="hljs-string">&quot;Notification from observer: &quot;</span> + n.sid);<br>                    <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                     * 如果对方的状态是flower 或者是leader</span><br><span class="hljs-comment">                     *  比较对方的逻辑时钟和自己的逻辑时钟</span><br><span class="hljs-comment">                     *     相等的情况下去在收到looking响应的投票集合中是否获得半数以上的投票,</span><br><span class="hljs-comment">                     *          并且去校验收到响应的节点在flower 和 leader 集合中是否为leader, 是的话则对当前状态结果进行更新</span><br><span class="hljs-comment">                     *     如果当前节点不符合leader的判断, 则将当前节点加入到flower 和 leader的集合中中, 再次进行校验是否符合leader 角色</span><br><span class="hljs-comment">                     *</span><br><span class="hljs-comment">                     */</span><br>                <span class="hljs-keyword">case</span> FOLLOWING:<br>                <span class="hljs-keyword">case</span> LEADING:<br>                    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                     * Consider all notifications from the same epoch</span><br><span class="hljs-comment">                     * together.</span><br><span class="hljs-comment">                     */</span><br>                    <span class="hljs-keyword">if</span>(n.electionEpoch == logicalclock.get())&#123;<br>                        recvset.put(n.sid, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vote</span>(n.leader,<br>                                                      n.zxid,<br>                                                      n.electionEpoch,<br>                                                      n.peerEpoch));<br><br>                        <span class="hljs-keyword">if</span>(ooePredicate(recvset, outofelection, n)) &#123;<br>                            self.setPeerState((n.leader == self.getId()) ?<br>                                    ServerState.LEADING: learningState());<br><br>                            <span class="hljs-type">Vote</span> <span class="hljs-variable">endVote</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vote</span>(n.leader,<br>                                    n.zxid,<br>                                    n.electionEpoch,<br>                                    n.peerEpoch);<br>                            leaveInstance(endVote);<br>                            <span class="hljs-keyword">return</span> endVote;<br>                        &#125;<br>                    &#125;<br><br>                    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                     * Before joining an established ensemble, verify</span><br><span class="hljs-comment">                     * a majority is following the same leader.</span><br><span class="hljs-comment">                     */</span><br>                    outofelection.put(n.sid, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vote</span>(n.version,<br>                                                        n.leader,<br>                                                        n.zxid,<br>                                                        n.electionEpoch,<br>                                                        n.peerEpoch,<br>                                                        n.state));<br><br>                    <span class="hljs-keyword">if</span>(ooePredicate(outofelection, outofelection, n)) &#123;<br>                        <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>)&#123;<br>                            logicalclock.set(n.electionEpoch);<br>                            self.setPeerState((n.leader == self.getId()) ?<br>                                    ServerState.LEADING: learningState());<br>                        &#125;<br>                        <span class="hljs-type">Vote</span> <span class="hljs-variable">endVote</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vote</span>(n.leader,<br>                                                n.zxid,<br>                                                n.electionEpoch,<br>                                                n.peerEpoch);<br>                        leaveInstance(endVote);<br>                        <span class="hljs-keyword">return</span> endVote;<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    LOG.warn(<span class="hljs-string">&quot;Notification state unrecognized: &#123;&#125; (n.state), &#123;&#125; (n.sid)&quot;</span>,<br>                            n.state, n.sid);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                LOG.warn(<span class="hljs-string">&quot;Ignoring notification from non-cluster member &quot;</span> + n.sid);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(self.jmxLeaderElectionBean != <span class="hljs-literal">null</span>)&#123;<br>                MBeanRegistry.getInstance().unregister(<br>                        self.jmxLeaderElectionBean);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            LOG.warn(<span class="hljs-string">&quot;Failed to unregister with JMX&quot;</span>, e);<br>        &#125;<br>        self.jmxLeaderElectionBean = <span class="hljs-literal">null</span>;<br>        LOG.debug(<span class="hljs-string">&quot;Number of connection processing threads: &#123;&#125;&quot;</span>,<br>                manager.getConnectionThreadCount());<br>    &#125;<br>&#125;<br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">ooePredicate</span><span class="hljs-params">(HashMap&lt;Long,Vote&gt; recv,</span><br><span class="hljs-params">                                HashMap&lt;Long,Vote&gt; ooe,</span><br><span class="hljs-params">                                Notification n)</span> &#123;<br><br>    <span class="hljs-keyword">return</span> (termPredicate(recv, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vote</span>(n.version,<br>                                         n.leader,<br>                                         n.zxid,<br>                                         n.electionEpoch,<br>                                         n.peerEpoch,<br>                                         n.state))<br>            &amp;&amp; checkLeader(ooe, n.leader, n.electionEpoch));<br><br>&#125;<br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkLeader</span><span class="hljs-params">(</span><br><span class="hljs-params">        HashMap&lt;Long, Vote&gt; votes,</span><br><span class="hljs-params">        <span class="hljs-type">long</span> leader,</span><br><span class="hljs-params">        <span class="hljs-type">long</span> electionEpoch)</span>&#123;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">predicate</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * If everyone else thinks I&#x27;m the leader, I must be the leader.</span><br><span class="hljs-comment">     * The other two checks are just for the case in which I&#x27;m not the</span><br><span class="hljs-comment">     * leader. If I&#x27;m not the leader and I haven&#x27;t received a message</span><br><span class="hljs-comment">     * from leader stating that it is leading, then predicate is false.</span><br><span class="hljs-comment">     * 如果其他人认为自己是leader, 那么自己就是leader, 除两种情况以外:</span><br><span class="hljs-comment">     *  1. 逻辑时钟和自己的不一样(说明曾经挂过)</span><br><span class="hljs-comment">     *  2. leader的状态不是leader(只要我自己不是leader，且我没有收到leader给我发它是leader，那么就不行)</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-keyword">if</span>(leader != self.getId())&#123;<br>        <span class="hljs-keyword">if</span>(votes.get(leader) == <span class="hljs-literal">null</span>) predicate = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(votes.get(leader).getState() != ServerState.LEADING) predicate = <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(logicalclock.get() != electionEpoch) &#123;<br>        predicate = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> predicate;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="查看是否收到半数以上的票"><a href="#查看是否收到半数以上的票" class="headerlink" title="查看是否收到半数以上的票"></a>查看是否收到半数以上的票</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">termPredicate</span><span class="hljs-params">(</span><br><span class="hljs-params">        HashMap&lt;Long, Vote&gt; votes,</span><br><span class="hljs-params">        Vote vote)</span> &#123;<br><br>    HashSet&lt;Long&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Long&gt;();<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * First make the views consistent. Sometimes peers will have</span><br><span class="hljs-comment">     * different zxids for a server depending on timing.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">for</span> (Map.Entry&lt;Long,Vote&gt; entry : votes.entrySet()) &#123;<br>        <span class="hljs-keyword">if</span> (vote.equals(entry.getValue()))&#123;<br>            set.add(entry.getKey());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> self.getQuorumVerifier().containsQuorum(set);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsQuorum</span><span class="hljs-params">(HashSet&lt;Long&gt; set)</span>&#123;<br>    <span class="hljs-keyword">return</span> (set.size() &gt; half);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>zk</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>netty服务端启动流程</title>
    <link href="/2022/11/19/netty/nettystart/"/>
    <url>/2022/11/19/netty/nettystart/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>netty</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>线程池</title>
    <link href="/2022/11/19/jdk/threadPoolExecutor/"/>
    <url>/2022/11/19/jdk/threadPoolExecutor/</url>
    
    <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ul><li>有大量异步任务的时候提升性能</li><li>通过一系列参数对线程资源进行管理</li></ul><h2 id="构造线程池"><a href="#构造线程池" class="headerlink" title="构造线程池"></a>构造线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                          ThreadFactory threadFactory,</span><br><span class="hljs-params">                          RejectedExecutionHandler handler)</span> &#123;<br>    <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt;= <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt; corePoolSize ||<br>        keepAliveTime &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-literal">null</span> || threadFactory == <span class="hljs-literal">null</span> || handler == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-built_in">this</span>.corePoolSize = corePoolSize;<br>    <span class="hljs-built_in">this</span>.maximumPoolSize = maximumPoolSize;<br>    <span class="hljs-built_in">this</span>.workQueue = workQueue;<br>    <span class="hljs-built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br>    <span class="hljs-built_in">this</span>.threadFactory = threadFactory;<br>    <span class="hljs-built_in">this</span>.handler = handler;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><ul><li>corePoolSize: 核心线程数</li><li>maximumPoolSize: 最大线程数, 通过ctl 去获取到, 其中包含了core 的值大小</li><li>keepAliveTime: 当线程数超过核心线程数(corePoolSize)，或者允许核心线程超时时，线程会使用此超时时间。<br>否则，它们将永远等待新的工作。<br>Timeout in nanoseconds for idle threads waiting for work.<br>Threads use this timeout when there are more than corePoolSize<br>present or if allowCoreThreadTimeOut. Otherwise they wait<br>forever for new work.</li><li>unit: 空闲线程存活的时间单位</li><li>workQueue: 用于保存等待执行任务的队列</li><li>threadFactory:  用于创建线程的工厂</li><li>handler: 当任务队列满了以后, 用于何种策略去执行</li></ul><h2 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">ctl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br> <span class="hljs-comment">//表示运行状态</span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> Integer.SIZE - <span class="hljs-number">3</span>;<br> <span class="hljs-comment">//表示worker的个数</span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_MASK</span> <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;<br> <span class="hljs-comment">// runState is stored in the high-order bits</span><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  *           SHUTDOWN()</span><br><span class="hljs-comment">  * RUNNING ---------------&gt; SHUTDOWN</span><br><span class="hljs-comment">  *           SHUTDOWNNOW()</span><br><span class="hljs-comment">  * RUNNING ---------------&gt; STOP</span><br><span class="hljs-comment">  * 1. RUNNING: 可以接受任务, 以及对添加的任务进行处理</span><br><span class="hljs-comment">  * 2. SHUTDOWN: 不可以接受任务, 但是可以对已经添加的任务进行处理</span><br><span class="hljs-comment">  * 3. STOP: 不接受添加任务, 不处理已经添加的任务, 会中断正在处理的任务</span><br><span class="hljs-comment">  * 4. TIDYING: 所有的任务已终止, ctl 记录的任务数量为0, 此时可以执行回掉函数terminated()</span><br><span class="hljs-comment">  * 5. TERMINATED: 线程池彻底终止</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RUNNING</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHUTDOWN</span>   <span class="hljs-operator">=</span>  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">STOP</span>       <span class="hljs-operator">=</span>  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TIDYING</span>    <span class="hljs-operator">=</span>  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TERMINATED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br></code></pre></td></tr></table></figure><ul><li>高3位表示状态, 后29表示个数<br>为什么用高三位表示状态?<br>因为线程池的状态有五种, RUNNING、SHUTDOWN、STOP、TIDYING、TERMINATED, 三位刚好可以表示</li></ul><h2 id="EXECUTE"><a href="#EXECUTE" class="headerlink" title="EXECUTE"></a>EXECUTE</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Proceed in 3 steps:</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 1. If fewer than corePoolSize threads are running, try to</span><br><span class="hljs-comment">     * start a new thread with the given command as its first</span><br><span class="hljs-comment">     * task.  The call to addWorker atomically checks runState and</span><br><span class="hljs-comment">     * workerCount, and so prevents false alarms that would add</span><br><span class="hljs-comment">     * threads when it shouldn&#x27;t, by returning false.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 2. If a task can be successfully queued, then we still need</span><br><span class="hljs-comment">     * to double-check whether we should have added a thread</span><br><span class="hljs-comment">     * (because existing ones died since last checking) or that</span><br><span class="hljs-comment">     * the pool shut down since entry into this method. So we</span><br><span class="hljs-comment">     * recheck state and if necessary roll back the enqueuing if</span><br><span class="hljs-comment">     * stopped, or start a new thread if there are none.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 3. If we cannot queue task, then we try to add a new</span><br><span class="hljs-comment">     * thread.  If it fails, we know we are shut down or saturated</span><br><span class="hljs-comment">     * and so reject the task.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>    <span class="hljs-comment">//通过获取低位运行线程数的个数来和当前核心线程数进行比较, 判断是否需要直接创建worker</span><br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>))<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//创建失败的原因: 线程池状态变更为 SHUTDOWN 或 其他任务被提交执行导致工作线程数超过了核心线程数</span><br>        c = ctl.get();<br>    &#125;<br><br>     <span class="hljs-comment">//线程池运行为RUNNING 状态的, 并且向queue里面去放线程</span><br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 再次检查线程池状态</span><br><span class="hljs-comment">         * 如果状态不是running 则将任务从队列中移除</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>            reject(command);<br>        <span class="hljs-comment">//当worker的数量为0的时候, 创建新的worker 线程从queue中去消费任务</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>            addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果队列满了, 直接尝试去通过创建线程池去执行线程,</span><br><span class="hljs-comment">     *  无法创建说明到了最大线程数, 则执行拒绝策略</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))<br>        reject(command);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="/img/executor.execute.jpg"></p><h2 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h2><p>常见的拒绝策略:</p><ol><li>AbortPolicy: 丢弃任务并抛出RejectedExecutionException异常。(默认拒绝策略)</li><li>DiscardPolicy：丢弃任务，但是不抛出异常。</li><li>DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务。</li><li>CallerRunsPolicy：由调用方线程处理该任务<br>可以实现RejectedExecutionHandler的接口去进行自定义实现</li></ol><h2 id="创建WORKER"><a href="#创建WORKER" class="headerlink" title="创建WORKER"></a>创建WORKER</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-type">boolean</span> core)</span> &#123;<br>     retry:<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();;) &#123;<br>         <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>         <span class="hljs-comment">/**</span><br><span class="hljs-comment">          * 1. 线程池的状态为SHUTDOWN 并且</span><br><span class="hljs-comment">          *  1.1 线程池运行状态为STOP</span><br><span class="hljs-comment">          *  1.2 运行的task不为空</span><br><span class="hljs-comment">          *  1.3 workQueue 为空</span><br><span class="hljs-comment">          *  返回添加失败</span><br><span class="hljs-comment">          */</span><br>         <span class="hljs-keyword">if</span> (runStateAtLeast(c, SHUTDOWN)<br>             &amp;&amp; (runStateAtLeast(c, STOP)<br>                 || firstTask != <span class="hljs-literal">null</span><br>                 || workQueue.isEmpty()))<br>             <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>         <span class="hljs-keyword">for</span> (;;) &#123;<br>             <span class="hljs-comment">/**</span><br><span class="hljs-comment">              * 如果创建的是核心线程, 则判断当前线程数是否大于核心线程数</span><br><span class="hljs-comment">              * 如果创建的是非核心线程, 判断当前线程数是否大于最大核心线程数</span><br><span class="hljs-comment">              */</span><br>             <span class="hljs-keyword">if</span> (workerCountOf(c)<br>                 &gt;= ((core ? corePoolSize : maximumPoolSize) &amp; COUNT_MASK))<br>                 <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>             <span class="hljs-comment">/**</span><br><span class="hljs-comment">              * 通过CAS对worker 数量进行加1</span><br><span class="hljs-comment">              */</span><br><br>             <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br>                 <span class="hljs-keyword">break</span> retry;<br>             c = ctl.get();  <span class="hljs-comment">// Re-read ctl</span><br>             <span class="hljs-keyword">if</span> (runStateAtLeast(c, SHUTDOWN))<br>                 <span class="hljs-keyword">continue</span> retry;<br>             <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span><br>         &#125;<br>     &#125;<br><br>     <span class="hljs-type">boolean</span> <span class="hljs-variable">workerStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>     <span class="hljs-type">boolean</span> <span class="hljs-variable">workerAdded</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>     <span class="hljs-type">Worker</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>     <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-comment">//创建一个worker</span><br>         w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(firstTask);<br>         <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br>         <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>             <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>             mainLock.lock();<br>             <span class="hljs-keyword">try</span> &#123;<br>                 <span class="hljs-comment">// Recheck while holding lock.</span><br>                 <span class="hljs-comment">// Back out on ThreadFactory failure or if</span><br>                 <span class="hljs-comment">// shut down before lock acquired.</span><br>                 <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br><br>                 <span class="hljs-comment">/**</span><br><span class="hljs-comment">                  * 加读写锁后再次对线程状态进行查看, 判断线程的状态是否为running状态,</span><br><span class="hljs-comment">                  * 将当前task 加入到worker中,并且去最大线程池数量</span><br><span class="hljs-comment">                  * 加入到线程池后进行解锁, 运行worker</span><br><span class="hljs-comment">                  */</span><br>                 <span class="hljs-keyword">if</span> (isRunning(c) ||<br>                     (runStateLessThan(c, STOP) &amp;&amp; firstTask == <span class="hljs-literal">null</span>)) &#123;<br>                     <span class="hljs-keyword">if</span> (t.getState() != Thread.State.NEW)<br>                         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br>                     workers.add(w);<br>                     workerAdded = <span class="hljs-literal">true</span>;<br>                     <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> workers.size();<br>                     <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>                         largestPoolSize = s;<br>                 &#125;<br>             &#125; <span class="hljs-keyword">finally</span> &#123;<br>                 mainLock.unlock();<br>             &#125;<br>             <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>                 t.start();<br>                 workerStarted = <span class="hljs-literal">true</span>;<br>             &#125;<br>         &#125;<br>     &#125; <span class="hljs-keyword">finally</span> &#123;<br>         <span class="hljs-keyword">if</span> (! workerStarted)<br>             addWorkerFailed(w);<br>     &#125;<br>     <span class="hljs-keyword">return</span> workerStarted;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="流程图-1"><a href="#流程图-1" class="headerlink" title="流程图"></a>流程图</h3><p><img src="/img/executor.create.worker.jpg"></p><h3 id="上锁的原因"><a href="#上锁的原因" class="headerlink" title="上锁的原因"></a>上锁的原因</h3><ul><li>对worker的集合以及数据进行加锁的原因  <ul><li>中断风暴定义: 如果不用lock的话, 使用并发安全的集合, 同时有5个线程进行中断, 每个线程都会进行interruptIdleWorkers<ul><li>第一个线程发起了对worker 进行中断, 第二个线程再次发起, 变成了对中断线程的中断,因此简单一点, 只需要一个线程可以发起中断即可, 用锁来实现串行化</li></ul></li><li>加锁好维护一些静态数据: largestPoolSize, 如用volatile的话, 到addWorker的时候, 拿到的值不一定准确</li></ul></li></ul><h3 id="其中worker-对象自身继承于AQS"><a href="#其中worker-对象自身继承于AQS" class="headerlink" title="其中worker 对象自身继承于AQS"></a>其中worker 对象自身继承于AQS</h3><ul><li>在初始化所得时候, 将值设置为-1, 开始时候变为正的, 保证线程开始运行的时候才可以进行中断线程</li></ul><h2 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Worker(Runnable firstTask) &#123;<br>    setState(-<span class="hljs-number">1</span>); <span class="hljs-comment">// inhibit interrupts until runWorker</span><br>    <span class="hljs-built_in">this</span>.firstTask = firstTask;<br>    <span class="hljs-built_in">this</span>.thread = getThreadFactory().newThread(<span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="runWorker"><a href="#runWorker" class="headerlink" title="runWorker"></a>runWorker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runWorker</span><span class="hljs-params">(Worker w)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">wt</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> w.firstTask;<br>    w.firstTask = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化的时候将值设置为-1, 知道开始运行的时候才设置为0, 目的是为了线程只有在开始运行的时候才可以中断</span><br><span class="hljs-comment">     */</span><br>    w.unlock(); <span class="hljs-comment">// allow interrupts</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">completedAbruptly</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 当前任务为null 或者时获取不到任务时</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = getTask()) != <span class="hljs-literal">null</span>) &#123;<br>            w.lock();<br>            <span class="hljs-comment">// If pool is stopping, ensure thread is interrupted;</span><br>            <span class="hljs-comment">// if not, ensure thread is not interrupted.  This</span><br>            <span class="hljs-comment">// requires a recheck in second case to deal with</span><br>            <span class="hljs-comment">// shutdownNow race while clearing interrupt</span><br>            <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||<br>                 (Thread.interrupted() &amp;&amp;<br>                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;<br>                !wt.isInterrupted())<br>                wt.interrupt();<br>            <span class="hljs-keyword">try</span> &#123;<br>                beforeExecute(wt, task);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    task.run();<br>                    afterExecute(task, <span class="hljs-literal">null</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                    afterExecute(task, ex);<br>                    <span class="hljs-keyword">throw</span> ex;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                task = <span class="hljs-literal">null</span>;<br>                w.completedTasks++;<br>                w.unlock();<br>            &#125;<br>        &#125;<br>        completedAbruptly = <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 对work 进行退出</span><br><span class="hljs-comment">         */</span><br>        processWorkerExit(w, completedAbruptly);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>封装出来的worker在runWorker中进行运行真正的调度, 以及从队列当中获取任务去执行</li><li>只有getTasks 执行完了, 才会进行退出执行</li></ul><h3 id="getTasks"><a href="#getTasks" class="headerlink" title="getTasks"></a>getTasks</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Performs blocking or timed wait for a task, depending on</span><br><span class="hljs-comment"> * current configuration settings, or returns null if this worker</span><br><span class="hljs-comment"> * must exit because of any of:</span><br><span class="hljs-comment"> * 1. There are more than maximumPoolSize workers (due to</span><br><span class="hljs-comment"> *    a call to setMaximumPoolSize).</span><br><span class="hljs-comment"> * 2. The pool is stopped.</span><br><span class="hljs-comment"> * 3. The pool is shutdown and the queue is empty.</span><br><span class="hljs-comment"> * 4. This worker timed out waiting for a task, and timed-out</span><br><span class="hljs-comment"> *    workers are subject to termination (that is,</span><br><span class="hljs-comment"> *    &#123;<span class="hljs-doctag">@code</span> allowCoreThreadTimeOut || workerCount &gt; corePoolSize&#125;)</span><br><span class="hljs-comment"> *    both before and after the timed wait, and if the queue is</span><br><span class="hljs-comment"> *    non-empty, this worker is not the last thread in the pool.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  通过阻塞或者是超时等待获取到任务</span><br><span class="hljs-comment"> *  以下状态返回null</span><br><span class="hljs-comment"> *      1. 在设置了最大线程数, 当前的worker count 超过了最大线程数</span><br><span class="hljs-comment"> *      2. 线程池的状态为stop 的状态</span><br><span class="hljs-comment"> *      3. 线程池得状态为stop 或者是 shutdown 同时队列为空</span><br><span class="hljs-comment"> *      4. worker 发生了超时等待, 其中设置了 allowCoreThreadTimeOut 或者是当前线程数量超过了核心线程数, </span><br><span class="hljs-comment"> *          并且 queue 是空的   </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> task, or null if the worker must exit, in which case</span><br><span class="hljs-comment"> *         workerCount is decremented</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Runnable <span class="hljs-title function_">getTask</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">timedOut</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br><br>        <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 此时线程池工作状态为STOP, TIDYING, TERMINATED或者是shutdown</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (runStateAtLeast(c, SHUTDOWN)<br>            &amp;&amp; (runStateAtLeast(c, STOP) || workQueue.isEmpty())) &#123;<br>            decrementWorkerCount();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<br><br>        <span class="hljs-comment">// Are workers subject to culling?</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 1. 允许超时回收, 如果设置为, 则会回收所有的worker</span><br><span class="hljs-comment">         * 2. worker count 大于核心线程数量</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">timed</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 工作线程超过最大线程数或者获取当前任务超时了</span><br><span class="hljs-comment">         * 同时 当前的workqueue 为空了, 从而导致获取不到任务时</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))<br>            &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;<br>            <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> timed ?<br>                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :<br>                workQueue.take();<br>            <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> r;<br>            timedOut = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;<br>            timedOut = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>判断能否继续获取到task<ul><li>线程池的工作状态为STOP 或者是SHUTDOWN 并且没有任务要执行了</li><li>当前worker线程数大于1, 并且任务队列中没有可执行任务了<ul><li>对于大多数默认的, 当前worker 个数是否超过了核心线程数,或者是设置了运行超时(allowCoreThreadTimeOut)</li><li>当前的worker线程超过了最大线程数</li></ul></li></ul></li></ul><h3 id="退出worker"><a href="#退出worker" class="headerlink" title="退出worker"></a>退出worker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Performs cleanup and bookkeeping for a dying worker. Called</span><br><span class="hljs-comment"> * only from worker threads. Unless completedAbruptly is set,</span><br><span class="hljs-comment"> * assumes that workerCount has already been adjusted to account</span><br><span class="hljs-comment"> * for exit.  This method removes thread from worker set, and</span><br><span class="hljs-comment"> * possibly terminates the pool or replaces the worker if either</span><br><span class="hljs-comment"> * it exited due to user task exception or if fewer than</span><br><span class="hljs-comment"> * corePoolSize workers are running or queue is non-empty but</span><br><span class="hljs-comment"> * there are no workers.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 1. worker set 中 移除worker</span><br><span class="hljs-comment"> * 2. 替换worker, 由于前面的</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> w the worker</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> completedAbruptly if the worker died due to user exception</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processWorkerExit</span><span class="hljs-params">(Worker w, <span class="hljs-type">boolean</span> completedAbruptly)</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  如果是意外退出的, 则将工作线程减一</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (completedAbruptly) <span class="hljs-comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span><br>        decrementWorkerCount();<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        completedTaskCount += w.completedTasks;<br>        workers.remove(w);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br><br>    tryTerminate();<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 状态是RUNNING 或者是SHUTDOWN 并且不是意外退出的</span><br><span class="hljs-comment">     *      如果设置了allowCoreThreadTimeOut,则为0，否则为核心线程数, 保留最小的线程数</span><br><span class="hljs-comment">     *      如果核心数等于0 并且任务队列不为空, 的时候最小数为1.</span><br><span class="hljs-comment">     *          工作线程数大于等于最小值的时候不增加新的工作线程, 否则增加新的工作线程</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (runStateLessThan(c, STOP)) &#123;<br>        <span class="hljs-keyword">if</span> (!completedAbruptly) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut ? <span class="hljs-number">0</span> : corePoolSize;<br>            <span class="hljs-keyword">if</span> (min == <span class="hljs-number">0</span> &amp;&amp; ! workQueue.isEmpty())<br>                min = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (workerCountOf(c) &gt;= min)<br>                <span class="hljs-keyword">return</span>; <span class="hljs-comment">// replacement not needed</span><br>        &#125;<br>        addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="tryTerminate"><a href="#tryTerminate" class="headerlink" title="tryTerminate"></a>tryTerminate</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * Transitions to TERMINATED state if either (SHUTDOWN and pool</span><br><span class="hljs-comment">  * and queue empty) or (STOP and pool empty).  If otherwise</span><br><span class="hljs-comment">  * eligible to terminate but workerCount is nonzero, interrupts an</span><br><span class="hljs-comment">  * idle worker to ensure that shutdown signals propagate. This</span><br><span class="hljs-comment">  * method must be called following any action that might make</span><br><span class="hljs-comment">  * termination possible -- reducing worker count or removing tasks</span><br><span class="hljs-comment">  * from the queue during shutdown. The method is non-private to</span><br><span class="hljs-comment">  * allow access from ScheduledThreadPoolExecutor.</span><br><span class="hljs-comment">  * 线程池状态转换为TERMINATED</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryTerminate</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-keyword">for</span> (;;) &#123;<br>         <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>         <span class="hljs-keyword">if</span> (isRunning(c) ||<br>             runStateAtLeast(c, TIDYING) ||<br>             (runStateLessThan(c, STOP) &amp;&amp; ! workQueue.isEmpty()))<br>             <span class="hljs-keyword">return</span>;<br>         <span class="hljs-comment">/**</span><br><span class="hljs-comment">          * 如果工作线程的个数部位0，则中断所有的Idle 线程</span><br><span class="hljs-comment">          */</span><br>         <span class="hljs-keyword">if</span> (workerCountOf(c) != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// Eligible to terminate</span><br>             interruptIdleWorkers(ONLY_ONE);<br>             <span class="hljs-keyword">return</span>;<br>         &#125;<br><br>         <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>         mainLock.lock();<br>         <span class="hljs-keyword">try</span> &#123;<br>             <span class="hljs-comment">//将线程池的状态变为TIDYING</span><br>             <span class="hljs-keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="hljs-number">0</span>))) &#123;<br>                 <span class="hljs-keyword">try</span> &#123;<br>                     terminated();<br>                 &#125; <span class="hljs-keyword">finally</span> &#123;<br>                     <span class="hljs-comment">//将线程池的状态设置为TERMINATED</span><br>                     ctl.set(ctlOf(TERMINATED, <span class="hljs-number">0</span>));<br>                     termination.signalAll();<br>                 &#125;<br>                 <span class="hljs-keyword">return</span>;<br>             &#125;<br>         &#125; <span class="hljs-keyword">finally</span> &#123;<br>             mainLock.unlock();<br>         &#125;<br>         <span class="hljs-comment">// else retry on failed CAS</span><br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h2 id="显示退出"><a href="#显示退出" class="headerlink" title="显示退出"></a>显示退出</h2><h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><p>当调用shutdown()方法时，线程池会继续执行已提交的任务，但不再接受新的任务提交。<br>它会平缓地关闭线程池，即等待已提交的任务执行完成，然后逐渐停止线程池中的线程。<br>shutdown()方法会使线程池进入”正在关闭”的状态，可以通过isShutdown()方法来判断线程池是否处于关闭状态。<br>适用于希望让线程池中已提交的任务全部执行完毕，不接受新任务的情况，对于已提交的任务，可以调用awaitTermination()方法等待其执行完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        checkShutdownAccess();<br>        advanceRunState(SHUTDOWN);<br>        interruptIdleWorkers();<br>        onShutdown(); <span class="hljs-comment">// hook for ScheduledThreadPoolExecutor</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>    tryTerminate();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="interruptIdleWorkers"><a href="#interruptIdleWorkers" class="headerlink" title="interruptIdleWorkers"></a>interruptIdleWorkers</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptIdleWorkers</span><span class="hljs-params">(<span class="hljs-type">boolean</span> onlyOne)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (Worker w : workers) &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * w.tryLock 保证只能对空闲的线程进行中断, 里面调用加锁的方式是不可重入的</span><br><span class="hljs-comment">             *    worker 在开始允许的时候先会上锁, 从而导致正在允许的线程是拿不到锁的</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    t.interrupt();<br>                &#125; <span class="hljs-keyword">catch</span> (SecurityException ignore) &#123;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    w.unlock();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (onlyOne)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow"></a>shutdownNow</h3><p>当调用shutdownNow()方法时，线程池会尝试立即停止所有正在执行的任务，并且不再处理还未执行的任务队列。<br>它会尝试中断正在执行的任务，并返回尚未开始执行的任务列表。<br>shutdownNow()方法会使线程池进入”已终止”的状态，可以通过isTerminated()方法来判断线程池是否已经终止。<br>适用于希望尽快停止线程池并放弃尚未执行的任务的情况。<br>需要注意的是，无论是调用shutdown()还是shutdownNow()方法，都会停止线程池的接受新任务功能，但它们的行为和效果略有不同。具体选择哪种方法取决于你的需求和业务场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title function_">shutdownNow</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Runnable&gt; tasks;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        checkShutdownAccess();<br>        advanceRunState(STOP);<br>        interruptWorkers();<br>        tasks = drainQueue();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>    tryTerminate();<br>    <span class="hljs-keyword">return</span> tasks;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>shutdown 和 shutdownNow 的区别</p><ul><li>shutdown将运行状态改为shutdown, 并中断所有的空闲线程</li><li>shutdownNow 是将状态改为STOP, 中断所有线程, 返回为处理的任务</li><li>一般情况下，建议先调用shutdown()方法，等待已提交的任务执行完成，然后再判断线程池是否已经终止。如果需要尽快停止线程池并放弃尚未执行的任务，可以在一段时间后（如等待一段时间后仍未终止），再调用shutdownNow()方法来强制停止线程池。</li><li>总结：使用shutdown()方法时，线程池会平缓地关闭，允许已提交的任务执行完成；使用shutdownNow()方法时，线程池会立即停止并尝试中断正在执行的任务。根据需求选择合适的方法来关闭线程池。</li></ul></li><li><p>线程内部异常处理<br>  Runnable 去进行submit 提交的:<br>  线程池的方式: 线程池会catch 到异常, 具体是否会抛出给主线程, 需要根据主线程是否实现afterExecute<br>  通过Runnable.run() 的方式则不会感知到异常<br>  Callable 去进行提交的时候, 则可以通过future 返回异常</p></li></ul><p>直接说结论，需要分两种情况：</p><ul><li><p><strong>使用<code>execute()</code>提交任务</strong>：当任务通过<code>execute()</code>提交到线程池并在执行过程中抛出异常时，如果这个异常没有在任务内被捕获，那么该异常会导致当前线程终止，并且异常会被打印到控制台或日志文件中。线程池会检测到这种线程终止，并创建一个新线程来替换它，从而保持配置的线程数不变。</p></li><li><p><strong>使用<code>submit()</code>提交任务</strong>：对于通过<code>submit()</code>提交的任务，如果在任务执行中发生异常，这个异常不会直接打印出来。相反，异常会被封装在由<code>submit()</code>返回的<code>Future</code>对象中。当调用<code>Future.get()</code>方法时，可以捕获到一个<code>ExecutionException</code>。在这种情况下，线程不会因为异常而终止，它会继续存在于线程池中，准备执行后续的任务。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>jdk</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo-demo</title>
    <link href="/2022/11/19/hexo-demo/"/>
    <url>/2022/11/19/hexo-demo/</url>
    
    <content type="html"><![CDATA[<h3 id="通过npm-安装hexo"><a href="#通过npm-安装hexo" class="headerlink" title="通过npm 安装hexo"></a>通过npm 安装hexo</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs copy">npm install hexo-cli -g  <br></code></pre></td></tr></table></figure><h3 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a>初始化hexo</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs copy">hexo init hexo-archieve<br></code></pre></td></tr></table></figure><p>然后在博客目录下创建 _config.fluid.yml，将主题的 _config.yml 内容复制进去。<br>接下来，修改 Hexo 博客目录中的 _config.yml：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs copy">language: zh-CN  # 指定语言，会影响主题显示的语言。默认为en，英文<br>theme: fluid  # 指定主题<br></code></pre></td></tr></table></figure><h3 id="启动hexo-server"><a href="#启动hexo-server" class="headerlink" title="启动hexo server"></a>启动hexo server</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs copy">hexo server<br></code></pre></td></tr></table></figure><h3 id="关于github-配置"><a href="#关于github-配置" class="headerlink" title="关于github 配置"></a>关于github 配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs copy">deploy:  <br>  type: git  <br>  repo: &lt;repository url&gt; # https://github.com/pc-xie/pc-xie.github.io.git<br>  branch: [branch]  <br>  token: [token]<br></code></pre></td></tr></table></figure><h3 id="推送到github上"><a href="#推送到github上" class="headerlink" title="推送到github上"></a>推送到github上</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs copy">hexo clean<br>hexo deploy<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>demo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/11/19/hello-world/"/>
    <url>/2022/11/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>demo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hashMap</title>
    <link href="/2022/06/22/jdk/hashMap/"/>
    <url>/2022/06/22/jdk/hashMap/</url>
    
    <content type="html"><![CDATA[<h2 id="HashMap-简介"><a href="#HashMap-简介" class="headerlink" title="HashMap 简介"></a>HashMap 简介</h2><p>HashMap 主要用来存放键值对，它基于哈希表的Map接口实现</font>，是常用的Java集合之一。</p><p>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间，具体可以参考 <code>treeifyBin</code>方法。</p><p><a href="https://cloud.tencent.com/developer/article/1684414?from=article.detail.1676181">https://cloud.tencent.com/developer/article/1684414?from=article.detail.1676181</a></p><h2 id="底层数据结构分析"><a href="#底层数据结构分析" class="headerlink" title="底层数据结构分析"></a>底层数据结构分析</h2><h3 id="JDK1-8之前"><a href="#JDK1-8之前" class="headerlink" title="JDK1.8之前"></a>JDK1.8之前</h3><p>JDK1.8 之前 HashMap 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。<strong>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash  值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p><p><strong>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</strong></p><p>设计扰动函数原因:</p><pre><code class="hljs">1. 降低hash碰撞, 越越分散越好2. 这是一个高频的操作, 通过采用位运算提升效率</code></pre><p>不可以key 自带的hashCode 去计算hash, 而采用hashCode的高低位的原因:</p><pre><code class="hljs">1. key的hashCode 只是返回了键值自带的hash值，范围是2^-31 到 2^31 大概40亿的映射空间, 问题是那么大的映射空间内存放不下</code></pre><p><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></p><p>JDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-comment">// key.hashCode()：返回散列值也就是hashcode</span><br>    <span class="hljs-comment">// ^ ：按位异或</span><br>    <span class="hljs-comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span><br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>对比一下 JDK1.7的 HashMap 的 hash 方法源码.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(<span class="hljs-type">int</span> h)</span> &#123;<br>    <span class="hljs-comment">// This function ensures that hashCodes that differ only by</span><br>    <span class="hljs-comment">// constant multiples at each bit position have a bounded</span><br>    <span class="hljs-comment">// number of collisions (approximately 8 at default load factor).</span><br><br>    h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);<br>    <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p><p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><p><img src="/../../img/jdk/jvm/jdk1.7_hashmap.png" alt="jdk1.8之前的内部结构"></p><h3 id="JDK1-8之后"><a href="#JDK1-8之后" class="headerlink" title="JDK1.8之后"></a>JDK1.8之后</h3><p>相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p><p><img src="/../../img/jdk/jvm/jdk1.8_hashmap.png" alt="JDK1.8之后的HashMap底层数据结构"></p><ul><li><p><strong>loadFactor加载因子</strong></p><p>loadFactor加载因子是控制数组存放数据的疏密程度，loadFactor越趋近于1，那么   数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。</p><p><strong>loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值</strong>。</p><p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 &#x3D; 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p></li><li><p><strong>threshold</strong></p><p><strong>threshold &#x3D; capacity * loadFactor</strong>，<strong>当Size&gt;&#x3D;threshold</strong>的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。</p></li></ul><p><strong>Node节点类源码:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 继承自 Map.Entry&lt;K,V&gt;</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br>       <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<span class="hljs-comment">// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span><br>       <span class="hljs-keyword">final</span> K key;<span class="hljs-comment">//键</span><br>       V value;<span class="hljs-comment">//值</span><br>       <span class="hljs-comment">// 指向下一个节点</span><br>       Node&lt;K,V&gt; next;<br>       Node(<span class="hljs-type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;<br>            <span class="hljs-built_in">this</span>.hash = hash;<br>            <span class="hljs-built_in">this</span>.key = key;<br>            <span class="hljs-built_in">this</span>.value = value;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> K <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span>        &#123; <span class="hljs-keyword">return</span> key; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span>      &#123; <span class="hljs-keyword">return</span> value; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> key + <span class="hljs-string">&quot;=&quot;</span> + value; &#125;<br>        <span class="hljs-comment">// 重写hashCode()方法</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">setValue</span><span class="hljs-params">(V newValue)</span> &#123;<br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> value;<br>            value = newValue;<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>        <span class="hljs-comment">// 重写 equals() 方法</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>            <span class="hljs-keyword">if</span> (o == <span class="hljs-built_in">this</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Map.Entry) &#123;<br>                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;<br>                <span class="hljs-keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;<br>                    Objects.equals(value, e.getValue()))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>树节点类源码:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;<br>        TreeNode&lt;K,V&gt; parent;  <span class="hljs-comment">// 父</span><br>        TreeNode&lt;K,V&gt; left;    <span class="hljs-comment">// 左</span><br>        TreeNode&lt;K,V&gt; right;   <span class="hljs-comment">// 右</span><br>        TreeNode&lt;K,V&gt; prev;    <span class="hljs-comment">// needed to unlink next upon deletion</span><br>        <span class="hljs-type">boolean</span> red;           <span class="hljs-comment">// 判断颜色</span><br>        TreeNode(<span class="hljs-type">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;<br>            <span class="hljs-built_in">super</span>(hash, key, val, next);<br>        &#125;<br>        <span class="hljs-comment">// 返回根节点</span><br>        <span class="hljs-keyword">final</span> TreeNode&lt;K,V&gt; <span class="hljs-title function_">root</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="hljs-built_in">this</span>, p;;) &#123;<br>                <span class="hljs-keyword">if</span> ((p = r.parent) == <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span> r;<br>                r = p;<br>       &#125;<br></code></pre></td></tr></table></figure><h2 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>HashMap 中有四个构造方法，它们分别如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 默认构造函数。</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="hljs-comment">// all   other fields defaulted</span><br> &#125;<br><br> <span class="hljs-comment">// 包含另一个“Map”的构造函数</span><br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;<br>     <span class="hljs-built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;<br>     putMapEntries(m, <span class="hljs-literal">false</span>);<span class="hljs-comment">//下面会分析到这个方法</span><br> &#125;<br><br> <span class="hljs-comment">// 指定“容量大小”的构造函数</span><br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>     <span class="hljs-built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);<br> &#125;<br><br> <span class="hljs-comment">// 指定“容量大小”和“加载因子”的构造函数</span><br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor)</span> &#123;<br>     <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);<br>     <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>         initialCapacity = MAXIMUM_CAPACITY;<br>     <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> + loadFactor);<br>     <span class="hljs-built_in">this</span>.loadFactor = loadFactor;<br>     <span class="hljs-built_in">this</span>.threshold = tableSizeFor(initialCapacity);<br> &#125;<br></code></pre></td></tr></table></figure><p><strong>putMapEntries方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putMapEntries</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m, <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> m.size();<br>    <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 判断table是否已经初始化</span><br>        <span class="hljs-keyword">if</span> (table == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// pre-size</span><br>            <span class="hljs-comment">// 未初始化，s为m的实际元素个数</span><br>            <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> ((<span class="hljs-type">float</span>)s / loadFactor) + <span class="hljs-number">1.0F</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> ((ft &lt; (<span class="hljs-type">float</span>)MAXIMUM_CAPACITY) ?<br>                    (<span class="hljs-type">int</span>)ft : MAXIMUM_CAPACITY);<br>            <span class="hljs-comment">// 计算得到的t大于阈值，则初始化阈值</span><br>            <span class="hljs-keyword">if</span> (t &gt; threshold)<br>                threshold = tableSizeFor(t);<br>        &#125;<br>        <span class="hljs-comment">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s &gt; threshold)<br>            resize();<br>        <span class="hljs-comment">// 将m中的所有元素添加至HashMap中</span><br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">K</span>, ? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">V</span>&gt; e : m.entrySet()) &#123;<br>            <span class="hljs-type">K</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> e.getKey();<br>            <span class="hljs-type">V</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> e.getValue();<br>            putVal(hash(key), key, value, <span class="hljs-literal">false</span>, evict);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><p>HashMap只提供了put用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。</p><p><strong>对putVal方法添加元素的分析如下：</strong></p><ul><li>①如果定位到的数组位置没有元素 就直接插入。</li><li>②如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果key不相同，就判断p是否是一个树节点，如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)。</li></ul><p>ps:下图有一个小问题，来自 <a href="https://github.com/Snailclimb/JavaGuide/issues/608">issue#608</a>指出：直接覆盖之后应该就会 return，不会有后续操作。参考 JDK8 HashMap.java 658 行。</p><p><img src="/img/jdk/hashMap_put.png" alt="put方法"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">                   <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;<br>    <span class="hljs-comment">// table未初始化或者长度为0，进行扩容</span><br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        n = (tab = resize()).length;<br>    <span class="hljs-comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>        tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>    <span class="hljs-comment">// 桶中已经存在元素</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                <span class="hljs-comment">// 将第一个元素赋值给e，用e来记录</span><br>                e = p;<br>        <span class="hljs-comment">// hash值不相等，即key不相等；为红黑树结点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>            <span class="hljs-comment">// 放入树中</span><br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br>        <span class="hljs-comment">// 为链表结点</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 在链表最末插入结点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-comment">// 到达链表的尾部</span><br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// 在尾部插入新结点</span><br>                    p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">// 结点数量达到阈值，转化为红黑树</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-comment">// 跳出循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span><br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-comment">// 相等，跳出循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span><br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 记录e的value</span><br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>            <span class="hljs-comment">// onlyIfAbsent为false或者旧值为null</span><br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                <span class="hljs-comment">//用新值替换旧值</span><br>                e.value = value;<br>            <span class="hljs-comment">// 访问后回调</span><br>            afterNodeAccess(e);<br>            <span class="hljs-comment">// 返回旧值</span><br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 结构性修改</span><br>    ++modCount;<br>    <span class="hljs-comment">// 实际大小大于阈值则扩容</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    <span class="hljs-comment">// 插入后回调</span><br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>我们再来对比一下 JDK1.7 put方法的代码</strong></p><p><strong>对于put方法的分析如下：</strong></p><ul><li>①如果定位到的数组位置没有元素 就直接插入。</li><li>②如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的key比较，如果key相同就直接覆盖，不同就采用头插法插入元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span><br>    <span class="hljs-keyword">if</span> (table == EMPTY_TABLE) &#123;<br>    inflateTable(threshold);<br>&#125;  <br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> putForNullKey(value);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> hash(key);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexFor(hash, table.length);<br>    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="hljs-literal">null</span>; e = e.next) &#123; <span class="hljs-comment">// 先遍历</span><br>        Object k;<br>        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;<br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>            e.value = value;<br>            e.recordAccess(<span class="hljs-built_in">this</span>);<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br><br>    modCount++;<br>    addEntry(hash, key, value, i);  <span class="hljs-comment">// 再插入</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>    Node&lt;K,V&gt; e;<br>    <span class="hljs-keyword">return</span> (e = getNode(hash(key), key)) == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : e.value;<br>&#125;<br><br><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title function_">getNode</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="hljs-type">int</span> n; K k;<br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 数组元素相等</span><br>        <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span><br>            ((k = first.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>            <span class="hljs-keyword">return</span> first;<br>        <span class="hljs-comment">// 桶中不止一个节点</span><br>        <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 在树中get</span><br>            <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)<br>                <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);<br>            <span class="hljs-comment">// 在链表中get</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">return</span> e;<br>            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h3><p>进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCap</span> <span class="hljs-operator">=</span> (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldThr</span> <span class="hljs-operator">=</span> threshold;<br>    <span class="hljs-type">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<br>        &#125;<br>        <span class="hljs-comment">// 没超过最大值，就扩充为原来的2倍</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span><br>        newCap = oldThr;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// signifies using defaults</span><br>        newCap = DEFAULT_INITIAL_CAPACITY;<br>        newThr = (<span class="hljs-type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br>    <span class="hljs-comment">// 计算新的resize上限</span><br>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)newCap * loadFactor;<br>        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-type">float</span>)MAXIMUM_CAPACITY ? (<span class="hljs-type">int</span>)ft : Integer.MAX_VALUE);<br>    &#125;<br>    threshold = newThr;<br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[newCap];<br>    table = newTab;<br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 把每个bucket都移动到新的buckets中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;<br>                oldTab[j] = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)<br>                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)<br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, newTab, j, oldCap);<br>                <span class="hljs-keyword">else</span> &#123;<br>                    Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-keyword">do</span> &#123;<br>                        next = e.next;<br>                        <span class="hljs-comment">// 原索引</span><br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)<br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                loTail.next = e;<br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-comment">// 原索引+oldCap</span><br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)<br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">// 原索引放到bucket里</span><br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;<br>                        loTail.next = <span class="hljs-literal">null</span>;<br>                        newTab[j] = loHead;<br>                    &#125;<br>                    <span class="hljs-comment">// 原索引+oldCap放到bucket里</span><br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-literal">null</span>;<br>                        newTab[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newTab;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>jdk</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>netty</title>
    <link href="/2022/01/24/netty/eventLoop/"/>
    <url>/2022/01/24/netty/eventLoop/</url>
    
    <content type="html"><![CDATA[<h2 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h2><h3 id="创建bossGroup-和-workerGroup"><a href="#创建bossGroup-和-workerGroup" class="headerlink" title="创建bossGroup 和 workerGroup"></a>创建bossGroup 和 workerGroup</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">1</span>);<br><span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">workerGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br><span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br>bootstrap.group(bossGroup, workerGroup)<br>        .channel(NioServerSocketChannel.class)<br>        .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.INFO))<br>        .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ch.pipeline();<br>                pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IdleStateHandler</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, TimeUnit.SECONDS));<br>                pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpResponseEncoder</span>());<br>                pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpRequestDecoder</span>());<br>                pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpObjectAggregator</span>(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">64</span>));<br>            &#125;<br>        &#125;);<br><span class="hljs-type">Channel</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> bootstrap.bind(PORT).sync().channel();<br></code></pre></td></tr></table></figure><h3 id="初始化NioEventLoopGroup"><a href="#初始化NioEventLoopGroup" class="headerlink" title="初始化NioEventLoopGroup"></a>初始化NioEventLoopGroup</h3><ul><li>创建 eventLoopGroup 默认 的core 线程数: 不指定的情况下为核数的2倍</li><li>初始化类的关系NioEventLoopGroup -&gt; MultithreadEventLoopGroup -&gt;MultithreadEventExecutorGroup -&gt; AbstractEventExecutorGroup</li></ul><h4 id="MultithreadEventExecutorGroup-初始化的流程"><a href="#MultithreadEventExecutorGroup-初始化的流程" class="headerlink" title="MultithreadEventExecutorGroup 初始化的流程"></a>MultithreadEventExecutorGroup 初始化的流程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventExecutor</span>[nThreads];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nThreads; i ++) &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        children[i] = newChild(executor, args);<br>        success = <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Think about if this is a good exception type</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;failed to create a child event loop&quot;</span>, e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (!success) &#123;<br>            <span class="hljs-comment">//dosomething</span><br>        &#125;<br>    &#125;<br>&#125;<br>chooser = chooserFactory.newChooser(children);<br><span class="hljs-keyword">final</span> FutureListener&lt;Object&gt; terminationListener = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureListener</span>&lt;Object&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(Future&lt;Object&gt; future)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">if</span> (terminatedChildren.incrementAndGet() == children.length) &#123;<br>            terminationFuture.setSuccess(<span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">for</span> (EventExecutor e: children) &#123;<br>    e.terminationFuture().addListener(terminationListener);<br>&#125;<br>Set&lt;EventExecutor&gt; childrenSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;EventExecutor&gt;(children.length);<br>Collections.addAll(childrenSet, children);<br>readonlyChildren = Collections.unmodifiableSet(childrenSet);    <br></code></pre></td></tr></table></figure><p>其中children 初始化为EventExecutor[];newChild 初始化在 NioEventLoopGroup 中进行了初始化NioEventLoop -&gt; SingleThreadEventLoop -&gt; SingleThreadEventExecutor -&gt; AbstractScheduledEventExecutor -&gt; AbstractEventExecutor 其中在创建时进行传递的 NioEventLoopGroup 用的是this,因此传递过去的 loopGroup 是NioEventLoopGroup 自身EventExecutorChooser 在进行选择的时候会去根据判断loopGroup的size，如果是2的指数的话用指数选择器, 不是的话用普通选择器</p><ul><li>问题:为什么要这样去区分???<br>指数选择器和普通选择器可以更加高效去进行获取到loopGroup，原因是在进行 &amp; 操作比 % 更快</li></ul><h3 id="serverBootStrap相关初始化"><a href="#serverBootStrap相关初始化" class="headerlink" title="serverBootStrap相关初始化"></a>serverBootStrap相关初始化</h3><pre><code class="hljs">ServerBootstrap -&gt; AbstractBootstrap</code></pre><h4 id="绑定boss和worker信息"><a href="#绑定boss和worker信息" class="headerlink" title="绑定boss和worker信息"></a>绑定boss和worker信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">bootstrap.group(bossGroup, workerGroup)<br></code></pre></td></tr></table></figure><p>AbstractBootStrap 的group 绑定boss 信息, serverBootStrap 绑定worker信息</p><h4 id="初始化channel-Factory"><a href="#初始化channel-Factory" class="headerlink" title="初始化channel Factory"></a>初始化channel Factory</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">channel(NioServerSocketChannel.class)<br></code></pre></td></tr></table></figure><p>调用父类 AbstractBootstrap 的反射去构造channel</p><h4 id="绑定handler"><a href="#绑定handler" class="headerlink" title="绑定handler"></a>绑定handler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.INFO))<br>childHandler();<br></code></pre></td></tr></table></figure><p>handler 方法是属于AbstractBootstrap的, childHandler 方法是属于 ServerBootstrap<br>childHandler 用于处理客户端建立连接后, handler 用于处理初始化的过程</p><h4 id="绑定端口号"><a href="#绑定端口号" class="headerlink" title="绑定端口号"></a>绑定端口号</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> ChannelFuture <span class="hljs-title function_">doBind</span><span class="hljs-params">(<span class="hljs-keyword">final</span> SocketAddress localAddress)</span> &#123;<br>    <span class="hljs-comment">//初始化和注册</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">regFuture</span> <span class="hljs-operator">=</span> initAndRegister();<br>    <span class="hljs-comment">//拿到刚刚注册上去的channel</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> regFuture.channel();<br>    <span class="hljs-keyword">if</span> (regFuture.isDone()) &#123;<br>        <span class="hljs-type">ChannelPromise</span> <span class="hljs-variable">promise</span> <span class="hljs-operator">=</span> channel.newPromise();<br>        <span class="hljs-comment">//进行绑定</span><br>        doBind0(regFuture, channel, localAddress, promise);<br>        <span class="hljs-keyword">return</span> promise;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">PendingRegistrationPromise</span> <span class="hljs-variable">promise</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PendingRegistrationPromise</span>(channel);<br>        regFuture.addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelFutureListener</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                <span class="hljs-type">Throwable</span> <span class="hljs-variable">cause</span> <span class="hljs-operator">=</span> future.cause();<br>                <span class="hljs-keyword">if</span> (cause != <span class="hljs-literal">null</span>) &#123;<br>                    promise.setFailure(cause);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    promise.registered();<br>                    doBind0(regFuture, channel, localAddress, promise);<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">return</span> promise;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="初始化和注册"><a href="#初始化和注册" class="headerlink" title="初始化和注册"></a>初始化和注册</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title function_">initAndRegister</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//通过反射去初始化创建channel,NioServerSocketChannel 属性</span><br>        channel = channelFactory.newChannel();<br>        <span class="hljs-comment">//进行初始化channel</span><br>        init(channel);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-comment">//dosomething</span><br>    &#125;<br>    <span class="hljs-comment">//group 注册</span><br>    <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">regFuture</span> <span class="hljs-operator">=</span> config().group().register(channel);<br>    <span class="hljs-keyword">if</span> (regFuture.cause() != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (channel.isRegistered()) &#123;<br>            channel.close();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            channel.unsafe().closeForcibly();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> regFuture;<br>&#125;<br></code></pre></td></tr></table></figure><p>channelFactory 是在 group 初始化channel Factory的时候传进来的，因此调用时创建的时 NioServerSocketChannel<br>NioServerSocketChannel -&gt; AbstractNioMessageChannel -&gt; AbstractNioChannel -&gt; AbstractChannel<br>NioServerSocketChannel 在初始化时指定 SelectionKey.OP_ACCEPT<br>在AbstractChannel 中设置了 pipieline, pipeline 中创建了 DefaultChannelPipeline, 初始化的设置了双链表  </p><h4 id="初始化channel"><a href="#初始化channel" class="headerlink" title="初始化channel"></a>初始化channel</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(Channel channel)</span> &#123;<br>    setChannelOptions(channel, newOptionsArray(), logger);<br>    setAttributes(channel, attrs0().entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY));<br>    <span class="hljs-comment">//拿到 NioServerSocketChannel 属性pipeline(DefaultChannelPipeline)</span><br>    <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> channel.pipeline();<br>    <span class="hljs-comment">//拿到 worker 的 group 信息</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">currentChildGroup</span> <span class="hljs-operator">=</span> childGroup;<br>    <span class="hljs-comment">//拿到 worker 的 handler 信息</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelHandler</span> <span class="hljs-variable">currentChildHandler</span> <span class="hljs-operator">=</span> childHandler;<br>    <span class="hljs-keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;<br>    <span class="hljs-keyword">synchronized</span> (childOptions) &#123;<br>        currentChildOptions = childOptions.entrySet().toArray(EMPTY_OPTION_ARRAY);<br>    &#125;<br>    <span class="hljs-keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs = childAttrs.entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY);<br>    <span class="hljs-comment">// 增加pipeline</span><br>    p.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Channel ch)</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ch.pipeline();<br>            <span class="hljs-comment">//将初始化的handler 进行加入进来</span><br>            <span class="hljs-type">ChannelHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> config.handler();<br>            <span class="hljs-keyword">if</span> (handler != <span class="hljs-literal">null</span>) &#123;<br>                pipeline.addLast(handler);<br>            &#125;<br><br>            ch.eventLoop().execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrapAcceptor</span>(ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>在进行 addLast 的时候将ChannelInitializer 封装成一个 task 用于后面的回掉</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title function_">addLast</span><span class="hljs-params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> &#123;<br>    <span class="hljs-keyword">final</span> AbstractChannelHandlerContext newCtx;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        checkMultiplicity(handler);<br>        newCtx = newContext(group, filterName(name, handler), handler);<br>        addLast0(newCtx);<br>        <span class="hljs-keyword">if</span> (!registered) &#123;<br>            newCtx.setAddPending();<br>            callHandlerCallbackLater(newCtx, <span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>        <span class="hljs-comment">//dosomething</span><br>    &#125;<br>    <span class="hljs-comment">//dosomething</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="将channel-注册绑定"><a href="#将channel-注册绑定" class="headerlink" title="将channel 注册绑定"></a>将channel 注册绑定</h4><p>ChannelFuture regFuture &#x3D; config().group().register(channel);<br>其中EventGroup 是 刚刚在进行 group 绑定的是 bossGroup, bossGroup 中register 注册的是 MultithreadEventLoopGroup, MultithreadEventLoopGroup 在获取 EventLoop 的时候<br>调用的是父类的MultithreadEventExecutorGroup 的chooser选择一个线程池去创建，这里面选择的线程池是(初始化NioEventLoopGroup) 中提及的, NioEventLoop 调用<br>SingleThreadEventLoop中的register(Channel), 最终调用AbstractChannel 中 AbstractUnsafe 内部类 的 register 方法终于到了实际注册的地方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(EventLoop eventLoop, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> &#123;<br>    <span class="hljs-comment">//dosomething</span><br>    AbstractChannel.<span class="hljs-built_in">this</span>.eventLoop = eventLoop;<br>    <span class="hljs-keyword">if</span> (eventLoop.inEventLoop()) &#123;<br>        register0(promise);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            eventLoop.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    register0(promise);<br>                &#125;<br>            &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            <span class="hljs-comment">//dosomething</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="register0"><a href="#register0" class="headerlink" title="register0"></a>register0</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register0</span><span class="hljs-params">(ChannelPromise promise)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">firstRegistration</span> <span class="hljs-operator">=</span> neverRegistered;<br>        doRegister();<br>        neverRegistered = <span class="hljs-literal">false</span>;<br>        registered = <span class="hljs-literal">true</span>;<br><br>        pipeline.invokeHandlerAddedIfNeeded();<br>        safeSetSuccess(promise);<br><br>        pipeline.fireChannelRegistered();<br>        <span class="hljs-keyword">if</span> (isActive()) &#123;<br>            <span class="hljs-keyword">if</span> (firstRegistration) &#123;<br>                pipeline.fireChannelActive();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (config().isAutoRead()) &#123;<br>                beginRead();<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-comment">//dosomething</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="注册过程"><a href="#注册过程" class="headerlink" title="注册过程"></a>注册过程</h4><p>将自己去调用jdk 原生的进行注册<br>selectionKey &#x3D; javaChannel().register(eventLoop().unwrappedSelector(), 0, this);再去回掉绑定handler 时的 pendingHandlerCallbackHead, 里面会将child pipeline 和 boosBootStrap 绑定在一起拿到 boosBootStrap 的channel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ch.pipeline();<br><span class="hljs-type">ChannelHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> config.handler();<br><span class="hljs-keyword">if</span> (handler != <span class="hljs-literal">null</span>) &#123;<br>    pipeline.addLast(handler);<br>&#125;<br>ch.eventLoop().execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//boosBootStrap的pipeline 添加ServerBootstrapAcceptor, 其中currentChildHandler 为worker的handler</span><br>        pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrapAcceptor</span>(<br>                ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><pre><code class="hljs">inBound handler 中事件进行传递pipeline.fireChannelRegistered();</code></pre><p>#2. reactor 思想<br>#3. bossEventLoop 是如何接收到客户端的请求的?<br>#4. bossEventLoop 如何将事件给workerEventLoop的？<br>#5. eventLoop 轮训的时候，如何解决jdk的空轮训的bug 的？</p>]]></content>
    
    
    <categories>
      
      <category>netty</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
