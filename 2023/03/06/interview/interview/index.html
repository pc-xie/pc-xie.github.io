

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="pc-xie">
  <meta name="keywords" content="">
  
    <meta name="description" content="自我介绍我叫谢鹏程, 我研究生毕业于电子科技大学 计算机科学与技术专业，我一直从事于基础架构的相关工作, 目前在汇付天下中间价部门担任高级开发工程师的角色, 负责API 平台的开发与维护，主要致力于API平台的高可用、稳定性以及易用性的提升，我上一份工作是在携程框架架构研发部担任高级开发工程师，主要致力于公司的配置中心的高可用、稳定性以及易用性的提升 项目介绍1. 配置中心的架构     配置中心">
<meta property="og:type" content="article">
<meta property="og:title" content="pc-xie">
<meta property="og:url" content="http://localhost:4000/2023/03/06/interview/interview/index.html">
<meta property="og:site_name" content="pc-xie">
<meta property="og:description" content="自我介绍我叫谢鹏程, 我研究生毕业于电子科技大学 计算机科学与技术专业，我一直从事于基础架构的相关工作, 目前在汇付天下中间价部门担任高级开发工程师的角色, 负责API 平台的开发与维护，主要致力于API平台的高可用、稳定性以及易用性的提升，我上一份工作是在携程框架架构研发部担任高级开发工程师，主要致力于公司的配置中心的高可用、稳定性以及易用性的提升 项目介绍1. 配置中心的架构     配置中心">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://localhost:4000/img/jdk/hashMap_put.png">
<meta property="og:image" content="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/jvm/access-location-of-object-handle.png">
<meta property="og:image" content="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/jvm/access-location-of-object-handle-direct-pointer.png">
<meta property="article:published_time" content="2023-03-06T02:01:17.966Z">
<meta property="article:modified_time" content="2024-10-07T14:42:27.679Z">
<meta property="article:author" content="pc-xie">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/img/jdk/hashMap_put.png">
  
  
  
  <title>pc-xie</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"localhost","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text=""></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-03-06 10:01" pubdate>
          2023年3月6日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          11k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          89 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none"></h1>
            
            
              <div class="markdown-body">
                
                <h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><p>我叫谢鹏程, 我研究生毕业于电子科技大学 计算机科学与技术专业，我一直从事于基础架构的相关工作, 目前在汇付天下中间价部门担任高级开发工程师的角色, 负责API 平台的开发与维护，主要致力于API平台的高可用、稳定性以及易用性的提升，我上一份工作是在携程框架架构研发部担任高级开发工程师，主要致力于公司的配置中心的高可用、稳定性以及易用性的提升</p>
<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><pre><code class="hljs">1. 配置中心的架构
    配置中心总共由2个人进行维护, 我是里面的主要开发, 主要负责配置中心的性能、稳定性、以及易用性等提升. 在高可用上, 我们对对接用户的控台、客户端请求过来的服务端以及需要用户引入的客户端上都进行了相关的修改, 
    1. 降低了DB的变更压力, 大规模配置变更期间, 通过对数据库查询进行批量化操作, 降低了DB的压力
    2. 保护系统的连接资源, 通过对tomcat 的 请求进行异步化处理, 防止由于极端情况下, 由于tomcat 线程在处理业务逻辑时, 业务请求处理时间高, 导致tomcat 无法接受请求处理
    3. 为了进行自身核心逻辑的保护, 将一些边缘的逻辑进行弱依赖处理, 例如由于一些审计日志的行为, 将主流程进行bolck
    4. 针对来源方的不同级别, 分配不同的资源去进行处理, 例如我们的来源方有DB 的主从切换, 业务的restAPI 等等, 针对不同的需求, 进行限流, 并且分配不同的线程去进行处理
     


    1.1 配置中心由控制平面, 服务端, 客户端, 以及mysql数据库四部分组成, 用户可以通过restAPI 和 前端部分在控制平面上对数据进行变更, 客户端是需要用户主动去引入, 将配置文件拉取过去, 服务端的作用是负责接收控台变更的通知, 然后再将变更的配置文件通知给正在使用配置文件的客户端, 从而实现将配置文件热更新到用户的进程中去, 客户端和服务端之间会有长轮训请求在那里, 每个服务端的进程里面同时起了一个eureka, 用于服务端直接节点的相互注册. 数据库在里面起的作用是对配置文件的一个持久化. 具体的流程是 用户在控制平面对配置文件进行变更, 然后控制平面将配置文件的元信息(环境 + 应用名 + 文件名) 广播http 请求的通知给所有的服务端节点。服务端收到请求后, 会去找哪些客户端监听了对应的配置文件. 然后将最新的版本号下发给客户端, 客户端收到新的版本号后,再向服务端拉取配置文件内容
    我在里面主要承担配置中心的稳定性以及易用性上的提升.
    1. 配置文件的批量话操作和对读取数据的预热, 降低了配置文件中DB 被击穿, 导致DB 网络IO大, 从而降低了配置文件的一个延时
    2. 优化了YONG GC: 我们使用的GC方式是G1, 尝试通过提升年轻代的比例和 增加MaxGCPauseMillis 去对yong gc 进行优化, 将yong gc 从2秒优化到了500ms, 再通过将 G1 替换成zgc, 将gc 时间降低到了10ms
    3. 优化了FULL GC, 通过jmap dump 内存的文件, 再通过MAT 去分析内存的占用情况, 
    4. 优化了堆外内存的占用. 通过pmap 查看操作系统中内存的占用情况
    5. 提升了稳定性
2. API 网关上提升了性能
    2.1 网关是由控制平面, 服务端, zk, mysql, redis 数据库四部分组成的,
</code></pre>
<h1 id="java-基础"><a href="#java-基础" class="headerlink" title="java 基础"></a>java 基础</h1><h2 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>大体上, HashMap 是一个数组, 数组每一个元素是个单向链表, 数组是HashMap 的主体， 链表是为了解决hash碰撞存在的， 其中解决hash碰撞是通过拉链法去解决冲突, 在jdk1.8后在解决冲突的时候引入了红黑树，其中当链表中的长度大于8的时候，将链表转换成红黑树</p>
<h5 id="解决hash-冲突方法"><a href="#解决hash-冲突方法" class="headerlink" title="解决hash 冲突方法"></a>解决hash 冲突方法</h5><p>开放地址法<br>拉链法</p>
<h5 id="put"><a href="#put" class="headerlink" title="put"></a>put</h5><p><strong>对putVal方法添加元素的分析如下：</strong></p>
<ul>
<li>①如果定位到的数组位置没有元素 就直接插入。</li>
<li>②如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果key不相同，就判断p是否是一个树节点，如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)。</li>
</ul>
<p>ps:下图有一个小问题，来自 <a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/issues/608">issue#608</a>指出：直接覆盖之后应该就会 return，不会有后续操作。参考 JDK8 HashMap.java 658 行。</p>
<p><img src="/img/jdk/hashMap_put.png" srcset="/img/loading.gif" lazyload alt="put方法"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">                   <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;<br>    <span class="hljs-comment">// table未初始化或者长度为0，进行扩容</span><br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        n = (tab = resize()).length;<br>    <span class="hljs-comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>        tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>    <span class="hljs-comment">// 桶中已经存在元素</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                <span class="hljs-comment">// 将第一个元素赋值给e，用e来记录</span><br>                e = p;<br>        <span class="hljs-comment">// hash值不相等，即key不相等；为红黑树结点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>            <span class="hljs-comment">// 放入树中</span><br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br>        <span class="hljs-comment">// 为链表结点</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 在链表最末插入结点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-comment">// 到达链表的尾部</span><br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// 在尾部插入新结点</span><br>                    p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">// 结点数量达到阈值，转化为红黑树</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-comment">// 跳出循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span><br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-comment">// 相等，跳出循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span><br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 记录e的value</span><br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>            <span class="hljs-comment">// onlyIfAbsent为false或者旧值为null</span><br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                <span class="hljs-comment">//用新值替换旧值</span><br>                e.value = value;<br>            <span class="hljs-comment">// 访问后回调</span><br>            afterNodeAccess(e);<br>            <span class="hljs-comment">// 返回旧值</span><br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 结构性修改</span><br>    ++modCount;<br>    <span class="hljs-comment">// 实际大小大于阈值则扩容</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    <span class="hljs-comment">// 插入后回调</span><br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="get"><a href="#get" class="headerlink" title="get"></a>get</h5><h4 id="非线程安全"><a href="#非线程安全" class="headerlink" title="非线程安全"></a>非线程安全</h4><p>原子性: 一个操作是否属于不可分割的<br>可见性:一个线程对变量的操作对于另外一个线程是可见的<br>线程A 去进行判断数组中是否存在元素的时候, 线程B 去对值进行修改, 以及两个线程在往链表中插入的时候<br>有序性:代码的执行顺序和语句顺序是一致的</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_31709249/article/details/106952137">参照链接1</a><br><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/984814">参照链接2</a><br>通过synchronzed, Node 变量value的volatile 以及CAS 去保证安全性<br>其中synchronize锁的粒度为桶中头结点（包括链表Node结点，包装红黑树的TreeBin结),transient volatile Node&lt;K,V&gt;[] table;<br>① 如果数组未没初始化，则先去初始化<br>② 如果对应的桶中的元素为空，那就新建一个链表节点，然后利用CAS操作将其放到桶中的位置。这个过程是在③前面的，我们知道，扩容过程中，每个桶位置迁移节点结束后，会将这个节点设置为ForwardingNode，所以这种情况下，你尽管放，放了以后，扩容的线程总会遍历到这个节点，然后将这个节点迁移到新数组中<br>③ 如果有线程在扩容，那就先去帮助扩容，扩容结束后，再重新put。<br>④ 最后，如果当前桶中已经有元素了，那就用synchronized锁住当前桶中的节点，然后在桶中插入元素，插入的时候，要么插入到链表中，要么插入到红黑树中。我们发现，这里的锁粒度是很小的，就锁住一个桶，不像JDK1.7中的ConcurrentHashMap，是分段锁，锁住很多的桶，所以并发效率更高。<br>⑤ 插入结束后，如果是插入到链表中，那去看看链表的长度有没有超过长度阈值8，如果超过了，就要将链表转换成红黑树。<br>⑥ 最后，让size加一（这里其实是用baseCount来记录长度的，而且处理的时候很复杂，继续看下面）。</p>
<h4 id="更新size中的addCount"><a href="#更新size中的addCount" class="headerlink" title="更新size中的addCount"></a>更新size中的addCount</h4><p>建立一个CounterCell类型的数组counterCells,每个线程生成一个随机数,用随机数去当线程的hash码, 用来对应到counterCells数组中的位置, 把要更新的值放在CounterCell的value上, 最后同步到baseCount, 获取到一个总的个数</p>
<h5 id="高并发下如何保证addCount的值的正确性"><a href="#高并发下如何保证addCount的值的正确性" class="headerlink" title="高并发下如何保证addCount的值的正确性"></a>高并发下如何保证addCount的值的正确性</h5><h4 id="扩容过程"><a href="#扩容过程" class="headerlink" title="扩容过程"></a>扩容过程</h4><p>实现了并发迁移的过程<br>每个线程承担不小于 16 个桶中的元素的扩容，然后从右向左划分 16 个桶给当前线程去迁移，每当开始迁移一个桶中的元素的时候，线程会锁住当前槽中列表的头元素，扩容完成后会将这个桶中的节点设置为ForwardingNode。假设这时候正好有 get请求过来会仍旧在旧的列表中访问，如果是插入、修改、删除、合并、compute 等操作时遇到 ForwardingNode，就表示正在扩容，那当前线程会一起扩容，扩容结束后再做元素的更新操作</p>
<h4 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h4><p>get 的时候普通链表是不需要去进行加锁, value 是通过volatile去进行修饰的, 保证可见性</p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><h4 id="ArrayLists"><a href="#ArrayLists" class="headerlink" title="ArrayLists"></a>ArrayLists</h4><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><h2 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h2><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="jvm的内存模型"><a href="#jvm的内存模型" class="headerlink" title="jvm的内存模型"></a>jvm的内存模型</h3><p><a href="http://localhost:4000/2022/12/14/jvm/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98/">jvm 内存模型</a><br><strong>线程私有的：</strong></p>
<ul>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
</ul>
<p><strong>线程共享的：</strong></p>
<ul>
<li>堆</li>
<li>方法区(metaspace)</li>
<li>直接内存 (非运行时数据区的一部分)</li>
</ul>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器是当前线程所执行的字节码的行号指示器。他通过通过改变计数器的值来选取下一条需要执行的字节码指令，其中分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。<br>其中每个线程都是有一个程序计数器的，<br>另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器, 因此这部分空间占用的每个线程私有的，也是唯一不会发生OOM的</p>
<h4 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h4><p>（除去native 方法）java 方法的调用都是通过虚拟机栈来实现的，每次方法的调用时数据的传递都是通过栈进行传递，每个方法开始调用对应入栈，接受后都是对应到出栈。其中每个帧栈上拥有的数据有局部便量表、操作数栈、动态连接等<br><strong>局部变量表</strong> 主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。<br><strong>操作数栈</strong> 主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。<br>栈空间虽然不是无限的，但一般正常调用的情况下是不会出现问题的。不过，如果函数调用陷入无限循环的话，就会导致栈中被压入太多栈帧而占用太多空间，导致栈空间过深。那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 <code>StackOverFlowError</code> 错误。<br>栈中国可能会出现两种错误：</p>
<ul>
<li><strong><code>StackOverFlowError</code>：</strong> 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 <code>StackOverFlowError</code> 错误。</li>
<li><strong><code>OutOfMemoryError</code>：</strong> 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常。</li>
</ul>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法被执行的时候，本地方法创建的帧栈，用于本地方法存的局部便量表、操作数栈、等信息<br>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 <code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code> 两种错误。</p>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域。<strong>几乎所有的对象实例以及数组都在这里分配内存。</strong><br>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。<br>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p>
<ol>
<li>新生代内存(Young Generation) 又可以分为Eden区和Survivor 区</li>
<li>老生代(Old Generation)</li>
<li>metaspace 区<br>堆这里最容易出现的就是 <code>OutOfMemoryError</code> 错误，并且出现这种错误之后的表现形式还会有几种，比如：</li>
<li><strong><code>java.lang.OutOfMemoryError: GC Overhead Limit Exceeded</code></strong> ： 当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</li>
<li><strong><code>java.lang.OutOfMemoryError: Java heap space</code></strong> :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。</li>
</ol>
<h4 id="方法区（MetaSpace-永久代）"><a href="#方法区（MetaSpace-永久代）" class="headerlink" title="方法区（MetaSpace 永久代）"></a>方法区（MetaSpace 永久代）</h4><p>方法区是各个线程共享的区域，其中存放的数据有类的信息、方法信息、常量、静态变量等等。</p>
<blockquote>
<p>当元空间溢出时会得到如下错误： <code>java.lang.OutOfMemoryError: MetaSpace</code></p>
</blockquote>
<p>可以通过 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小</p>
<h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p>Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 <strong>常量池表(Constant Pool Table)</strong> 。<br>字面量是源代码中的固定值的表示法，即通过字面我们就能知道其值的含义。字面量包括整数、浮点数和字符串字面量，符号引用包括类符号引用、字段符号引用、方法符号引用和接口方法符号引用。<br>常量池表会在类加载后存放到方法区的运行时常量池中。<br>运行时常量池的功能类似于传统编程语言的符号表，尽管它包含了比典型符号表更广泛的数据。<br>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 错误。</p>
<h5 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h5><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在堆中创建字符串对象”ab“</span><br><span class="hljs-comment">// 将字符串对象”ab“的引用保存在字符串常量池中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">aa</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br><span class="hljs-comment">// 直接返回字符串常量池中字符串对象”ab“的引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>System.out.println(aa==bb);<span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
<p>HotSpot 虚拟机中字符串常量池的实现是 <code>src/hotspot/share/classfile/stringTable.cpp</code> ,<code>StringTable</code> 本质上就是一个<code>HashSet&lt;String&gt;</code> ,容量为 <code>StringTableSize</code>（可以通过 <code>-XX:StringTableSize</code> 参数来设置）。<br><strong><code>StringTable</code> 中保存的是字符串对象的引用，字符串对象的引用指向堆中的字符串对象。</strong><br>JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。<br><strong>JDK 1.7 为什么要将字符串常量池移动到堆中？</strong><br>主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。</p>
<h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p>
<h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><h4 id="Step1-类加载检查"><a href="#Step1-类加载检查" class="headerlink" title="Step1:类加载检查"></a>Step1:类加载检查</h4><p>虚拟机遇到一条 new 指令时，先去检查指令在常量池中能否找到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程(双亲委派)。</p>
<h4 id="Step2-分配内存"><a href="#Step2-分配内存" class="headerlink" title="Step2:分配内存"></a>Step2:分配内存</h4><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。<strong>分配内存的方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种。<br><strong>内存分配的两种方式</strong> （补充内容，需要掌握）：</p>
<ul>
<li>指针碰撞 ：<ul>
<li>适用场合 ：堆内存规整（即没有内存碎片）的情况下。</li>
<li>原理 ：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li>
<li>使用该分配方式的 GC 收集器：Serial, ParNew</li>
</ul>
</li>
<li>空闲列表 ：<ul>
<li>适用场合 ： 堆内存不规整的情况下。</li>
<li>原理 ：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。</li>
<li>使用该分配方式的 GC 收集器：CMS<br>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的。<br><strong>内存分配并发问题（补充内容，需要掌握）</strong><br>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</li>
</ul>
</li>
<li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li>
<li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li>
</ul>
<h4 id="Step3-初始化零值"><a href="#Step3-初始化零值" class="headerlink" title="Step3:初始化零值"></a>Step3:初始化零值</h4><p>内存分配完成后，虚拟机需要将分配到的内存空间都进行初始化（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<h4 id="Step4-设置对象头"><a href="#Step4-设置对象头" class="headerlink" title="Step4:设置对象头"></a>Step4:设置对象头</h4><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<h4 id="Step5-执行-init-方法"><a href="#Step5-执行-init-方法" class="headerlink" title="Step5:执行 init 方法"></a>Step5:执行 init 方法</h4><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。<br><strong>Hotspot 虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。<br><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。<br><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：<strong>使用句柄</strong>、<strong>直接指针</strong>。</p>
<h4 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h4><p>如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。<br><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/jvm/access-location-of-object-handle.png" srcset="/img/loading.gif" lazyload alt="对象的访问定位-使用句柄"></p>
<h4 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h4><p>如果使用直接指针访问，reference 中存储的直接就是对象的地址。<br><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/jvm/access-location-of-object-handle-direct-pointer.png" srcset="/img/loading.gif" lazyload alt="对象的访问定位-直接指针"><br>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。<br>HotSpot 虚拟机主要使用的就是这种方式来进行对象访问。</p>
<h3 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h3><p>Java中的双亲委派模型是一种类加载机制，用于保证程序安全和稳定性。它是由启动类加载器（Bootstrap ClassLoader）、扩展类加载器（Extension ClassLoader）和应用程序类加载器（Application ClassLoader）组成的。<br>当一个类被加载时，Java虚拟机（JVM）首先会将该请求委派给父类加载器，如果父类加载器无法加载该类，那么会再委派给父类加载器的父类加载器，直到委派到最顶层的启动类加载器。<br>如果启动类加载器无法加载该类，那么会回到应用程序类加载器，它会尝试从自己的类路径中加载该类。如果应用程序类加载器还是无法加载该类，那么会回到扩展类加载器，它会尝试从扩展路径中加载该类。如果扩展类加载器也无法加载该类，那么最后会回到启动类加载器，它会尝试从JVM的核心类库中加载该类。<br>这种双亲委派模型保证了Java类的安全性和稳定性。因为父类加载器的加载机制是先加载自己的类路径下的类，只有在找不到该类时才会委派给自己的子类加载器。这样就避免了Java类被重复加载的问题，也避免了恶意代码的加载。<br>总结来说，Java双亲委派机制的加载顺序为：<br>当一个类加载器收到一个类加载请求时，它首先将该请求委派给其父类加载器。<br>如果父类加载器无法加载该类，它会将该请求委派给自己的父类加载器。<br>这个过程将一直持续到最顶层的启动类加载器。<br>如果启动类加载器也无法加载该类，那么它将回到应用程序类加载器，然后再回到扩展类加载器。<br>最后，如果所有的类加载器都无法加载该类，那么将会抛出ClassNotFoundException异常</p>
<h4 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h4><p>Java中的类加载过程分为3个步骤：加载、连接和初始化。下面我们来逐步了解它们的具体过程。<br>加载：类加载器首先会通过类的全限定名来查找并加载对应的类文件。在加载过程中，类文件中的静态变量、方法等信息都会被加载到JVM的方法区中，并且为类在方法区中创建一个Class对象。<br>连接：连接阶段又可以分为3个小阶段，分别是验证、准备和解析<br>2.1 验证：在这个阶段，类加载器会对类文件进行验证，以确保它们符合Java虚拟机规范，并且没有安全方面的问题。<br>2.2 准备：在准备阶段，类加载器会为类中的静态变量分配内存，并设置默认值（0或null），同时也会为静态变量关联上对应的符号引用（即指向该变量在常量池中的引用）。<br>2.3 解析：在解析阶段，类加载器会将类文件中的符号引用替换成直接引用，即将常量池中的符号引用指向具体的内存地址，这样类中的代码就可以直接使用这些变量或方法了。<br>初始化：在初始化阶段，类加载器会按照代码中的要求执行类的初始化，如执行静态代码块、初始化静态变量等。如果类的父类还没有被初始化，则会先初始化其父类。同时，在初始化阶段，JVM也会对类做一些必要的初始化检查，如检查是否存在抽象方法没有被实现等。<br>总结来说，Java类的加载过程分为三个阶段：加载、连接和初始化。在加载阶段，类文件会被加载到方法区中，并为类创建一个Class对象；在连接阶段，类文件会被验证、准备和解析；在初始化阶段，类的代码会按照要求被执行，同时也会进行一些必要的检查。</p>
<h2 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h2><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div></div>
      <div>http://localhost:4000/2023/03/06/interview/interview/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>pc-xie</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年3月6日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/03/10/mysql/mysql_interview/" title="数据库面试">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">数据库面试</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/12/26/mysql/index/" title="索引">
                        <span class="hidden-mobile">索引</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
